// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/ecshreve/dndgen/ent/abilitybonus"
	"github.com/ecshreve/dndgen/ent/abilityscore"
	"github.com/ecshreve/dndgen/ent/alignment"
	"github.com/ecshreve/dndgen/ent/coin"
	"github.com/ecshreve/dndgen/ent/condition"
	"github.com/ecshreve/dndgen/ent/damagetype"
	"github.com/ecshreve/dndgen/ent/equipment"
	"github.com/ecshreve/dndgen/ent/equipmentcost"
	"github.com/ecshreve/dndgen/ent/feat"
	"github.com/ecshreve/dndgen/ent/language"
	"github.com/ecshreve/dndgen/ent/magicschool"
	"github.com/ecshreve/dndgen/ent/predicate"
	"github.com/ecshreve/dndgen/ent/race"
	"github.com/ecshreve/dndgen/ent/rule"
	"github.com/ecshreve/dndgen/ent/rulesection"
	"github.com/ecshreve/dndgen/ent/skill"
	"github.com/ecshreve/dndgen/ent/weaponproperty"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAbilityBonus   = "AbilityBonus"
	TypeAbilityScore   = "AbilityScore"
	TypeAlignment      = "Alignment"
	TypeCoin           = "Coin"
	TypeCondition      = "Condition"
	TypeDamageType     = "DamageType"
	TypeEquipment      = "Equipment"
	TypeEquipmentCost  = "EquipmentCost"
	TypeFeat           = "Feat"
	TypeLanguage       = "Language"
	TypeMagicSchool    = "MagicSchool"
	TypeRace           = "Race"
	TypeRule           = "Rule"
	TypeRuleSection    = "RuleSection"
	TypeSkill          = "Skill"
	TypeWeaponProperty = "WeaponProperty"
)

// AbilityBonusMutation represents an operation that mutates the AbilityBonus nodes in the graph.
type AbilityBonusMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	bonus                *int
	addbonus             *int
	clearedFields        map[string]struct{}
	ability_score        *int
	clearedability_score bool
	race                 *int
	clearedrace          bool
	done                 bool
	oldValue             func(context.Context) (*AbilityBonus, error)
	predicates           []predicate.AbilityBonus
}

var _ ent.Mutation = (*AbilityBonusMutation)(nil)

// abilitybonusOption allows management of the mutation configuration using functional options.
type abilitybonusOption func(*AbilityBonusMutation)

// newAbilityBonusMutation creates new mutation for the AbilityBonus entity.
func newAbilityBonusMutation(c config, op Op, opts ...abilitybonusOption) *AbilityBonusMutation {
	m := &AbilityBonusMutation{
		config:        c,
		op:            op,
		typ:           TypeAbilityBonus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbilityBonusID sets the ID field of the mutation.
func withAbilityBonusID(id int) abilitybonusOption {
	return func(m *AbilityBonusMutation) {
		var (
			err   error
			once  sync.Once
			value *AbilityBonus
		)
		m.oldValue = func(ctx context.Context) (*AbilityBonus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AbilityBonus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbilityBonus sets the old AbilityBonus of the mutation.
func withAbilityBonus(node *AbilityBonus) abilitybonusOption {
	return func(m *AbilityBonusMutation) {
		m.oldValue = func(context.Context) (*AbilityBonus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbilityBonusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbilityBonusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AbilityBonusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AbilityBonusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AbilityBonus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBonus sets the "bonus" field.
func (m *AbilityBonusMutation) SetBonus(i int) {
	m.bonus = &i
	m.addbonus = nil
}

// Bonus returns the value of the "bonus" field in the mutation.
func (m *AbilityBonusMutation) Bonus() (r int, exists bool) {
	v := m.bonus
	if v == nil {
		return
	}
	return *v, true
}

// OldBonus returns the old "bonus" field's value of the AbilityBonus entity.
// If the AbilityBonus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilityBonusMutation) OldBonus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBonus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBonus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBonus: %w", err)
	}
	return oldValue.Bonus, nil
}

// AddBonus adds i to the "bonus" field.
func (m *AbilityBonusMutation) AddBonus(i int) {
	if m.addbonus != nil {
		*m.addbonus += i
	} else {
		m.addbonus = &i
	}
}

// AddedBonus returns the value that was added to the "bonus" field in this mutation.
func (m *AbilityBonusMutation) AddedBonus() (r int, exists bool) {
	v := m.addbonus
	if v == nil {
		return
	}
	return *v, true
}

// ResetBonus resets all changes to the "bonus" field.
func (m *AbilityBonusMutation) ResetBonus() {
	m.bonus = nil
	m.addbonus = nil
}

// SetAbilityScoreID sets the "ability_score" edge to the AbilityScore entity by id.
func (m *AbilityBonusMutation) SetAbilityScoreID(id int) {
	m.ability_score = &id
}

// ClearAbilityScore clears the "ability_score" edge to the AbilityScore entity.
func (m *AbilityBonusMutation) ClearAbilityScore() {
	m.clearedability_score = true
}

// AbilityScoreCleared reports if the "ability_score" edge to the AbilityScore entity was cleared.
func (m *AbilityBonusMutation) AbilityScoreCleared() bool {
	return m.clearedability_score
}

// AbilityScoreID returns the "ability_score" edge ID in the mutation.
func (m *AbilityBonusMutation) AbilityScoreID() (id int, exists bool) {
	if m.ability_score != nil {
		return *m.ability_score, true
	}
	return
}

// AbilityScoreIDs returns the "ability_score" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AbilityScoreID instead. It exists only for internal usage by the builders.
func (m *AbilityBonusMutation) AbilityScoreIDs() (ids []int) {
	if id := m.ability_score; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAbilityScore resets all changes to the "ability_score" edge.
func (m *AbilityBonusMutation) ResetAbilityScore() {
	m.ability_score = nil
	m.clearedability_score = false
}

// SetRaceID sets the "race" edge to the Race entity by id.
func (m *AbilityBonusMutation) SetRaceID(id int) {
	m.race = &id
}

// ClearRace clears the "race" edge to the Race entity.
func (m *AbilityBonusMutation) ClearRace() {
	m.clearedrace = true
}

// RaceCleared reports if the "race" edge to the Race entity was cleared.
func (m *AbilityBonusMutation) RaceCleared() bool {
	return m.clearedrace
}

// RaceID returns the "race" edge ID in the mutation.
func (m *AbilityBonusMutation) RaceID() (id int, exists bool) {
	if m.race != nil {
		return *m.race, true
	}
	return
}

// RaceIDs returns the "race" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RaceID instead. It exists only for internal usage by the builders.
func (m *AbilityBonusMutation) RaceIDs() (ids []int) {
	if id := m.race; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRace resets all changes to the "race" edge.
func (m *AbilityBonusMutation) ResetRace() {
	m.race = nil
	m.clearedrace = false
}

// Where appends a list predicates to the AbilityBonusMutation builder.
func (m *AbilityBonusMutation) Where(ps ...predicate.AbilityBonus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AbilityBonusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AbilityBonusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AbilityBonus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AbilityBonusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AbilityBonusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AbilityBonus).
func (m *AbilityBonusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AbilityBonusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.bonus != nil {
		fields = append(fields, abilitybonus.FieldBonus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AbilityBonusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abilitybonus.FieldBonus:
		return m.Bonus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AbilityBonusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abilitybonus.FieldBonus:
		return m.OldBonus(ctx)
	}
	return nil, fmt.Errorf("unknown AbilityBonus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbilityBonusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abilitybonus.FieldBonus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBonus(v)
		return nil
	}
	return fmt.Errorf("unknown AbilityBonus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AbilityBonusMutation) AddedFields() []string {
	var fields []string
	if m.addbonus != nil {
		fields = append(fields, abilitybonus.FieldBonus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AbilityBonusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case abilitybonus.FieldBonus:
		return m.AddedBonus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbilityBonusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case abilitybonus.FieldBonus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBonus(v)
		return nil
	}
	return fmt.Errorf("unknown AbilityBonus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AbilityBonusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AbilityBonusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbilityBonusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AbilityBonus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AbilityBonusMutation) ResetField(name string) error {
	switch name {
	case abilitybonus.FieldBonus:
		m.ResetBonus()
		return nil
	}
	return fmt.Errorf("unknown AbilityBonus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AbilityBonusMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ability_score != nil {
		edges = append(edges, abilitybonus.EdgeAbilityScore)
	}
	if m.race != nil {
		edges = append(edges, abilitybonus.EdgeRace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AbilityBonusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case abilitybonus.EdgeAbilityScore:
		if id := m.ability_score; id != nil {
			return []ent.Value{*id}
		}
	case abilitybonus.EdgeRace:
		if id := m.race; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AbilityBonusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AbilityBonusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AbilityBonusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedability_score {
		edges = append(edges, abilitybonus.EdgeAbilityScore)
	}
	if m.clearedrace {
		edges = append(edges, abilitybonus.EdgeRace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AbilityBonusMutation) EdgeCleared(name string) bool {
	switch name {
	case abilitybonus.EdgeAbilityScore:
		return m.clearedability_score
	case abilitybonus.EdgeRace:
		return m.clearedrace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AbilityBonusMutation) ClearEdge(name string) error {
	switch name {
	case abilitybonus.EdgeAbilityScore:
		m.ClearAbilityScore()
		return nil
	case abilitybonus.EdgeRace:
		m.ClearRace()
		return nil
	}
	return fmt.Errorf("unknown AbilityBonus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AbilityBonusMutation) ResetEdge(name string) error {
	switch name {
	case abilitybonus.EdgeAbilityScore:
		m.ResetAbilityScore()
		return nil
	case abilitybonus.EdgeRace:
		m.ResetRace()
		return nil
	}
	return fmt.Errorf("unknown AbilityBonus edge %s", name)
}

// AbilityScoreMutation represents an operation that mutates the AbilityScore nodes in the graph.
type AbilityScoreMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	indx                   *string
	name                   *string
	desc                   *[]string
	appenddesc             []string
	full_name              *string
	clearedFields          map[string]struct{}
	skills                 map[int]struct{}
	removedskills          map[int]struct{}
	clearedskills          bool
	ability_bonuses        map[int]struct{}
	removedability_bonuses map[int]struct{}
	clearedability_bonuses bool
	done                   bool
	oldValue               func(context.Context) (*AbilityScore, error)
	predicates             []predicate.AbilityScore
}

var _ ent.Mutation = (*AbilityScoreMutation)(nil)

// abilityscoreOption allows management of the mutation configuration using functional options.
type abilityscoreOption func(*AbilityScoreMutation)

// newAbilityScoreMutation creates new mutation for the AbilityScore entity.
func newAbilityScoreMutation(c config, op Op, opts ...abilityscoreOption) *AbilityScoreMutation {
	m := &AbilityScoreMutation{
		config:        c,
		op:            op,
		typ:           TypeAbilityScore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbilityScoreID sets the ID field of the mutation.
func withAbilityScoreID(id int) abilityscoreOption {
	return func(m *AbilityScoreMutation) {
		var (
			err   error
			once  sync.Once
			value *AbilityScore
		)
		m.oldValue = func(ctx context.Context) (*AbilityScore, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AbilityScore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbilityScore sets the old AbilityScore of the mutation.
func withAbilityScore(node *AbilityScore) abilityscoreOption {
	return func(m *AbilityScoreMutation) {
		m.oldValue = func(context.Context) (*AbilityScore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbilityScoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbilityScoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AbilityScoreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AbilityScoreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AbilityScore.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *AbilityScoreMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *AbilityScoreMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the AbilityScore entity.
// If the AbilityScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilityScoreMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *AbilityScoreMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *AbilityScoreMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AbilityScoreMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AbilityScore entity.
// If the AbilityScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilityScoreMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AbilityScoreMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *AbilityScoreMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *AbilityScoreMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the AbilityScore entity.
// If the AbilityScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilityScoreMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *AbilityScoreMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *AbilityScoreMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *AbilityScoreMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[abilityscore.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *AbilityScoreMutation) DescCleared() bool {
	_, ok := m.clearedFields[abilityscore.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *AbilityScoreMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, abilityscore.FieldDesc)
}

// SetFullName sets the "full_name" field.
func (m *AbilityScoreMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *AbilityScoreMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the AbilityScore entity.
// If the AbilityScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilityScoreMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *AbilityScoreMutation) ResetFullName() {
	m.full_name = nil
}

// AddSkillIDs adds the "skills" edge to the Skill entity by ids.
func (m *AbilityScoreMutation) AddSkillIDs(ids ...int) {
	if m.skills == nil {
		m.skills = make(map[int]struct{})
	}
	for i := range ids {
		m.skills[ids[i]] = struct{}{}
	}
}

// ClearSkills clears the "skills" edge to the Skill entity.
func (m *AbilityScoreMutation) ClearSkills() {
	m.clearedskills = true
}

// SkillsCleared reports if the "skills" edge to the Skill entity was cleared.
func (m *AbilityScoreMutation) SkillsCleared() bool {
	return m.clearedskills
}

// RemoveSkillIDs removes the "skills" edge to the Skill entity by IDs.
func (m *AbilityScoreMutation) RemoveSkillIDs(ids ...int) {
	if m.removedskills == nil {
		m.removedskills = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.skills, ids[i])
		m.removedskills[ids[i]] = struct{}{}
	}
}

// RemovedSkills returns the removed IDs of the "skills" edge to the Skill entity.
func (m *AbilityScoreMutation) RemovedSkillsIDs() (ids []int) {
	for id := range m.removedskills {
		ids = append(ids, id)
	}
	return
}

// SkillsIDs returns the "skills" edge IDs in the mutation.
func (m *AbilityScoreMutation) SkillsIDs() (ids []int) {
	for id := range m.skills {
		ids = append(ids, id)
	}
	return
}

// ResetSkills resets all changes to the "skills" edge.
func (m *AbilityScoreMutation) ResetSkills() {
	m.skills = nil
	m.clearedskills = false
	m.removedskills = nil
}

// AddAbilityBonuseIDs adds the "ability_bonuses" edge to the AbilityBonus entity by ids.
func (m *AbilityScoreMutation) AddAbilityBonuseIDs(ids ...int) {
	if m.ability_bonuses == nil {
		m.ability_bonuses = make(map[int]struct{})
	}
	for i := range ids {
		m.ability_bonuses[ids[i]] = struct{}{}
	}
}

// ClearAbilityBonuses clears the "ability_bonuses" edge to the AbilityBonus entity.
func (m *AbilityScoreMutation) ClearAbilityBonuses() {
	m.clearedability_bonuses = true
}

// AbilityBonusesCleared reports if the "ability_bonuses" edge to the AbilityBonus entity was cleared.
func (m *AbilityScoreMutation) AbilityBonusesCleared() bool {
	return m.clearedability_bonuses
}

// RemoveAbilityBonuseIDs removes the "ability_bonuses" edge to the AbilityBonus entity by IDs.
func (m *AbilityScoreMutation) RemoveAbilityBonuseIDs(ids ...int) {
	if m.removedability_bonuses == nil {
		m.removedability_bonuses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ability_bonuses, ids[i])
		m.removedability_bonuses[ids[i]] = struct{}{}
	}
}

// RemovedAbilityBonuses returns the removed IDs of the "ability_bonuses" edge to the AbilityBonus entity.
func (m *AbilityScoreMutation) RemovedAbilityBonusesIDs() (ids []int) {
	for id := range m.removedability_bonuses {
		ids = append(ids, id)
	}
	return
}

// AbilityBonusesIDs returns the "ability_bonuses" edge IDs in the mutation.
func (m *AbilityScoreMutation) AbilityBonusesIDs() (ids []int) {
	for id := range m.ability_bonuses {
		ids = append(ids, id)
	}
	return
}

// ResetAbilityBonuses resets all changes to the "ability_bonuses" edge.
func (m *AbilityScoreMutation) ResetAbilityBonuses() {
	m.ability_bonuses = nil
	m.clearedability_bonuses = false
	m.removedability_bonuses = nil
}

// Where appends a list predicates to the AbilityScoreMutation builder.
func (m *AbilityScoreMutation) Where(ps ...predicate.AbilityScore) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AbilityScoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AbilityScoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AbilityScore, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AbilityScoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AbilityScoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AbilityScore).
func (m *AbilityScoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AbilityScoreMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.indx != nil {
		fields = append(fields, abilityscore.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, abilityscore.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, abilityscore.FieldDesc)
	}
	if m.full_name != nil {
		fields = append(fields, abilityscore.FieldFullName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AbilityScoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abilityscore.FieldIndx:
		return m.Indx()
	case abilityscore.FieldName:
		return m.Name()
	case abilityscore.FieldDesc:
		return m.Desc()
	case abilityscore.FieldFullName:
		return m.FullName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AbilityScoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abilityscore.FieldIndx:
		return m.OldIndx(ctx)
	case abilityscore.FieldName:
		return m.OldName(ctx)
	case abilityscore.FieldDesc:
		return m.OldDesc(ctx)
	case abilityscore.FieldFullName:
		return m.OldFullName(ctx)
	}
	return nil, fmt.Errorf("unknown AbilityScore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbilityScoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abilityscore.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case abilityscore.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case abilityscore.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case abilityscore.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	}
	return fmt.Errorf("unknown AbilityScore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AbilityScoreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AbilityScoreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbilityScoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AbilityScore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AbilityScoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(abilityscore.FieldDesc) {
		fields = append(fields, abilityscore.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AbilityScoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbilityScoreMutation) ClearField(name string) error {
	switch name {
	case abilityscore.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown AbilityScore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AbilityScoreMutation) ResetField(name string) error {
	switch name {
	case abilityscore.FieldIndx:
		m.ResetIndx()
		return nil
	case abilityscore.FieldName:
		m.ResetName()
		return nil
	case abilityscore.FieldDesc:
		m.ResetDesc()
		return nil
	case abilityscore.FieldFullName:
		m.ResetFullName()
		return nil
	}
	return fmt.Errorf("unknown AbilityScore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AbilityScoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.skills != nil {
		edges = append(edges, abilityscore.EdgeSkills)
	}
	if m.ability_bonuses != nil {
		edges = append(edges, abilityscore.EdgeAbilityBonuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AbilityScoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case abilityscore.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.skills))
		for id := range m.skills {
			ids = append(ids, id)
		}
		return ids
	case abilityscore.EdgeAbilityBonuses:
		ids := make([]ent.Value, 0, len(m.ability_bonuses))
		for id := range m.ability_bonuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AbilityScoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedskills != nil {
		edges = append(edges, abilityscore.EdgeSkills)
	}
	if m.removedability_bonuses != nil {
		edges = append(edges, abilityscore.EdgeAbilityBonuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AbilityScoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case abilityscore.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.removedskills))
		for id := range m.removedskills {
			ids = append(ids, id)
		}
		return ids
	case abilityscore.EdgeAbilityBonuses:
		ids := make([]ent.Value, 0, len(m.removedability_bonuses))
		for id := range m.removedability_bonuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AbilityScoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedskills {
		edges = append(edges, abilityscore.EdgeSkills)
	}
	if m.clearedability_bonuses {
		edges = append(edges, abilityscore.EdgeAbilityBonuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AbilityScoreMutation) EdgeCleared(name string) bool {
	switch name {
	case abilityscore.EdgeSkills:
		return m.clearedskills
	case abilityscore.EdgeAbilityBonuses:
		return m.clearedability_bonuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AbilityScoreMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AbilityScore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AbilityScoreMutation) ResetEdge(name string) error {
	switch name {
	case abilityscore.EdgeSkills:
		m.ResetSkills()
		return nil
	case abilityscore.EdgeAbilityBonuses:
		m.ResetAbilityBonuses()
		return nil
	}
	return fmt.Errorf("unknown AbilityScore edge %s", name)
}

// AlignmentMutation represents an operation that mutates the Alignment nodes in the graph.
type AlignmentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	abbr          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Alignment, error)
	predicates    []predicate.Alignment
}

var _ ent.Mutation = (*AlignmentMutation)(nil)

// alignmentOption allows management of the mutation configuration using functional options.
type alignmentOption func(*AlignmentMutation)

// newAlignmentMutation creates new mutation for the Alignment entity.
func newAlignmentMutation(c config, op Op, opts ...alignmentOption) *AlignmentMutation {
	m := &AlignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAlignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlignmentID sets the ID field of the mutation.
func withAlignmentID(id int) alignmentOption {
	return func(m *AlignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Alignment
		)
		m.oldValue = func(ctx context.Context) (*Alignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Alignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlignment sets the old Alignment of the mutation.
func withAlignment(node *Alignment) alignmentOption {
	return func(m *AlignmentMutation) {
		m.oldValue = func(context.Context) (*Alignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlignmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Alignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *AlignmentMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *AlignmentMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Alignment entity.
// If the Alignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlignmentMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *AlignmentMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *AlignmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlignmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Alignment entity.
// If the Alignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlignmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlignmentMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *AlignmentMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *AlignmentMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Alignment entity.
// If the Alignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlignmentMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *AlignmentMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *AlignmentMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *AlignmentMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[alignment.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *AlignmentMutation) DescCleared() bool {
	_, ok := m.clearedFields[alignment.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *AlignmentMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, alignment.FieldDesc)
}

// SetAbbr sets the "abbr" field.
func (m *AlignmentMutation) SetAbbr(s string) {
	m.abbr = &s
}

// Abbr returns the value of the "abbr" field in the mutation.
func (m *AlignmentMutation) Abbr() (r string, exists bool) {
	v := m.abbr
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbr returns the old "abbr" field's value of the Alignment entity.
// If the Alignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlignmentMutation) OldAbbr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbr: %w", err)
	}
	return oldValue.Abbr, nil
}

// ResetAbbr resets all changes to the "abbr" field.
func (m *AlignmentMutation) ResetAbbr() {
	m.abbr = nil
}

// Where appends a list predicates to the AlignmentMutation builder.
func (m *AlignmentMutation) Where(ps ...predicate.Alignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Alignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Alignment).
func (m *AlignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlignmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.indx != nil {
		fields = append(fields, alignment.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, alignment.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, alignment.FieldDesc)
	}
	if m.abbr != nil {
		fields = append(fields, alignment.FieldAbbr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alignment.FieldIndx:
		return m.Indx()
	case alignment.FieldName:
		return m.Name()
	case alignment.FieldDesc:
		return m.Desc()
	case alignment.FieldAbbr:
		return m.Abbr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alignment.FieldIndx:
		return m.OldIndx(ctx)
	case alignment.FieldName:
		return m.OldName(ctx)
	case alignment.FieldDesc:
		return m.OldDesc(ctx)
	case alignment.FieldAbbr:
		return m.OldAbbr(ctx)
	}
	return nil, fmt.Errorf("unknown Alignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alignment.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case alignment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case alignment.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case alignment.FieldAbbr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbr(v)
		return nil
	}
	return fmt.Errorf("unknown Alignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Alignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alignment.FieldDesc) {
		fields = append(fields, alignment.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlignmentMutation) ClearField(name string) error {
	switch name {
	case alignment.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Alignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlignmentMutation) ResetField(name string) error {
	switch name {
	case alignment.FieldIndx:
		m.ResetIndx()
		return nil
	case alignment.FieldName:
		m.ResetName()
		return nil
	case alignment.FieldDesc:
		m.ResetDesc()
		return nil
	case alignment.FieldAbbr:
		m.ResetAbbr()
		return nil
	}
	return fmt.Errorf("unknown Alignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlignmentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlignmentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlignmentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Alignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlignmentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Alignment edge %s", name)
}

// CoinMutation represents an operation that mutates the Coin nodes in the graph.
type CoinMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	indx                    *string
	name                    *string
	desc                    *[]string
	appenddesc              []string
	gold_conversion_rate    *float64
	addgold_conversion_rate *float64
	clearedFields           map[string]struct{}
	equipment_costs         map[int]struct{}
	removedequipment_costs  map[int]struct{}
	clearedequipment_costs  bool
	done                    bool
	oldValue                func(context.Context) (*Coin, error)
	predicates              []predicate.Coin
}

var _ ent.Mutation = (*CoinMutation)(nil)

// coinOption allows management of the mutation configuration using functional options.
type coinOption func(*CoinMutation)

// newCoinMutation creates new mutation for the Coin entity.
func newCoinMutation(c config, op Op, opts ...coinOption) *CoinMutation {
	m := &CoinMutation{
		config:        c,
		op:            op,
		typ:           TypeCoin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCoinID sets the ID field of the mutation.
func withCoinID(id int) coinOption {
	return func(m *CoinMutation) {
		var (
			err   error
			once  sync.Once
			value *Coin
		)
		m.oldValue = func(ctx context.Context) (*Coin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoin sets the old Coin of the mutation.
func withCoin(node *Coin) coinOption {
	return func(m *CoinMutation) {
		m.oldValue = func(context.Context) (*Coin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CoinMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CoinMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CoinMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CoinMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Coin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *CoinMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *CoinMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *CoinMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *CoinMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CoinMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CoinMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *CoinMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *CoinMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *CoinMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *CoinMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *CoinMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[coin.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *CoinMutation) DescCleared() bool {
	_, ok := m.clearedFields[coin.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *CoinMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, coin.FieldDesc)
}

// SetGoldConversionRate sets the "gold_conversion_rate" field.
func (m *CoinMutation) SetGoldConversionRate(f float64) {
	m.gold_conversion_rate = &f
	m.addgold_conversion_rate = nil
}

// GoldConversionRate returns the value of the "gold_conversion_rate" field in the mutation.
func (m *CoinMutation) GoldConversionRate() (r float64, exists bool) {
	v := m.gold_conversion_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldGoldConversionRate returns the old "gold_conversion_rate" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldGoldConversionRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoldConversionRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoldConversionRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoldConversionRate: %w", err)
	}
	return oldValue.GoldConversionRate, nil
}

// AddGoldConversionRate adds f to the "gold_conversion_rate" field.
func (m *CoinMutation) AddGoldConversionRate(f float64) {
	if m.addgold_conversion_rate != nil {
		*m.addgold_conversion_rate += f
	} else {
		m.addgold_conversion_rate = &f
	}
}

// AddedGoldConversionRate returns the value that was added to the "gold_conversion_rate" field in this mutation.
func (m *CoinMutation) AddedGoldConversionRate() (r float64, exists bool) {
	v := m.addgold_conversion_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetGoldConversionRate resets all changes to the "gold_conversion_rate" field.
func (m *CoinMutation) ResetGoldConversionRate() {
	m.gold_conversion_rate = nil
	m.addgold_conversion_rate = nil
}

// AddEquipmentCostIDs adds the "equipment_costs" edge to the EquipmentCost entity by ids.
func (m *CoinMutation) AddEquipmentCostIDs(ids ...int) {
	if m.equipment_costs == nil {
		m.equipment_costs = make(map[int]struct{})
	}
	for i := range ids {
		m.equipment_costs[ids[i]] = struct{}{}
	}
}

// ClearEquipmentCosts clears the "equipment_costs" edge to the EquipmentCost entity.
func (m *CoinMutation) ClearEquipmentCosts() {
	m.clearedequipment_costs = true
}

// EquipmentCostsCleared reports if the "equipment_costs" edge to the EquipmentCost entity was cleared.
func (m *CoinMutation) EquipmentCostsCleared() bool {
	return m.clearedequipment_costs
}

// RemoveEquipmentCostIDs removes the "equipment_costs" edge to the EquipmentCost entity by IDs.
func (m *CoinMutation) RemoveEquipmentCostIDs(ids ...int) {
	if m.removedequipment_costs == nil {
		m.removedequipment_costs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.equipment_costs, ids[i])
		m.removedequipment_costs[ids[i]] = struct{}{}
	}
}

// RemovedEquipmentCosts returns the removed IDs of the "equipment_costs" edge to the EquipmentCost entity.
func (m *CoinMutation) RemovedEquipmentCostsIDs() (ids []int) {
	for id := range m.removedequipment_costs {
		ids = append(ids, id)
	}
	return
}

// EquipmentCostsIDs returns the "equipment_costs" edge IDs in the mutation.
func (m *CoinMutation) EquipmentCostsIDs() (ids []int) {
	for id := range m.equipment_costs {
		ids = append(ids, id)
	}
	return
}

// ResetEquipmentCosts resets all changes to the "equipment_costs" edge.
func (m *CoinMutation) ResetEquipmentCosts() {
	m.equipment_costs = nil
	m.clearedequipment_costs = false
	m.removedequipment_costs = nil
}

// Where appends a list predicates to the CoinMutation builder.
func (m *CoinMutation) Where(ps ...predicate.Coin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CoinMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CoinMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Coin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CoinMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CoinMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Coin).
func (m *CoinMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CoinMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.indx != nil {
		fields = append(fields, coin.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, coin.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, coin.FieldDesc)
	}
	if m.gold_conversion_rate != nil {
		fields = append(fields, coin.FieldGoldConversionRate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CoinMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coin.FieldIndx:
		return m.Indx()
	case coin.FieldName:
		return m.Name()
	case coin.FieldDesc:
		return m.Desc()
	case coin.FieldGoldConversionRate:
		return m.GoldConversionRate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CoinMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coin.FieldIndx:
		return m.OldIndx(ctx)
	case coin.FieldName:
		return m.OldName(ctx)
	case coin.FieldDesc:
		return m.OldDesc(ctx)
	case coin.FieldGoldConversionRate:
		return m.OldGoldConversionRate(ctx)
	}
	return nil, fmt.Errorf("unknown Coin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoinMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coin.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case coin.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coin.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case coin.FieldGoldConversionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoldConversionRate(v)
		return nil
	}
	return fmt.Errorf("unknown Coin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CoinMutation) AddedFields() []string {
	var fields []string
	if m.addgold_conversion_rate != nil {
		fields = append(fields, coin.FieldGoldConversionRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CoinMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coin.FieldGoldConversionRate:
		return m.AddedGoldConversionRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoinMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coin.FieldGoldConversionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoldConversionRate(v)
		return nil
	}
	return fmt.Errorf("unknown Coin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CoinMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coin.FieldDesc) {
		fields = append(fields, coin.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CoinMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CoinMutation) ClearField(name string) error {
	switch name {
	case coin.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Coin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CoinMutation) ResetField(name string) error {
	switch name {
	case coin.FieldIndx:
		m.ResetIndx()
		return nil
	case coin.FieldName:
		m.ResetName()
		return nil
	case coin.FieldDesc:
		m.ResetDesc()
		return nil
	case coin.FieldGoldConversionRate:
		m.ResetGoldConversionRate()
		return nil
	}
	return fmt.Errorf("unknown Coin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CoinMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment_costs != nil {
		edges = append(edges, coin.EdgeEquipmentCosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CoinMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case coin.EdgeEquipmentCosts:
		ids := make([]ent.Value, 0, len(m.equipment_costs))
		for id := range m.equipment_costs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CoinMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedequipment_costs != nil {
		edges = append(edges, coin.EdgeEquipmentCosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CoinMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case coin.EdgeEquipmentCosts:
		ids := make([]ent.Value, 0, len(m.removedequipment_costs))
		for id := range m.removedequipment_costs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CoinMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedequipment_costs {
		edges = append(edges, coin.EdgeEquipmentCosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CoinMutation) EdgeCleared(name string) bool {
	switch name {
	case coin.EdgeEquipmentCosts:
		return m.clearedequipment_costs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CoinMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Coin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CoinMutation) ResetEdge(name string) error {
	switch name {
	case coin.EdgeEquipmentCosts:
		m.ResetEquipmentCosts()
		return nil
	}
	return fmt.Errorf("unknown Coin edge %s", name)
}

// ConditionMutation represents an operation that mutates the Condition nodes in the graph.
type ConditionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Condition, error)
	predicates    []predicate.Condition
}

var _ ent.Mutation = (*ConditionMutation)(nil)

// conditionOption allows management of the mutation configuration using functional options.
type conditionOption func(*ConditionMutation)

// newConditionMutation creates new mutation for the Condition entity.
func newConditionMutation(c config, op Op, opts ...conditionOption) *ConditionMutation {
	m := &ConditionMutation{
		config:        c,
		op:            op,
		typ:           TypeCondition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConditionID sets the ID field of the mutation.
func withConditionID(id int) conditionOption {
	return func(m *ConditionMutation) {
		var (
			err   error
			once  sync.Once
			value *Condition
		)
		m.oldValue = func(ctx context.Context) (*Condition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Condition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCondition sets the old Condition of the mutation.
func withCondition(node *Condition) conditionOption {
	return func(m *ConditionMutation) {
		m.oldValue = func(context.Context) (*Condition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConditionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConditionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConditionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConditionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Condition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *ConditionMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *ConditionMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Condition entity.
// If the Condition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConditionMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *ConditionMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *ConditionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConditionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Condition entity.
// If the Condition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConditionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConditionMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *ConditionMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *ConditionMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Condition entity.
// If the Condition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConditionMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *ConditionMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *ConditionMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *ConditionMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[condition.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *ConditionMutation) DescCleared() bool {
	_, ok := m.clearedFields[condition.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *ConditionMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, condition.FieldDesc)
}

// Where appends a list predicates to the ConditionMutation builder.
func (m *ConditionMutation) Where(ps ...predicate.Condition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConditionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConditionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Condition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConditionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConditionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Condition).
func (m *ConditionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConditionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, condition.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, condition.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, condition.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConditionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case condition.FieldIndx:
		return m.Indx()
	case condition.FieldName:
		return m.Name()
	case condition.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConditionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case condition.FieldIndx:
		return m.OldIndx(ctx)
	case condition.FieldName:
		return m.OldName(ctx)
	case condition.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Condition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConditionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case condition.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case condition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case condition.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Condition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConditionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConditionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConditionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Condition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConditionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(condition.FieldDesc) {
		fields = append(fields, condition.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConditionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConditionMutation) ClearField(name string) error {
	switch name {
	case condition.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Condition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConditionMutation) ResetField(name string) error {
	switch name {
	case condition.FieldIndx:
		m.ResetIndx()
		return nil
	case condition.FieldName:
		m.ResetName()
		return nil
	case condition.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Condition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConditionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConditionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConditionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConditionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConditionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConditionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConditionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Condition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConditionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Condition edge %s", name)
}

// DamageTypeMutation represents an operation that mutates the DamageType nodes in the graph.
type DamageTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DamageType, error)
	predicates    []predicate.DamageType
}

var _ ent.Mutation = (*DamageTypeMutation)(nil)

// damagetypeOption allows management of the mutation configuration using functional options.
type damagetypeOption func(*DamageTypeMutation)

// newDamageTypeMutation creates new mutation for the DamageType entity.
func newDamageTypeMutation(c config, op Op, opts ...damagetypeOption) *DamageTypeMutation {
	m := &DamageTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeDamageType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDamageTypeID sets the ID field of the mutation.
func withDamageTypeID(id int) damagetypeOption {
	return func(m *DamageTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *DamageType
		)
		m.oldValue = func(ctx context.Context) (*DamageType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DamageType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDamageType sets the old DamageType of the mutation.
func withDamageType(node *DamageType) damagetypeOption {
	return func(m *DamageTypeMutation) {
		m.oldValue = func(context.Context) (*DamageType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DamageTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DamageTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DamageTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DamageTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DamageType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *DamageTypeMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *DamageTypeMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the DamageType entity.
// If the DamageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DamageTypeMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *DamageTypeMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *DamageTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DamageTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DamageType entity.
// If the DamageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DamageTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DamageTypeMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *DamageTypeMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *DamageTypeMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the DamageType entity.
// If the DamageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DamageTypeMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *DamageTypeMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *DamageTypeMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *DamageTypeMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[damagetype.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *DamageTypeMutation) DescCleared() bool {
	_, ok := m.clearedFields[damagetype.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *DamageTypeMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, damagetype.FieldDesc)
}

// Where appends a list predicates to the DamageTypeMutation builder.
func (m *DamageTypeMutation) Where(ps ...predicate.DamageType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DamageTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DamageTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DamageType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DamageTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DamageTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DamageType).
func (m *DamageTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DamageTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, damagetype.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, damagetype.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, damagetype.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DamageTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case damagetype.FieldIndx:
		return m.Indx()
	case damagetype.FieldName:
		return m.Name()
	case damagetype.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DamageTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case damagetype.FieldIndx:
		return m.OldIndx(ctx)
	case damagetype.FieldName:
		return m.OldName(ctx)
	case damagetype.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown DamageType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DamageTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case damagetype.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case damagetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case damagetype.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown DamageType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DamageTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DamageTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DamageTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DamageType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DamageTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(damagetype.FieldDesc) {
		fields = append(fields, damagetype.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DamageTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DamageTypeMutation) ClearField(name string) error {
	switch name {
	case damagetype.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown DamageType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DamageTypeMutation) ResetField(name string) error {
	switch name {
	case damagetype.FieldIndx:
		m.ResetIndx()
		return nil
	case damagetype.FieldName:
		m.ResetName()
		return nil
	case damagetype.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown DamageType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DamageTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DamageTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DamageTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DamageTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DamageTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DamageTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DamageTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DamageType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DamageTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DamageType edge %s", name)
}

// EquipmentMutation represents an operation that mutates the Equipment nodes in the graph.
type EquipmentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	indx                   *string
	name                   *string
	desc                   *[]string
	appenddesc             []string
	clearedFields          map[string]struct{}
	equipment_costs        map[int]struct{}
	removedequipment_costs map[int]struct{}
	clearedequipment_costs bool
	done                   bool
	oldValue               func(context.Context) (*Equipment, error)
	predicates             []predicate.Equipment
}

var _ ent.Mutation = (*EquipmentMutation)(nil)

// equipmentOption allows management of the mutation configuration using functional options.
type equipmentOption func(*EquipmentMutation)

// newEquipmentMutation creates new mutation for the Equipment entity.
func newEquipmentMutation(c config, op Op, opts ...equipmentOption) *EquipmentMutation {
	m := &EquipmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentID sets the ID field of the mutation.
func withEquipmentID(id int) equipmentOption {
	return func(m *EquipmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Equipment
		)
		m.oldValue = func(ctx context.Context) (*Equipment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Equipment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipment sets the old Equipment of the mutation.
func withEquipment(node *Equipment) equipmentOption {
	return func(m *EquipmentMutation) {
		m.oldValue = func(context.Context) (*Equipment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Equipment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *EquipmentMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *EquipmentMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *EquipmentMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *EquipmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EquipmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EquipmentMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *EquipmentMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *EquipmentMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *EquipmentMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *EquipmentMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *EquipmentMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[equipment.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *EquipmentMutation) DescCleared() bool {
	_, ok := m.clearedFields[equipment.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *EquipmentMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, equipment.FieldDesc)
}

// AddEquipmentCostIDs adds the "equipment_costs" edge to the EquipmentCost entity by ids.
func (m *EquipmentMutation) AddEquipmentCostIDs(ids ...int) {
	if m.equipment_costs == nil {
		m.equipment_costs = make(map[int]struct{})
	}
	for i := range ids {
		m.equipment_costs[ids[i]] = struct{}{}
	}
}

// ClearEquipmentCosts clears the "equipment_costs" edge to the EquipmentCost entity.
func (m *EquipmentMutation) ClearEquipmentCosts() {
	m.clearedequipment_costs = true
}

// EquipmentCostsCleared reports if the "equipment_costs" edge to the EquipmentCost entity was cleared.
func (m *EquipmentMutation) EquipmentCostsCleared() bool {
	return m.clearedequipment_costs
}

// RemoveEquipmentCostIDs removes the "equipment_costs" edge to the EquipmentCost entity by IDs.
func (m *EquipmentMutation) RemoveEquipmentCostIDs(ids ...int) {
	if m.removedequipment_costs == nil {
		m.removedequipment_costs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.equipment_costs, ids[i])
		m.removedequipment_costs[ids[i]] = struct{}{}
	}
}

// RemovedEquipmentCosts returns the removed IDs of the "equipment_costs" edge to the EquipmentCost entity.
func (m *EquipmentMutation) RemovedEquipmentCostsIDs() (ids []int) {
	for id := range m.removedequipment_costs {
		ids = append(ids, id)
	}
	return
}

// EquipmentCostsIDs returns the "equipment_costs" edge IDs in the mutation.
func (m *EquipmentMutation) EquipmentCostsIDs() (ids []int) {
	for id := range m.equipment_costs {
		ids = append(ids, id)
	}
	return
}

// ResetEquipmentCosts resets all changes to the "equipment_costs" edge.
func (m *EquipmentMutation) ResetEquipmentCosts() {
	m.equipment_costs = nil
	m.clearedequipment_costs = false
	m.removedequipment_costs = nil
}

// Where appends a list predicates to the EquipmentMutation builder.
func (m *EquipmentMutation) Where(ps ...predicate.Equipment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EquipmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EquipmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Equipment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EquipmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EquipmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Equipment).
func (m *EquipmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, equipment.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, equipment.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, equipment.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipment.FieldIndx:
		return m.Indx()
	case equipment.FieldName:
		return m.Name()
	case equipment.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipment.FieldIndx:
		return m.OldIndx(ctx)
	case equipment.FieldName:
		return m.OldName(ctx)
	case equipment.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Equipment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipment.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case equipment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case equipment.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Equipment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipment.FieldDesc) {
		fields = append(fields, equipment.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentMutation) ClearField(name string) error {
	switch name {
	case equipment.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Equipment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentMutation) ResetField(name string) error {
	switch name {
	case equipment.FieldIndx:
		m.ResetIndx()
		return nil
	case equipment.FieldName:
		m.ResetName()
		return nil
	case equipment.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment_costs != nil {
		edges = append(edges, equipment.EdgeEquipmentCosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeEquipmentCosts:
		ids := make([]ent.Value, 0, len(m.equipment_costs))
		for id := range m.equipment_costs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedequipment_costs != nil {
		edges = append(edges, equipment.EdgeEquipmentCosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeEquipmentCosts:
		ids := make([]ent.Value, 0, len(m.removedequipment_costs))
		for id := range m.removedequipment_costs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedequipment_costs {
		edges = append(edges, equipment.EdgeEquipmentCosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentMutation) EdgeCleared(name string) bool {
	switch name {
	case equipment.EdgeEquipmentCosts:
		return m.clearedequipment_costs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Equipment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentMutation) ResetEdge(name string) error {
	switch name {
	case equipment.EdgeEquipmentCosts:
		m.ResetEquipmentCosts()
		return nil
	}
	return fmt.Errorf("unknown Equipment edge %s", name)
}

// EquipmentCostMutation represents an operation that mutates the EquipmentCost nodes in the graph.
type EquipmentCostMutation struct {
	config
	op               Op
	typ              string
	id               *int
	quantity         *int
	addquantity      *int
	clearedFields    map[string]struct{}
	coin             *int
	clearedcoin      bool
	equipment        *int
	clearedequipment bool
	done             bool
	oldValue         func(context.Context) (*EquipmentCost, error)
	predicates       []predicate.EquipmentCost
}

var _ ent.Mutation = (*EquipmentCostMutation)(nil)

// equipmentcostOption allows management of the mutation configuration using functional options.
type equipmentcostOption func(*EquipmentCostMutation)

// newEquipmentCostMutation creates new mutation for the EquipmentCost entity.
func newEquipmentCostMutation(c config, op Op, opts ...equipmentcostOption) *EquipmentCostMutation {
	m := &EquipmentCostMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentCost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentCostID sets the ID field of the mutation.
func withEquipmentCostID(id int) equipmentcostOption {
	return func(m *EquipmentCostMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentCost
		)
		m.oldValue = func(ctx context.Context) (*EquipmentCost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentCost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentCost sets the old EquipmentCost of the mutation.
func withEquipmentCost(node *EquipmentCost) equipmentcostOption {
	return func(m *EquipmentCostMutation) {
		m.oldValue = func(context.Context) (*EquipmentCost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentCostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentCostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentCostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentCostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EquipmentCost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *EquipmentCostMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *EquipmentCostMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the EquipmentCost entity.
// If the EquipmentCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentCostMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *EquipmentCostMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *EquipmentCostMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *EquipmentCostMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetEquipmentID sets the "equipment_id" field.
func (m *EquipmentCostMutation) SetEquipmentID(i int) {
	m.equipment = &i
}

// EquipmentID returns the value of the "equipment_id" field in the mutation.
func (m *EquipmentCostMutation) EquipmentID() (r int, exists bool) {
	v := m.equipment
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentID returns the old "equipment_id" field's value of the EquipmentCost entity.
// If the EquipmentCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentCostMutation) OldEquipmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentID: %w", err)
	}
	return oldValue.EquipmentID, nil
}

// ResetEquipmentID resets all changes to the "equipment_id" field.
func (m *EquipmentCostMutation) ResetEquipmentID() {
	m.equipment = nil
}

// SetCoinID sets the "coin_id" field.
func (m *EquipmentCostMutation) SetCoinID(i int) {
	m.coin = &i
}

// CoinID returns the value of the "coin_id" field in the mutation.
func (m *EquipmentCostMutation) CoinID() (r int, exists bool) {
	v := m.coin
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinID returns the old "coin_id" field's value of the EquipmentCost entity.
// If the EquipmentCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentCostMutation) OldCoinID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinID: %w", err)
	}
	return oldValue.CoinID, nil
}

// ResetCoinID resets all changes to the "coin_id" field.
func (m *EquipmentCostMutation) ResetCoinID() {
	m.coin = nil
}

// ClearCoin clears the "coin" edge to the Coin entity.
func (m *EquipmentCostMutation) ClearCoin() {
	m.clearedcoin = true
	m.clearedFields[equipmentcost.FieldCoinID] = struct{}{}
}

// CoinCleared reports if the "coin" edge to the Coin entity was cleared.
func (m *EquipmentCostMutation) CoinCleared() bool {
	return m.clearedcoin
}

// CoinIDs returns the "coin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoinID instead. It exists only for internal usage by the builders.
func (m *EquipmentCostMutation) CoinIDs() (ids []int) {
	if id := m.coin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoin resets all changes to the "coin" edge.
func (m *EquipmentCostMutation) ResetCoin() {
	m.coin = nil
	m.clearedcoin = false
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *EquipmentCostMutation) ClearEquipment() {
	m.clearedequipment = true
	m.clearedFields[equipmentcost.FieldEquipmentID] = struct{}{}
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *EquipmentCostMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *EquipmentCostMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *EquipmentCostMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// Where appends a list predicates to the EquipmentCostMutation builder.
func (m *EquipmentCostMutation) Where(ps ...predicate.EquipmentCost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EquipmentCostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EquipmentCostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EquipmentCost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EquipmentCostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EquipmentCostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EquipmentCost).
func (m *EquipmentCostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentCostMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.quantity != nil {
		fields = append(fields, equipmentcost.FieldQuantity)
	}
	if m.equipment != nil {
		fields = append(fields, equipmentcost.FieldEquipmentID)
	}
	if m.coin != nil {
		fields = append(fields, equipmentcost.FieldCoinID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentCostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentcost.FieldQuantity:
		return m.Quantity()
	case equipmentcost.FieldEquipmentID:
		return m.EquipmentID()
	case equipmentcost.FieldCoinID:
		return m.CoinID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentCostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentcost.FieldQuantity:
		return m.OldQuantity(ctx)
	case equipmentcost.FieldEquipmentID:
		return m.OldEquipmentID(ctx)
	case equipmentcost.FieldCoinID:
		return m.OldCoinID(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentCost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentCostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentcost.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case equipmentcost.FieldEquipmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentID(v)
		return nil
	case equipmentcost.FieldCoinID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinID(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentCost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentCostMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, equipmentcost.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentCostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmentcost.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentCostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmentcost.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentCost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentCostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentCostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentCostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EquipmentCost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentCostMutation) ResetField(name string) error {
	switch name {
	case equipmentcost.FieldQuantity:
		m.ResetQuantity()
		return nil
	case equipmentcost.FieldEquipmentID:
		m.ResetEquipmentID()
		return nil
	case equipmentcost.FieldCoinID:
		m.ResetCoinID()
		return nil
	}
	return fmt.Errorf("unknown EquipmentCost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentCostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.coin != nil {
		edges = append(edges, equipmentcost.EdgeCoin)
	}
	if m.equipment != nil {
		edges = append(edges, equipmentcost.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentCostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentcost.EdgeCoin:
		if id := m.coin; id != nil {
			return []ent.Value{*id}
		}
	case equipmentcost.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentCostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentCostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentCostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcoin {
		edges = append(edges, equipmentcost.EdgeCoin)
	}
	if m.clearedequipment {
		edges = append(edges, equipmentcost.EdgeEquipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentCostMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentcost.EdgeCoin:
		return m.clearedcoin
	case equipmentcost.EdgeEquipment:
		return m.clearedequipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentCostMutation) ClearEdge(name string) error {
	switch name {
	case equipmentcost.EdgeCoin:
		m.ClearCoin()
		return nil
	case equipmentcost.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentCost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentCostMutation) ResetEdge(name string) error {
	switch name {
	case equipmentcost.EdgeCoin:
		m.ResetCoin()
		return nil
	case equipmentcost.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentCost edge %s", name)
}

// FeatMutation represents an operation that mutates the Feat nodes in the graph.
type FeatMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Feat, error)
	predicates    []predicate.Feat
}

var _ ent.Mutation = (*FeatMutation)(nil)

// featOption allows management of the mutation configuration using functional options.
type featOption func(*FeatMutation)

// newFeatMutation creates new mutation for the Feat entity.
func newFeatMutation(c config, op Op, opts ...featOption) *FeatMutation {
	m := &FeatMutation{
		config:        c,
		op:            op,
		typ:           TypeFeat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatID sets the ID field of the mutation.
func withFeatID(id int) featOption {
	return func(m *FeatMutation) {
		var (
			err   error
			once  sync.Once
			value *Feat
		)
		m.oldValue = func(ctx context.Context) (*Feat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeat sets the old Feat of the mutation.
func withFeat(node *Feat) featOption {
	return func(m *FeatMutation) {
		m.oldValue = func(context.Context) (*Feat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *FeatMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *FeatMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Feat entity.
// If the Feat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *FeatMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *FeatMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Feat entity.
// If the Feat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *FeatMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *FeatMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Feat entity.
// If the Feat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *FeatMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *FeatMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *FeatMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[feat.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *FeatMutation) DescCleared() bool {
	_, ok := m.clearedFields[feat.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *FeatMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, feat.FieldDesc)
}

// Where appends a list predicates to the FeatMutation builder.
func (m *FeatMutation) Where(ps ...predicate.Feat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feat).
func (m *FeatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, feat.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, feat.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, feat.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feat.FieldIndx:
		return m.Indx()
	case feat.FieldName:
		return m.Name()
	case feat.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feat.FieldIndx:
		return m.OldIndx(ctx)
	case feat.FieldName:
		return m.OldName(ctx)
	case feat.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Feat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feat.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case feat.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feat.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Feat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feat.FieldDesc) {
		fields = append(fields, feat.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatMutation) ClearField(name string) error {
	switch name {
	case feat.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Feat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatMutation) ResetField(name string) error {
	switch name {
	case feat.FieldIndx:
		m.ResetIndx()
		return nil
	case feat.FieldName:
		m.ResetName()
		return nil
	case feat.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Feat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Feat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Feat edge %s", name)
}

// LanguageMutation represents an operation that mutates the Language nodes in the graph.
type LanguageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	language_type *language.LanguageType
	script        *language.Script
	clearedFields map[string]struct{}
	races         map[int]struct{}
	removedraces  map[int]struct{}
	clearedraces  bool
	done          bool
	oldValue      func(context.Context) (*Language, error)
	predicates    []predicate.Language
}

var _ ent.Mutation = (*LanguageMutation)(nil)

// languageOption allows management of the mutation configuration using functional options.
type languageOption func(*LanguageMutation)

// newLanguageMutation creates new mutation for the Language entity.
func newLanguageMutation(c config, op Op, opts ...languageOption) *LanguageMutation {
	m := &LanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLanguageID sets the ID field of the mutation.
func withLanguageID(id int) languageOption {
	return func(m *LanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *Language
		)
		m.oldValue = func(ctx context.Context) (*Language, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Language.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLanguage sets the old Language of the mutation.
func withLanguage(node *Language) languageOption {
	return func(m *LanguageMutation) {
		m.oldValue = func(context.Context) (*Language, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LanguageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LanguageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Language.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *LanguageMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *LanguageMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *LanguageMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *LanguageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LanguageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LanguageMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *LanguageMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *LanguageMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *LanguageMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *LanguageMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *LanguageMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[language.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *LanguageMutation) DescCleared() bool {
	_, ok := m.clearedFields[language.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *LanguageMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, language.FieldDesc)
}

// SetLanguageType sets the "language_type" field.
func (m *LanguageMutation) SetLanguageType(lt language.LanguageType) {
	m.language_type = &lt
}

// LanguageType returns the value of the "language_type" field in the mutation.
func (m *LanguageMutation) LanguageType() (r language.LanguageType, exists bool) {
	v := m.language_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageType returns the old "language_type" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldLanguageType(ctx context.Context) (v language.LanguageType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageType: %w", err)
	}
	return oldValue.LanguageType, nil
}

// ResetLanguageType resets all changes to the "language_type" field.
func (m *LanguageMutation) ResetLanguageType() {
	m.language_type = nil
}

// SetScript sets the "script" field.
func (m *LanguageMutation) SetScript(l language.Script) {
	m.script = &l
}

// Script returns the value of the "script" field in the mutation.
func (m *LanguageMutation) Script() (r language.Script, exists bool) {
	v := m.script
	if v == nil {
		return
	}
	return *v, true
}

// OldScript returns the old "script" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldScript(ctx context.Context) (v language.Script, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScript is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScript requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScript: %w", err)
	}
	return oldValue.Script, nil
}

// ResetScript resets all changes to the "script" field.
func (m *LanguageMutation) ResetScript() {
	m.script = nil
}

// AddRaceIDs adds the "races" edge to the Race entity by ids.
func (m *LanguageMutation) AddRaceIDs(ids ...int) {
	if m.races == nil {
		m.races = make(map[int]struct{})
	}
	for i := range ids {
		m.races[ids[i]] = struct{}{}
	}
}

// ClearRaces clears the "races" edge to the Race entity.
func (m *LanguageMutation) ClearRaces() {
	m.clearedraces = true
}

// RacesCleared reports if the "races" edge to the Race entity was cleared.
func (m *LanguageMutation) RacesCleared() bool {
	return m.clearedraces
}

// RemoveRaceIDs removes the "races" edge to the Race entity by IDs.
func (m *LanguageMutation) RemoveRaceIDs(ids ...int) {
	if m.removedraces == nil {
		m.removedraces = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.races, ids[i])
		m.removedraces[ids[i]] = struct{}{}
	}
}

// RemovedRaces returns the removed IDs of the "races" edge to the Race entity.
func (m *LanguageMutation) RemovedRacesIDs() (ids []int) {
	for id := range m.removedraces {
		ids = append(ids, id)
	}
	return
}

// RacesIDs returns the "races" edge IDs in the mutation.
func (m *LanguageMutation) RacesIDs() (ids []int) {
	for id := range m.races {
		ids = append(ids, id)
	}
	return
}

// ResetRaces resets all changes to the "races" edge.
func (m *LanguageMutation) ResetRaces() {
	m.races = nil
	m.clearedraces = false
	m.removedraces = nil
}

// Where appends a list predicates to the LanguageMutation builder.
func (m *LanguageMutation) Where(ps ...predicate.Language) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Language, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Language).
func (m *LanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LanguageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.indx != nil {
		fields = append(fields, language.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, language.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, language.FieldDesc)
	}
	if m.language_type != nil {
		fields = append(fields, language.FieldLanguageType)
	}
	if m.script != nil {
		fields = append(fields, language.FieldScript)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case language.FieldIndx:
		return m.Indx()
	case language.FieldName:
		return m.Name()
	case language.FieldDesc:
		return m.Desc()
	case language.FieldLanguageType:
		return m.LanguageType()
	case language.FieldScript:
		return m.Script()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case language.FieldIndx:
		return m.OldIndx(ctx)
	case language.FieldName:
		return m.OldName(ctx)
	case language.FieldDesc:
		return m.OldDesc(ctx)
	case language.FieldLanguageType:
		return m.OldLanguageType(ctx)
	case language.FieldScript:
		return m.OldScript(ctx)
	}
	return nil, fmt.Errorf("unknown Language field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case language.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case language.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case language.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case language.FieldLanguageType:
		v, ok := value.(language.LanguageType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageType(v)
		return nil
	case language.FieldScript:
		v, ok := value.(language.Script)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScript(v)
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LanguageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LanguageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Language numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LanguageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(language.FieldDesc) {
		fields = append(fields, language.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LanguageMutation) ClearField(name string) error {
	switch name {
	case language.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Language nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LanguageMutation) ResetField(name string) error {
	switch name {
	case language.FieldIndx:
		m.ResetIndx()
		return nil
	case language.FieldName:
		m.ResetName()
		return nil
	case language.FieldDesc:
		m.ResetDesc()
		return nil
	case language.FieldLanguageType:
		m.ResetLanguageType()
		return nil
	case language.FieldScript:
		m.ResetScript()
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.races != nil {
		edges = append(edges, language.EdgeRaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LanguageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case language.EdgeRaces:
		ids := make([]ent.Value, 0, len(m.races))
		for id := range m.races {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedraces != nil {
		edges = append(edges, language.EdgeRaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LanguageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case language.EdgeRaces:
		ids := make([]ent.Value, 0, len(m.removedraces))
		for id := range m.removedraces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedraces {
		edges = append(edges, language.EdgeRaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LanguageMutation) EdgeCleared(name string) bool {
	switch name {
	case language.EdgeRaces:
		return m.clearedraces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LanguageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Language unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LanguageMutation) ResetEdge(name string) error {
	switch name {
	case language.EdgeRaces:
		m.ResetRaces()
		return nil
	}
	return fmt.Errorf("unknown Language edge %s", name)
}

// MagicSchoolMutation represents an operation that mutates the MagicSchool nodes in the graph.
type MagicSchoolMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MagicSchool, error)
	predicates    []predicate.MagicSchool
}

var _ ent.Mutation = (*MagicSchoolMutation)(nil)

// magicschoolOption allows management of the mutation configuration using functional options.
type magicschoolOption func(*MagicSchoolMutation)

// newMagicSchoolMutation creates new mutation for the MagicSchool entity.
func newMagicSchoolMutation(c config, op Op, opts ...magicschoolOption) *MagicSchoolMutation {
	m := &MagicSchoolMutation{
		config:        c,
		op:            op,
		typ:           TypeMagicSchool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMagicSchoolID sets the ID field of the mutation.
func withMagicSchoolID(id int) magicschoolOption {
	return func(m *MagicSchoolMutation) {
		var (
			err   error
			once  sync.Once
			value *MagicSchool
		)
		m.oldValue = func(ctx context.Context) (*MagicSchool, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MagicSchool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMagicSchool sets the old MagicSchool of the mutation.
func withMagicSchool(node *MagicSchool) magicschoolOption {
	return func(m *MagicSchoolMutation) {
		m.oldValue = func(context.Context) (*MagicSchool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MagicSchoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MagicSchoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MagicSchoolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MagicSchoolMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MagicSchool.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *MagicSchoolMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *MagicSchoolMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the MagicSchool entity.
// If the MagicSchool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicSchoolMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *MagicSchoolMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *MagicSchoolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MagicSchoolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MagicSchool entity.
// If the MagicSchool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicSchoolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MagicSchoolMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *MagicSchoolMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *MagicSchoolMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the MagicSchool entity.
// If the MagicSchool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicSchoolMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *MagicSchoolMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *MagicSchoolMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *MagicSchoolMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[magicschool.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *MagicSchoolMutation) DescCleared() bool {
	_, ok := m.clearedFields[magicschool.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *MagicSchoolMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, magicschool.FieldDesc)
}

// Where appends a list predicates to the MagicSchoolMutation builder.
func (m *MagicSchoolMutation) Where(ps ...predicate.MagicSchool) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MagicSchoolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MagicSchoolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MagicSchool, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MagicSchoolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MagicSchoolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MagicSchool).
func (m *MagicSchoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MagicSchoolMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, magicschool.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, magicschool.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, magicschool.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MagicSchoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case magicschool.FieldIndx:
		return m.Indx()
	case magicschool.FieldName:
		return m.Name()
	case magicschool.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MagicSchoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case magicschool.FieldIndx:
		return m.OldIndx(ctx)
	case magicschool.FieldName:
		return m.OldName(ctx)
	case magicschool.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown MagicSchool field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MagicSchoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case magicschool.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case magicschool.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case magicschool.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown MagicSchool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MagicSchoolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MagicSchoolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MagicSchoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MagicSchool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MagicSchoolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(magicschool.FieldDesc) {
		fields = append(fields, magicschool.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MagicSchoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MagicSchoolMutation) ClearField(name string) error {
	switch name {
	case magicschool.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown MagicSchool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MagicSchoolMutation) ResetField(name string) error {
	switch name {
	case magicschool.FieldIndx:
		m.ResetIndx()
		return nil
	case magicschool.FieldName:
		m.ResetName()
		return nil
	case magicschool.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown MagicSchool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MagicSchoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MagicSchoolMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MagicSchoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MagicSchoolMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MagicSchoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MagicSchoolMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MagicSchoolMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MagicSchool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MagicSchoolMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MagicSchool edge %s", name)
}

// RaceMutation represents an operation that mutates the Race nodes in the graph.
type RaceMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	indx                   *string
	name                   *string
	speed                  *int
	addspeed               *int
	size                   *race.Size
	size_desc              *string
	alignment_desc         *string
	age_desc               *string
	language_desc          *string
	clearedFields          map[string]struct{}
	ability_bonuses        map[int]struct{}
	removedability_bonuses map[int]struct{}
	clearedability_bonuses bool
	languages              map[int]struct{}
	removedlanguages       map[int]struct{}
	clearedlanguages       bool
	done                   bool
	oldValue               func(context.Context) (*Race, error)
	predicates             []predicate.Race
}

var _ ent.Mutation = (*RaceMutation)(nil)

// raceOption allows management of the mutation configuration using functional options.
type raceOption func(*RaceMutation)

// newRaceMutation creates new mutation for the Race entity.
func newRaceMutation(c config, op Op, opts ...raceOption) *RaceMutation {
	m := &RaceMutation{
		config:        c,
		op:            op,
		typ:           TypeRace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRaceID sets the ID field of the mutation.
func withRaceID(id int) raceOption {
	return func(m *RaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Race
		)
		m.oldValue = func(ctx context.Context) (*Race, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Race.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRace sets the old Race of the mutation.
func withRace(node *Race) raceOption {
	return func(m *RaceMutation) {
		m.oldValue = func(context.Context) (*Race, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RaceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Race.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *RaceMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *RaceMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *RaceMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *RaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RaceMutation) ResetName() {
	m.name = nil
}

// SetSpeed sets the "speed" field.
func (m *RaceMutation) SetSpeed(i int) {
	m.speed = &i
	m.addspeed = nil
}

// Speed returns the value of the "speed" field in the mutation.
func (m *RaceMutation) Speed() (r int, exists bool) {
	v := m.speed
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeed returns the old "speed" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldSpeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeed: %w", err)
	}
	return oldValue.Speed, nil
}

// AddSpeed adds i to the "speed" field.
func (m *RaceMutation) AddSpeed(i int) {
	if m.addspeed != nil {
		*m.addspeed += i
	} else {
		m.addspeed = &i
	}
}

// AddedSpeed returns the value that was added to the "speed" field in this mutation.
func (m *RaceMutation) AddedSpeed() (r int, exists bool) {
	v := m.addspeed
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpeed resets all changes to the "speed" field.
func (m *RaceMutation) ResetSpeed() {
	m.speed = nil
	m.addspeed = nil
}

// SetSize sets the "size" field.
func (m *RaceMutation) SetSize(r race.Size) {
	m.size = &r
}

// Size returns the value of the "size" field in the mutation.
func (m *RaceMutation) Size() (r race.Size, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldSize(ctx context.Context) (v race.Size, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *RaceMutation) ResetSize() {
	m.size = nil
}

// SetSizeDesc sets the "size_desc" field.
func (m *RaceMutation) SetSizeDesc(s string) {
	m.size_desc = &s
}

// SizeDesc returns the value of the "size_desc" field in the mutation.
func (m *RaceMutation) SizeDesc() (r string, exists bool) {
	v := m.size_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeDesc returns the old "size_desc" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldSizeDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeDesc: %w", err)
	}
	return oldValue.SizeDesc, nil
}

// ResetSizeDesc resets all changes to the "size_desc" field.
func (m *RaceMutation) ResetSizeDesc() {
	m.size_desc = nil
}

// SetAlignmentDesc sets the "alignment_desc" field.
func (m *RaceMutation) SetAlignmentDesc(s string) {
	m.alignment_desc = &s
}

// AlignmentDesc returns the value of the "alignment_desc" field in the mutation.
func (m *RaceMutation) AlignmentDesc() (r string, exists bool) {
	v := m.alignment_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldAlignmentDesc returns the old "alignment_desc" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldAlignmentDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlignmentDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlignmentDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlignmentDesc: %w", err)
	}
	return oldValue.AlignmentDesc, nil
}

// ResetAlignmentDesc resets all changes to the "alignment_desc" field.
func (m *RaceMutation) ResetAlignmentDesc() {
	m.alignment_desc = nil
}

// SetAgeDesc sets the "age_desc" field.
func (m *RaceMutation) SetAgeDesc(s string) {
	m.age_desc = &s
}

// AgeDesc returns the value of the "age_desc" field in the mutation.
func (m *RaceMutation) AgeDesc() (r string, exists bool) {
	v := m.age_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldAgeDesc returns the old "age_desc" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldAgeDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgeDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgeDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgeDesc: %w", err)
	}
	return oldValue.AgeDesc, nil
}

// ResetAgeDesc resets all changes to the "age_desc" field.
func (m *RaceMutation) ResetAgeDesc() {
	m.age_desc = nil
}

// SetLanguageDesc sets the "language_desc" field.
func (m *RaceMutation) SetLanguageDesc(s string) {
	m.language_desc = &s
}

// LanguageDesc returns the value of the "language_desc" field in the mutation.
func (m *RaceMutation) LanguageDesc() (r string, exists bool) {
	v := m.language_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageDesc returns the old "language_desc" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldLanguageDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageDesc: %w", err)
	}
	return oldValue.LanguageDesc, nil
}

// ResetLanguageDesc resets all changes to the "language_desc" field.
func (m *RaceMutation) ResetLanguageDesc() {
	m.language_desc = nil
}

// AddAbilityBonuseIDs adds the "ability_bonuses" edge to the AbilityBonus entity by ids.
func (m *RaceMutation) AddAbilityBonuseIDs(ids ...int) {
	if m.ability_bonuses == nil {
		m.ability_bonuses = make(map[int]struct{})
	}
	for i := range ids {
		m.ability_bonuses[ids[i]] = struct{}{}
	}
}

// ClearAbilityBonuses clears the "ability_bonuses" edge to the AbilityBonus entity.
func (m *RaceMutation) ClearAbilityBonuses() {
	m.clearedability_bonuses = true
}

// AbilityBonusesCleared reports if the "ability_bonuses" edge to the AbilityBonus entity was cleared.
func (m *RaceMutation) AbilityBonusesCleared() bool {
	return m.clearedability_bonuses
}

// RemoveAbilityBonuseIDs removes the "ability_bonuses" edge to the AbilityBonus entity by IDs.
func (m *RaceMutation) RemoveAbilityBonuseIDs(ids ...int) {
	if m.removedability_bonuses == nil {
		m.removedability_bonuses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ability_bonuses, ids[i])
		m.removedability_bonuses[ids[i]] = struct{}{}
	}
}

// RemovedAbilityBonuses returns the removed IDs of the "ability_bonuses" edge to the AbilityBonus entity.
func (m *RaceMutation) RemovedAbilityBonusesIDs() (ids []int) {
	for id := range m.removedability_bonuses {
		ids = append(ids, id)
	}
	return
}

// AbilityBonusesIDs returns the "ability_bonuses" edge IDs in the mutation.
func (m *RaceMutation) AbilityBonusesIDs() (ids []int) {
	for id := range m.ability_bonuses {
		ids = append(ids, id)
	}
	return
}

// ResetAbilityBonuses resets all changes to the "ability_bonuses" edge.
func (m *RaceMutation) ResetAbilityBonuses() {
	m.ability_bonuses = nil
	m.clearedability_bonuses = false
	m.removedability_bonuses = nil
}

// AddLanguageIDs adds the "languages" edge to the Language entity by ids.
func (m *RaceMutation) AddLanguageIDs(ids ...int) {
	if m.languages == nil {
		m.languages = make(map[int]struct{})
	}
	for i := range ids {
		m.languages[ids[i]] = struct{}{}
	}
}

// ClearLanguages clears the "languages" edge to the Language entity.
func (m *RaceMutation) ClearLanguages() {
	m.clearedlanguages = true
}

// LanguagesCleared reports if the "languages" edge to the Language entity was cleared.
func (m *RaceMutation) LanguagesCleared() bool {
	return m.clearedlanguages
}

// RemoveLanguageIDs removes the "languages" edge to the Language entity by IDs.
func (m *RaceMutation) RemoveLanguageIDs(ids ...int) {
	if m.removedlanguages == nil {
		m.removedlanguages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.languages, ids[i])
		m.removedlanguages[ids[i]] = struct{}{}
	}
}

// RemovedLanguages returns the removed IDs of the "languages" edge to the Language entity.
func (m *RaceMutation) RemovedLanguagesIDs() (ids []int) {
	for id := range m.removedlanguages {
		ids = append(ids, id)
	}
	return
}

// LanguagesIDs returns the "languages" edge IDs in the mutation.
func (m *RaceMutation) LanguagesIDs() (ids []int) {
	for id := range m.languages {
		ids = append(ids, id)
	}
	return
}

// ResetLanguages resets all changes to the "languages" edge.
func (m *RaceMutation) ResetLanguages() {
	m.languages = nil
	m.clearedlanguages = false
	m.removedlanguages = nil
}

// Where appends a list predicates to the RaceMutation builder.
func (m *RaceMutation) Where(ps ...predicate.Race) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Race, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Race).
func (m *RaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RaceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.indx != nil {
		fields = append(fields, race.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, race.FieldName)
	}
	if m.speed != nil {
		fields = append(fields, race.FieldSpeed)
	}
	if m.size != nil {
		fields = append(fields, race.FieldSize)
	}
	if m.size_desc != nil {
		fields = append(fields, race.FieldSizeDesc)
	}
	if m.alignment_desc != nil {
		fields = append(fields, race.FieldAlignmentDesc)
	}
	if m.age_desc != nil {
		fields = append(fields, race.FieldAgeDesc)
	}
	if m.language_desc != nil {
		fields = append(fields, race.FieldLanguageDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case race.FieldIndx:
		return m.Indx()
	case race.FieldName:
		return m.Name()
	case race.FieldSpeed:
		return m.Speed()
	case race.FieldSize:
		return m.Size()
	case race.FieldSizeDesc:
		return m.SizeDesc()
	case race.FieldAlignmentDesc:
		return m.AlignmentDesc()
	case race.FieldAgeDesc:
		return m.AgeDesc()
	case race.FieldLanguageDesc:
		return m.LanguageDesc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case race.FieldIndx:
		return m.OldIndx(ctx)
	case race.FieldName:
		return m.OldName(ctx)
	case race.FieldSpeed:
		return m.OldSpeed(ctx)
	case race.FieldSize:
		return m.OldSize(ctx)
	case race.FieldSizeDesc:
		return m.OldSizeDesc(ctx)
	case race.FieldAlignmentDesc:
		return m.OldAlignmentDesc(ctx)
	case race.FieldAgeDesc:
		return m.OldAgeDesc(ctx)
	case race.FieldLanguageDesc:
		return m.OldLanguageDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Race field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case race.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case race.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case race.FieldSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeed(v)
		return nil
	case race.FieldSize:
		v, ok := value.(race.Size)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case race.FieldSizeDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeDesc(v)
		return nil
	case race.FieldAlignmentDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlignmentDesc(v)
		return nil
	case race.FieldAgeDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgeDesc(v)
		return nil
	case race.FieldLanguageDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Race field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RaceMutation) AddedFields() []string {
	var fields []string
	if m.addspeed != nil {
		fields = append(fields, race.FieldSpeed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case race.FieldSpeed:
		return m.AddedSpeed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case race.FieldSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown Race numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Race nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RaceMutation) ResetField(name string) error {
	switch name {
	case race.FieldIndx:
		m.ResetIndx()
		return nil
	case race.FieldName:
		m.ResetName()
		return nil
	case race.FieldSpeed:
		m.ResetSpeed()
		return nil
	case race.FieldSize:
		m.ResetSize()
		return nil
	case race.FieldSizeDesc:
		m.ResetSizeDesc()
		return nil
	case race.FieldAlignmentDesc:
		m.ResetAlignmentDesc()
		return nil
	case race.FieldAgeDesc:
		m.ResetAgeDesc()
		return nil
	case race.FieldLanguageDesc:
		m.ResetLanguageDesc()
		return nil
	}
	return fmt.Errorf("unknown Race field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ability_bonuses != nil {
		edges = append(edges, race.EdgeAbilityBonuses)
	}
	if m.languages != nil {
		edges = append(edges, race.EdgeLanguages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case race.EdgeAbilityBonuses:
		ids := make([]ent.Value, 0, len(m.ability_bonuses))
		for id := range m.ability_bonuses {
			ids = append(ids, id)
		}
		return ids
	case race.EdgeLanguages:
		ids := make([]ent.Value, 0, len(m.languages))
		for id := range m.languages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedability_bonuses != nil {
		edges = append(edges, race.EdgeAbilityBonuses)
	}
	if m.removedlanguages != nil {
		edges = append(edges, race.EdgeLanguages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case race.EdgeAbilityBonuses:
		ids := make([]ent.Value, 0, len(m.removedability_bonuses))
		for id := range m.removedability_bonuses {
			ids = append(ids, id)
		}
		return ids
	case race.EdgeLanguages:
		ids := make([]ent.Value, 0, len(m.removedlanguages))
		for id := range m.removedlanguages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedability_bonuses {
		edges = append(edges, race.EdgeAbilityBonuses)
	}
	if m.clearedlanguages {
		edges = append(edges, race.EdgeLanguages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RaceMutation) EdgeCleared(name string) bool {
	switch name {
	case race.EdgeAbilityBonuses:
		return m.clearedability_bonuses
	case race.EdgeLanguages:
		return m.clearedlanguages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Race unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RaceMutation) ResetEdge(name string) error {
	switch name {
	case race.EdgeAbilityBonuses:
		m.ResetAbilityBonuses()
		return nil
	case race.EdgeLanguages:
		m.ResetLanguages()
		return nil
	}
	return fmt.Errorf("unknown Race edge %s", name)
}

// RuleMutation represents an operation that mutates the Rule nodes in the graph.
type RuleMutation struct {
	config
	op              Op
	typ             string
	id              *int
	indx            *string
	name            *string
	desc            *[]string
	appenddesc      []string
	clearedFields   map[string]struct{}
	sections        map[int]struct{}
	removedsections map[int]struct{}
	clearedsections bool
	done            bool
	oldValue        func(context.Context) (*Rule, error)
	predicates      []predicate.Rule
}

var _ ent.Mutation = (*RuleMutation)(nil)

// ruleOption allows management of the mutation configuration using functional options.
type ruleOption func(*RuleMutation)

// newRuleMutation creates new mutation for the Rule entity.
func newRuleMutation(c config, op Op, opts ...ruleOption) *RuleMutation {
	m := &RuleMutation{
		config:        c,
		op:            op,
		typ:           TypeRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRuleID sets the ID field of the mutation.
func withRuleID(id int) ruleOption {
	return func(m *RuleMutation) {
		var (
			err   error
			once  sync.Once
			value *Rule
		)
		m.oldValue = func(ctx context.Context) (*Rule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRule sets the old Rule of the mutation.
func withRule(node *Rule) ruleOption {
	return func(m *RuleMutation) {
		m.oldValue = func(context.Context) (*Rule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RuleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *RuleMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *RuleMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *RuleMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *RuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RuleMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *RuleMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *RuleMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *RuleMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *RuleMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *RuleMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[rule.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *RuleMutation) DescCleared() bool {
	_, ok := m.clearedFields[rule.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *RuleMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, rule.FieldDesc)
}

// AddSectionIDs adds the "sections" edge to the RuleSection entity by ids.
func (m *RuleMutation) AddSectionIDs(ids ...int) {
	if m.sections == nil {
		m.sections = make(map[int]struct{})
	}
	for i := range ids {
		m.sections[ids[i]] = struct{}{}
	}
}

// ClearSections clears the "sections" edge to the RuleSection entity.
func (m *RuleMutation) ClearSections() {
	m.clearedsections = true
}

// SectionsCleared reports if the "sections" edge to the RuleSection entity was cleared.
func (m *RuleMutation) SectionsCleared() bool {
	return m.clearedsections
}

// RemoveSectionIDs removes the "sections" edge to the RuleSection entity by IDs.
func (m *RuleMutation) RemoveSectionIDs(ids ...int) {
	if m.removedsections == nil {
		m.removedsections = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sections, ids[i])
		m.removedsections[ids[i]] = struct{}{}
	}
}

// RemovedSections returns the removed IDs of the "sections" edge to the RuleSection entity.
func (m *RuleMutation) RemovedSectionsIDs() (ids []int) {
	for id := range m.removedsections {
		ids = append(ids, id)
	}
	return
}

// SectionsIDs returns the "sections" edge IDs in the mutation.
func (m *RuleMutation) SectionsIDs() (ids []int) {
	for id := range m.sections {
		ids = append(ids, id)
	}
	return
}

// ResetSections resets all changes to the "sections" edge.
func (m *RuleMutation) ResetSections() {
	m.sections = nil
	m.clearedsections = false
	m.removedsections = nil
}

// Where appends a list predicates to the RuleMutation builder.
func (m *RuleMutation) Where(ps ...predicate.Rule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Rule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Rule).
func (m *RuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RuleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, rule.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, rule.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, rule.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rule.FieldIndx:
		return m.Indx()
	case rule.FieldName:
		return m.Name()
	case rule.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rule.FieldIndx:
		return m.OldIndx(ctx)
	case rule.FieldName:
		return m.OldName(ctx)
	case rule.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Rule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rule.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case rule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rule.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Rule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Rule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rule.FieldDesc) {
		fields = append(fields, rule.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RuleMutation) ClearField(name string) error {
	switch name {
	case rule.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Rule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RuleMutation) ResetField(name string) error {
	switch name {
	case rule.FieldIndx:
		m.ResetIndx()
		return nil
	case rule.FieldName:
		m.ResetName()
		return nil
	case rule.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Rule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sections != nil {
		edges = append(edges, rule.EdgeSections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rule.EdgeSections:
		ids := make([]ent.Value, 0, len(m.sections))
		for id := range m.sections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsections != nil {
		edges = append(edges, rule.EdgeSections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rule.EdgeSections:
		ids := make([]ent.Value, 0, len(m.removedsections))
		for id := range m.removedsections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsections {
		edges = append(edges, rule.EdgeSections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RuleMutation) EdgeCleared(name string) bool {
	switch name {
	case rule.EdgeSections:
		return m.clearedsections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Rule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RuleMutation) ResetEdge(name string) error {
	switch name {
	case rule.EdgeSections:
		m.ResetSections()
		return nil
	}
	return fmt.Errorf("unknown Rule edge %s", name)
}

// RuleSectionMutation represents an operation that mutates the RuleSection nodes in the graph.
type RuleSectionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	clearedFields map[string]struct{}
	rule          *int
	clearedrule   bool
	done          bool
	oldValue      func(context.Context) (*RuleSection, error)
	predicates    []predicate.RuleSection
}

var _ ent.Mutation = (*RuleSectionMutation)(nil)

// rulesectionOption allows management of the mutation configuration using functional options.
type rulesectionOption func(*RuleSectionMutation)

// newRuleSectionMutation creates new mutation for the RuleSection entity.
func newRuleSectionMutation(c config, op Op, opts ...rulesectionOption) *RuleSectionMutation {
	m := &RuleSectionMutation{
		config:        c,
		op:            op,
		typ:           TypeRuleSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRuleSectionID sets the ID field of the mutation.
func withRuleSectionID(id int) rulesectionOption {
	return func(m *RuleSectionMutation) {
		var (
			err   error
			once  sync.Once
			value *RuleSection
		)
		m.oldValue = func(ctx context.Context) (*RuleSection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RuleSection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRuleSection sets the old RuleSection of the mutation.
func withRuleSection(node *RuleSection) rulesectionOption {
	return func(m *RuleSectionMutation) {
		m.oldValue = func(context.Context) (*RuleSection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RuleSectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RuleSectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RuleSectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RuleSectionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RuleSection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *RuleSectionMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *RuleSectionMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the RuleSection entity.
// If the RuleSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleSectionMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *RuleSectionMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *RuleSectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RuleSectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RuleSection entity.
// If the RuleSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleSectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RuleSectionMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *RuleSectionMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *RuleSectionMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the RuleSection entity.
// If the RuleSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleSectionMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *RuleSectionMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *RuleSectionMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *RuleSectionMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[rulesection.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *RuleSectionMutation) DescCleared() bool {
	_, ok := m.clearedFields[rulesection.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *RuleSectionMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, rulesection.FieldDesc)
}

// SetRuleID sets the "rule" edge to the Rule entity by id.
func (m *RuleSectionMutation) SetRuleID(id int) {
	m.rule = &id
}

// ClearRule clears the "rule" edge to the Rule entity.
func (m *RuleSectionMutation) ClearRule() {
	m.clearedrule = true
}

// RuleCleared reports if the "rule" edge to the Rule entity was cleared.
func (m *RuleSectionMutation) RuleCleared() bool {
	return m.clearedrule
}

// RuleID returns the "rule" edge ID in the mutation.
func (m *RuleSectionMutation) RuleID() (id int, exists bool) {
	if m.rule != nil {
		return *m.rule, true
	}
	return
}

// RuleIDs returns the "rule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuleID instead. It exists only for internal usage by the builders.
func (m *RuleSectionMutation) RuleIDs() (ids []int) {
	if id := m.rule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRule resets all changes to the "rule" edge.
func (m *RuleSectionMutation) ResetRule() {
	m.rule = nil
	m.clearedrule = false
}

// Where appends a list predicates to the RuleSectionMutation builder.
func (m *RuleSectionMutation) Where(ps ...predicate.RuleSection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RuleSectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RuleSectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RuleSection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RuleSectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RuleSectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RuleSection).
func (m *RuleSectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RuleSectionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, rulesection.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, rulesection.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, rulesection.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RuleSectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rulesection.FieldIndx:
		return m.Indx()
	case rulesection.FieldName:
		return m.Name()
	case rulesection.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RuleSectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rulesection.FieldIndx:
		return m.OldIndx(ctx)
	case rulesection.FieldName:
		return m.OldName(ctx)
	case rulesection.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown RuleSection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleSectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rulesection.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case rulesection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rulesection.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown RuleSection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RuleSectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RuleSectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleSectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RuleSection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RuleSectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rulesection.FieldDesc) {
		fields = append(fields, rulesection.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RuleSectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RuleSectionMutation) ClearField(name string) error {
	switch name {
	case rulesection.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown RuleSection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RuleSectionMutation) ResetField(name string) error {
	switch name {
	case rulesection.FieldIndx:
		m.ResetIndx()
		return nil
	case rulesection.FieldName:
		m.ResetName()
		return nil
	case rulesection.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown RuleSection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RuleSectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rule != nil {
		edges = append(edges, rulesection.EdgeRule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RuleSectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rulesection.EdgeRule:
		if id := m.rule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RuleSectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RuleSectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RuleSectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrule {
		edges = append(edges, rulesection.EdgeRule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RuleSectionMutation) EdgeCleared(name string) bool {
	switch name {
	case rulesection.EdgeRule:
		return m.clearedrule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RuleSectionMutation) ClearEdge(name string) error {
	switch name {
	case rulesection.EdgeRule:
		m.ClearRule()
		return nil
	}
	return fmt.Errorf("unknown RuleSection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RuleSectionMutation) ResetEdge(name string) error {
	switch name {
	case rulesection.EdgeRule:
		m.ResetRule()
		return nil
	}
	return fmt.Errorf("unknown RuleSection edge %s", name)
}

// SkillMutation represents an operation that mutates the Skill nodes in the graph.
type SkillMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	indx                 *string
	name                 *string
	desc                 *[]string
	appenddesc           []string
	clearedFields        map[string]struct{}
	ability_score        *int
	clearedability_score bool
	done                 bool
	oldValue             func(context.Context) (*Skill, error)
	predicates           []predicate.Skill
}

var _ ent.Mutation = (*SkillMutation)(nil)

// skillOption allows management of the mutation configuration using functional options.
type skillOption func(*SkillMutation)

// newSkillMutation creates new mutation for the Skill entity.
func newSkillMutation(c config, op Op, opts ...skillOption) *SkillMutation {
	m := &SkillMutation{
		config:        c,
		op:            op,
		typ:           TypeSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkillID sets the ID field of the mutation.
func withSkillID(id int) skillOption {
	return func(m *SkillMutation) {
		var (
			err   error
			once  sync.Once
			value *Skill
		)
		m.oldValue = func(ctx context.Context) (*Skill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Skill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkill sets the old Skill of the mutation.
func withSkill(node *Skill) skillOption {
	return func(m *SkillMutation) {
		m.oldValue = func(context.Context) (*Skill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkillMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Skill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *SkillMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *SkillMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *SkillMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *SkillMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SkillMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SkillMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *SkillMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *SkillMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *SkillMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *SkillMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *SkillMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[skill.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *SkillMutation) DescCleared() bool {
	_, ok := m.clearedFields[skill.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *SkillMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, skill.FieldDesc)
}

// SetAbilityScoreID sets the "ability_score" edge to the AbilityScore entity by id.
func (m *SkillMutation) SetAbilityScoreID(id int) {
	m.ability_score = &id
}

// ClearAbilityScore clears the "ability_score" edge to the AbilityScore entity.
func (m *SkillMutation) ClearAbilityScore() {
	m.clearedability_score = true
}

// AbilityScoreCleared reports if the "ability_score" edge to the AbilityScore entity was cleared.
func (m *SkillMutation) AbilityScoreCleared() bool {
	return m.clearedability_score
}

// AbilityScoreID returns the "ability_score" edge ID in the mutation.
func (m *SkillMutation) AbilityScoreID() (id int, exists bool) {
	if m.ability_score != nil {
		return *m.ability_score, true
	}
	return
}

// AbilityScoreIDs returns the "ability_score" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AbilityScoreID instead. It exists only for internal usage by the builders.
func (m *SkillMutation) AbilityScoreIDs() (ids []int) {
	if id := m.ability_score; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAbilityScore resets all changes to the "ability_score" edge.
func (m *SkillMutation) ResetAbilityScore() {
	m.ability_score = nil
	m.clearedability_score = false
}

// Where appends a list predicates to the SkillMutation builder.
func (m *SkillMutation) Where(ps ...predicate.Skill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Skill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Skill).
func (m *SkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkillMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, skill.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, skill.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, skill.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skill.FieldIndx:
		return m.Indx()
	case skill.FieldName:
		return m.Name()
	case skill.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skill.FieldIndx:
		return m.OldIndx(ctx)
	case skill.FieldName:
		return m.OldName(ctx)
	case skill.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Skill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skill.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case skill.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case skill.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Skill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(skill.FieldDesc) {
		fields = append(fields, skill.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkillMutation) ClearField(name string) error {
	switch name {
	case skill.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Skill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkillMutation) ResetField(name string) error {
	switch name {
	case skill.FieldIndx:
		m.ResetIndx()
		return nil
	case skill.FieldName:
		m.ResetName()
		return nil
	case skill.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ability_score != nil {
		edges = append(edges, skill.EdgeAbilityScore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeAbilityScore:
		if id := m.ability_score; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedability_score {
		edges = append(edges, skill.EdgeAbilityScore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkillMutation) EdgeCleared(name string) bool {
	switch name {
	case skill.EdgeAbilityScore:
		return m.clearedability_score
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkillMutation) ClearEdge(name string) error {
	switch name {
	case skill.EdgeAbilityScore:
		m.ClearAbilityScore()
		return nil
	}
	return fmt.Errorf("unknown Skill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkillMutation) ResetEdge(name string) error {
	switch name {
	case skill.EdgeAbilityScore:
		m.ResetAbilityScore()
		return nil
	}
	return fmt.Errorf("unknown Skill edge %s", name)
}

// WeaponPropertyMutation represents an operation that mutates the WeaponProperty nodes in the graph.
type WeaponPropertyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WeaponProperty, error)
	predicates    []predicate.WeaponProperty
}

var _ ent.Mutation = (*WeaponPropertyMutation)(nil)

// weaponpropertyOption allows management of the mutation configuration using functional options.
type weaponpropertyOption func(*WeaponPropertyMutation)

// newWeaponPropertyMutation creates new mutation for the WeaponProperty entity.
func newWeaponPropertyMutation(c config, op Op, opts ...weaponpropertyOption) *WeaponPropertyMutation {
	m := &WeaponPropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeWeaponProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWeaponPropertyID sets the ID field of the mutation.
func withWeaponPropertyID(id int) weaponpropertyOption {
	return func(m *WeaponPropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *WeaponProperty
		)
		m.oldValue = func(ctx context.Context) (*WeaponProperty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WeaponProperty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWeaponProperty sets the old WeaponProperty of the mutation.
func withWeaponProperty(node *WeaponProperty) weaponpropertyOption {
	return func(m *WeaponPropertyMutation) {
		m.oldValue = func(context.Context) (*WeaponProperty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WeaponPropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WeaponPropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WeaponPropertyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WeaponPropertyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WeaponProperty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *WeaponPropertyMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *WeaponPropertyMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the WeaponProperty entity.
// If the WeaponProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeaponPropertyMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *WeaponPropertyMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *WeaponPropertyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WeaponPropertyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WeaponProperty entity.
// If the WeaponProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeaponPropertyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WeaponPropertyMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *WeaponPropertyMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *WeaponPropertyMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the WeaponProperty entity.
// If the WeaponProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeaponPropertyMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *WeaponPropertyMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *WeaponPropertyMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *WeaponPropertyMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[weaponproperty.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *WeaponPropertyMutation) DescCleared() bool {
	_, ok := m.clearedFields[weaponproperty.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *WeaponPropertyMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, weaponproperty.FieldDesc)
}

// Where appends a list predicates to the WeaponPropertyMutation builder.
func (m *WeaponPropertyMutation) Where(ps ...predicate.WeaponProperty) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WeaponPropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WeaponPropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WeaponProperty, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WeaponPropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WeaponPropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WeaponProperty).
func (m *WeaponPropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WeaponPropertyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, weaponproperty.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, weaponproperty.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, weaponproperty.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WeaponPropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case weaponproperty.FieldIndx:
		return m.Indx()
	case weaponproperty.FieldName:
		return m.Name()
	case weaponproperty.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WeaponPropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case weaponproperty.FieldIndx:
		return m.OldIndx(ctx)
	case weaponproperty.FieldName:
		return m.OldName(ctx)
	case weaponproperty.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown WeaponProperty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WeaponPropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case weaponproperty.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case weaponproperty.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case weaponproperty.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown WeaponProperty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WeaponPropertyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WeaponPropertyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WeaponPropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WeaponProperty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WeaponPropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(weaponproperty.FieldDesc) {
		fields = append(fields, weaponproperty.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WeaponPropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WeaponPropertyMutation) ClearField(name string) error {
	switch name {
	case weaponproperty.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown WeaponProperty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WeaponPropertyMutation) ResetField(name string) error {
	switch name {
	case weaponproperty.FieldIndx:
		m.ResetIndx()
		return nil
	case weaponproperty.FieldName:
		m.ResetName()
		return nil
	case weaponproperty.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown WeaponProperty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WeaponPropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WeaponPropertyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WeaponPropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WeaponPropertyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WeaponPropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WeaponPropertyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WeaponPropertyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WeaponProperty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WeaponPropertyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WeaponProperty edge %s", name)
}
