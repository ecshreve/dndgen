// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/ecshreve/dndgen/ent/abilitybonus"
	"github.com/ecshreve/dndgen/ent/abilityscore"
	"github.com/ecshreve/dndgen/ent/alignment"
	"github.com/ecshreve/dndgen/ent/armor"
	"github.com/ecshreve/dndgen/ent/character"
	"github.com/ecshreve/dndgen/ent/characterabilityscore"
	"github.com/ecshreve/dndgen/ent/characterproficiency"
	"github.com/ecshreve/dndgen/ent/characterskill"
	"github.com/ecshreve/dndgen/ent/class"
	"github.com/ecshreve/dndgen/ent/coin"
	"github.com/ecshreve/dndgen/ent/condition"
	"github.com/ecshreve/dndgen/ent/cost"
	"github.com/ecshreve/dndgen/ent/damagetype"
	"github.com/ecshreve/dndgen/ent/equipment"
	"github.com/ecshreve/dndgen/ent/equipmententry"
	"github.com/ecshreve/dndgen/ent/feat"
	"github.com/ecshreve/dndgen/ent/feature"
	"github.com/ecshreve/dndgen/ent/gear"
	"github.com/ecshreve/dndgen/ent/language"
	"github.com/ecshreve/dndgen/ent/languagechoice"
	"github.com/ecshreve/dndgen/ent/magicschool"
	"github.com/ecshreve/dndgen/ent/predicate"
	"github.com/ecshreve/dndgen/ent/prerequisite"
	"github.com/ecshreve/dndgen/ent/proficiency"
	"github.com/ecshreve/dndgen/ent/proficiencychoice"
	"github.com/ecshreve/dndgen/ent/property"
	"github.com/ecshreve/dndgen/ent/race"
	"github.com/ecshreve/dndgen/ent/rule"
	"github.com/ecshreve/dndgen/ent/rulesection"
	"github.com/ecshreve/dndgen/ent/skill"
	"github.com/ecshreve/dndgen/ent/tool"
	"github.com/ecshreve/dndgen/ent/trait"
	"github.com/ecshreve/dndgen/ent/vehicle"
	"github.com/ecshreve/dndgen/ent/weapon"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAbilityBonus          = "AbilityBonus"
	TypeAbilityScore          = "AbilityScore"
	TypeAlignment             = "Alignment"
	TypeArmor                 = "Armor"
	TypeCharacter             = "Character"
	TypeCharacterAbilityScore = "CharacterAbilityScore"
	TypeCharacterProficiency  = "CharacterProficiency"
	TypeCharacterSkill        = "CharacterSkill"
	TypeClass                 = "Class"
	TypeCoin                  = "Coin"
	TypeCondition             = "Condition"
	TypeCost                  = "Cost"
	TypeDamageType            = "DamageType"
	TypeEquipment             = "Equipment"
	TypeEquipmentEntry        = "EquipmentEntry"
	TypeFeat                  = "Feat"
	TypeFeature               = "Feature"
	TypeGear                  = "Gear"
	TypeLanguage              = "Language"
	TypeLanguageChoice        = "LanguageChoice"
	TypeMagicSchool           = "MagicSchool"
	TypePrerequisite          = "Prerequisite"
	TypeProficiency           = "Proficiency"
	TypeProficiencyChoice     = "ProficiencyChoice"
	TypeProperty              = "Property"
	TypeRace                  = "Race"
	TypeRule                  = "Rule"
	TypeRuleSection           = "RuleSection"
	TypeSkill                 = "Skill"
	TypeTool                  = "Tool"
	TypeTrait                 = "Trait"
	TypeVehicle               = "Vehicle"
	TypeWeapon                = "Weapon"
)

// AbilityBonusMutation represents an operation that mutates the AbilityBonus nodes in the graph.
type AbilityBonusMutation struct {
	config
	op                   Op
	typ                  string
	bonus                *int
	addbonus             *int
	clearedFields        map[string]struct{}
	race                 *int
	clearedrace          bool
	ability_score        *int
	clearedability_score bool
	done                 bool
	oldValue             func(context.Context) (*AbilityBonus, error)
	predicates           []predicate.AbilityBonus
}

var _ ent.Mutation = (*AbilityBonusMutation)(nil)

// abilitybonusOption allows management of the mutation configuration using functional options.
type abilitybonusOption func(*AbilityBonusMutation)

// newAbilityBonusMutation creates new mutation for the AbilityBonus entity.
func newAbilityBonusMutation(c config, op Op, opts ...abilitybonusOption) *AbilityBonusMutation {
	m := &AbilityBonusMutation{
		config:        c,
		op:            op,
		typ:           TypeAbilityBonus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbilityBonusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbilityBonusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetBonus sets the "bonus" field.
func (m *AbilityBonusMutation) SetBonus(i int) {
	m.bonus = &i
	m.addbonus = nil
}

// Bonus returns the value of the "bonus" field in the mutation.
func (m *AbilityBonusMutation) Bonus() (r int, exists bool) {
	v := m.bonus
	if v == nil {
		return
	}
	return *v, true
}

// AddBonus adds i to the "bonus" field.
func (m *AbilityBonusMutation) AddBonus(i int) {
	if m.addbonus != nil {
		*m.addbonus += i
	} else {
		m.addbonus = &i
	}
}

// AddedBonus returns the value that was added to the "bonus" field in this mutation.
func (m *AbilityBonusMutation) AddedBonus() (r int, exists bool) {
	v := m.addbonus
	if v == nil {
		return
	}
	return *v, true
}

// ResetBonus resets all changes to the "bonus" field.
func (m *AbilityBonusMutation) ResetBonus() {
	m.bonus = nil
	m.addbonus = nil
}

// SetRaceID sets the "race_id" field.
func (m *AbilityBonusMutation) SetRaceID(i int) {
	m.race = &i
}

// RaceID returns the value of the "race_id" field in the mutation.
func (m *AbilityBonusMutation) RaceID() (r int, exists bool) {
	v := m.race
	if v == nil {
		return
	}
	return *v, true
}

// ResetRaceID resets all changes to the "race_id" field.
func (m *AbilityBonusMutation) ResetRaceID() {
	m.race = nil
}

// SetAbilityScoreID sets the "ability_score_id" field.
func (m *AbilityBonusMutation) SetAbilityScoreID(i int) {
	m.ability_score = &i
}

// AbilityScoreID returns the value of the "ability_score_id" field in the mutation.
func (m *AbilityBonusMutation) AbilityScoreID() (r int, exists bool) {
	v := m.ability_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetAbilityScoreID resets all changes to the "ability_score_id" field.
func (m *AbilityBonusMutation) ResetAbilityScoreID() {
	m.ability_score = nil
}

// ClearRace clears the "race" edge to the Race entity.
func (m *AbilityBonusMutation) ClearRace() {
	m.clearedrace = true
	m.clearedFields[abilitybonus.FieldRaceID] = struct{}{}
}

// RaceCleared reports if the "race" edge to the Race entity was cleared.
func (m *AbilityBonusMutation) RaceCleared() bool {
	return m.clearedrace
}

// RaceIDs returns the "race" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RaceID instead. It exists only for internal usage by the builders.
func (m *AbilityBonusMutation) RaceIDs() (ids []int) {
	if id := m.race; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRace resets all changes to the "race" edge.
func (m *AbilityBonusMutation) ResetRace() {
	m.race = nil
	m.clearedrace = false
}

// ClearAbilityScore clears the "ability_score" edge to the AbilityScore entity.
func (m *AbilityBonusMutation) ClearAbilityScore() {
	m.clearedability_score = true
	m.clearedFields[abilitybonus.FieldAbilityScoreID] = struct{}{}
}

// AbilityScoreCleared reports if the "ability_score" edge to the AbilityScore entity was cleared.
func (m *AbilityBonusMutation) AbilityScoreCleared() bool {
	return m.clearedability_score
}

// AbilityScoreIDs returns the "ability_score" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AbilityScoreID instead. It exists only for internal usage by the builders.
func (m *AbilityBonusMutation) AbilityScoreIDs() (ids []int) {
	if id := m.ability_score; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAbilityScore resets all changes to the "ability_score" edge.
func (m *AbilityBonusMutation) ResetAbilityScore() {
	m.ability_score = nil
	m.clearedability_score = false
}

// Where appends a list predicates to the AbilityBonusMutation builder.
func (m *AbilityBonusMutation) Where(ps ...predicate.AbilityBonus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AbilityBonusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AbilityBonusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AbilityBonus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AbilityBonusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AbilityBonusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AbilityBonus).
func (m *AbilityBonusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AbilityBonusMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.bonus != nil {
		fields = append(fields, abilitybonus.FieldBonus)
	}
	if m.race != nil {
		fields = append(fields, abilitybonus.FieldRaceID)
	}
	if m.ability_score != nil {
		fields = append(fields, abilitybonus.FieldAbilityScoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AbilityBonusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abilitybonus.FieldBonus:
		return m.Bonus()
	case abilitybonus.FieldRaceID:
		return m.RaceID()
	case abilitybonus.FieldAbilityScoreID:
		return m.AbilityScoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AbilityBonusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema AbilityBonus does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbilityBonusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abilitybonus.FieldBonus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBonus(v)
		return nil
	case abilitybonus.FieldRaceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRaceID(v)
		return nil
	case abilitybonus.FieldAbilityScoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbilityScoreID(v)
		return nil
	}
	return fmt.Errorf("unknown AbilityBonus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AbilityBonusMutation) AddedFields() []string {
	var fields []string
	if m.addbonus != nil {
		fields = append(fields, abilitybonus.FieldBonus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AbilityBonusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case abilitybonus.FieldBonus:
		return m.AddedBonus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbilityBonusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case abilitybonus.FieldBonus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBonus(v)
		return nil
	}
	return fmt.Errorf("unknown AbilityBonus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AbilityBonusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AbilityBonusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbilityBonusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AbilityBonus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AbilityBonusMutation) ResetField(name string) error {
	switch name {
	case abilitybonus.FieldBonus:
		m.ResetBonus()
		return nil
	case abilitybonus.FieldRaceID:
		m.ResetRaceID()
		return nil
	case abilitybonus.FieldAbilityScoreID:
		m.ResetAbilityScoreID()
		return nil
	}
	return fmt.Errorf("unknown AbilityBonus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AbilityBonusMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.race != nil {
		edges = append(edges, abilitybonus.EdgeRace)
	}
	if m.ability_score != nil {
		edges = append(edges, abilitybonus.EdgeAbilityScore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AbilityBonusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case abilitybonus.EdgeRace:
		if id := m.race; id != nil {
			return []ent.Value{*id}
		}
	case abilitybonus.EdgeAbilityScore:
		if id := m.ability_score; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AbilityBonusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AbilityBonusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AbilityBonusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrace {
		edges = append(edges, abilitybonus.EdgeRace)
	}
	if m.clearedability_score {
		edges = append(edges, abilitybonus.EdgeAbilityScore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AbilityBonusMutation) EdgeCleared(name string) bool {
	switch name {
	case abilitybonus.EdgeRace:
		return m.clearedrace
	case abilitybonus.EdgeAbilityScore:
		return m.clearedability_score
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AbilityBonusMutation) ClearEdge(name string) error {
	switch name {
	case abilitybonus.EdgeRace:
		m.ClearRace()
		return nil
	case abilitybonus.EdgeAbilityScore:
		m.ClearAbilityScore()
		return nil
	}
	return fmt.Errorf("unknown AbilityBonus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AbilityBonusMutation) ResetEdge(name string) error {
	switch name {
	case abilitybonus.EdgeRace:
		m.ResetRace()
		return nil
	case abilitybonus.EdgeAbilityScore:
		m.ResetAbilityScore()
		return nil
	}
	return fmt.Errorf("unknown AbilityBonus edge %s", name)
}

// AbilityScoreMutation represents an operation that mutates the AbilityScore nodes in the graph.
type AbilityScoreMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	indx                            *string
	name                            *string
	desc                            *[]string
	appenddesc                      []string
	full_name                       *string
	clearedFields                   map[string]struct{}
	skills                          map[int]struct{}
	removedskills                   map[int]struct{}
	clearedskills                   bool
	classes                         map[int]struct{}
	removedclasses                  map[int]struct{}
	clearedclasses                  bool
	characters                      map[int]struct{}
	removedcharacters               map[int]struct{}
	clearedcharacters               bool
	race                            map[int]struct{}
	removedrace                     map[int]struct{}
	clearedrace                     bool
	character_ability_scores        map[int]struct{}
	removedcharacter_ability_scores map[int]struct{}
	clearedcharacter_ability_scores bool
	done                            bool
	oldValue                        func(context.Context) (*AbilityScore, error)
	predicates                      []predicate.AbilityScore
}

var _ ent.Mutation = (*AbilityScoreMutation)(nil)

// abilityscoreOption allows management of the mutation configuration using functional options.
type abilityscoreOption func(*AbilityScoreMutation)

// newAbilityScoreMutation creates new mutation for the AbilityScore entity.
func newAbilityScoreMutation(c config, op Op, opts ...abilityscoreOption) *AbilityScoreMutation {
	m := &AbilityScoreMutation{
		config:        c,
		op:            op,
		typ:           TypeAbilityScore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbilityScoreID sets the ID field of the mutation.
func withAbilityScoreID(id int) abilityscoreOption {
	return func(m *AbilityScoreMutation) {
		var (
			err   error
			once  sync.Once
			value *AbilityScore
		)
		m.oldValue = func(ctx context.Context) (*AbilityScore, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AbilityScore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbilityScore sets the old AbilityScore of the mutation.
func withAbilityScore(node *AbilityScore) abilityscoreOption {
	return func(m *AbilityScoreMutation) {
		m.oldValue = func(context.Context) (*AbilityScore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbilityScoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbilityScoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AbilityScoreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AbilityScoreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AbilityScore.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *AbilityScoreMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *AbilityScoreMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the AbilityScore entity.
// If the AbilityScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilityScoreMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *AbilityScoreMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *AbilityScoreMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AbilityScoreMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AbilityScore entity.
// If the AbilityScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilityScoreMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AbilityScoreMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *AbilityScoreMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *AbilityScoreMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the AbilityScore entity.
// If the AbilityScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilityScoreMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *AbilityScoreMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *AbilityScoreMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *AbilityScoreMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[abilityscore.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *AbilityScoreMutation) DescCleared() bool {
	_, ok := m.clearedFields[abilityscore.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *AbilityScoreMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, abilityscore.FieldDesc)
}

// SetFullName sets the "full_name" field.
func (m *AbilityScoreMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *AbilityScoreMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the AbilityScore entity.
// If the AbilityScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbilityScoreMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *AbilityScoreMutation) ResetFullName() {
	m.full_name = nil
}

// AddSkillIDs adds the "skills" edge to the Skill entity by ids.
func (m *AbilityScoreMutation) AddSkillIDs(ids ...int) {
	if m.skills == nil {
		m.skills = make(map[int]struct{})
	}
	for i := range ids {
		m.skills[ids[i]] = struct{}{}
	}
}

// ClearSkills clears the "skills" edge to the Skill entity.
func (m *AbilityScoreMutation) ClearSkills() {
	m.clearedskills = true
}

// SkillsCleared reports if the "skills" edge to the Skill entity was cleared.
func (m *AbilityScoreMutation) SkillsCleared() bool {
	return m.clearedskills
}

// RemoveSkillIDs removes the "skills" edge to the Skill entity by IDs.
func (m *AbilityScoreMutation) RemoveSkillIDs(ids ...int) {
	if m.removedskills == nil {
		m.removedskills = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.skills, ids[i])
		m.removedskills[ids[i]] = struct{}{}
	}
}

// RemovedSkills returns the removed IDs of the "skills" edge to the Skill entity.
func (m *AbilityScoreMutation) RemovedSkillsIDs() (ids []int) {
	for id := range m.removedskills {
		ids = append(ids, id)
	}
	return
}

// SkillsIDs returns the "skills" edge IDs in the mutation.
func (m *AbilityScoreMutation) SkillsIDs() (ids []int) {
	for id := range m.skills {
		ids = append(ids, id)
	}
	return
}

// ResetSkills resets all changes to the "skills" edge.
func (m *AbilityScoreMutation) ResetSkills() {
	m.skills = nil
	m.clearedskills = false
	m.removedskills = nil
}

// AddClassIDs adds the "classes" edge to the Class entity by ids.
func (m *AbilityScoreMutation) AddClassIDs(ids ...int) {
	if m.classes == nil {
		m.classes = make(map[int]struct{})
	}
	for i := range ids {
		m.classes[ids[i]] = struct{}{}
	}
}

// ClearClasses clears the "classes" edge to the Class entity.
func (m *AbilityScoreMutation) ClearClasses() {
	m.clearedclasses = true
}

// ClassesCleared reports if the "classes" edge to the Class entity was cleared.
func (m *AbilityScoreMutation) ClassesCleared() bool {
	return m.clearedclasses
}

// RemoveClassIDs removes the "classes" edge to the Class entity by IDs.
func (m *AbilityScoreMutation) RemoveClassIDs(ids ...int) {
	if m.removedclasses == nil {
		m.removedclasses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.classes, ids[i])
		m.removedclasses[ids[i]] = struct{}{}
	}
}

// RemovedClasses returns the removed IDs of the "classes" edge to the Class entity.
func (m *AbilityScoreMutation) RemovedClassesIDs() (ids []int) {
	for id := range m.removedclasses {
		ids = append(ids, id)
	}
	return
}

// ClassesIDs returns the "classes" edge IDs in the mutation.
func (m *AbilityScoreMutation) ClassesIDs() (ids []int) {
	for id := range m.classes {
		ids = append(ids, id)
	}
	return
}

// ResetClasses resets all changes to the "classes" edge.
func (m *AbilityScoreMutation) ResetClasses() {
	m.classes = nil
	m.clearedclasses = false
	m.removedclasses = nil
}

// AddCharacterIDs adds the "characters" edge to the Character entity by ids.
func (m *AbilityScoreMutation) AddCharacterIDs(ids ...int) {
	if m.characters == nil {
		m.characters = make(map[int]struct{})
	}
	for i := range ids {
		m.characters[ids[i]] = struct{}{}
	}
}

// ClearCharacters clears the "characters" edge to the Character entity.
func (m *AbilityScoreMutation) ClearCharacters() {
	m.clearedcharacters = true
}

// CharactersCleared reports if the "characters" edge to the Character entity was cleared.
func (m *AbilityScoreMutation) CharactersCleared() bool {
	return m.clearedcharacters
}

// RemoveCharacterIDs removes the "characters" edge to the Character entity by IDs.
func (m *AbilityScoreMutation) RemoveCharacterIDs(ids ...int) {
	if m.removedcharacters == nil {
		m.removedcharacters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.characters, ids[i])
		m.removedcharacters[ids[i]] = struct{}{}
	}
}

// RemovedCharacters returns the removed IDs of the "characters" edge to the Character entity.
func (m *AbilityScoreMutation) RemovedCharactersIDs() (ids []int) {
	for id := range m.removedcharacters {
		ids = append(ids, id)
	}
	return
}

// CharactersIDs returns the "characters" edge IDs in the mutation.
func (m *AbilityScoreMutation) CharactersIDs() (ids []int) {
	for id := range m.characters {
		ids = append(ids, id)
	}
	return
}

// ResetCharacters resets all changes to the "characters" edge.
func (m *AbilityScoreMutation) ResetCharacters() {
	m.characters = nil
	m.clearedcharacters = false
	m.removedcharacters = nil
}

// AddRaceIDs adds the "race" edge to the Race entity by ids.
func (m *AbilityScoreMutation) AddRaceIDs(ids ...int) {
	if m.race == nil {
		m.race = make(map[int]struct{})
	}
	for i := range ids {
		m.race[ids[i]] = struct{}{}
	}
}

// ClearRace clears the "race" edge to the Race entity.
func (m *AbilityScoreMutation) ClearRace() {
	m.clearedrace = true
}

// RaceCleared reports if the "race" edge to the Race entity was cleared.
func (m *AbilityScoreMutation) RaceCleared() bool {
	return m.clearedrace
}

// RemoveRaceIDs removes the "race" edge to the Race entity by IDs.
func (m *AbilityScoreMutation) RemoveRaceIDs(ids ...int) {
	if m.removedrace == nil {
		m.removedrace = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.race, ids[i])
		m.removedrace[ids[i]] = struct{}{}
	}
}

// RemovedRace returns the removed IDs of the "race" edge to the Race entity.
func (m *AbilityScoreMutation) RemovedRaceIDs() (ids []int) {
	for id := range m.removedrace {
		ids = append(ids, id)
	}
	return
}

// RaceIDs returns the "race" edge IDs in the mutation.
func (m *AbilityScoreMutation) RaceIDs() (ids []int) {
	for id := range m.race {
		ids = append(ids, id)
	}
	return
}

// ResetRace resets all changes to the "race" edge.
func (m *AbilityScoreMutation) ResetRace() {
	m.race = nil
	m.clearedrace = false
	m.removedrace = nil
}

// AddCharacterAbilityScoreIDs adds the "character_ability_scores" edge to the CharacterAbilityScore entity by ids.
func (m *AbilityScoreMutation) AddCharacterAbilityScoreIDs(ids ...int) {
	if m.character_ability_scores == nil {
		m.character_ability_scores = make(map[int]struct{})
	}
	for i := range ids {
		m.character_ability_scores[ids[i]] = struct{}{}
	}
}

// ClearCharacterAbilityScores clears the "character_ability_scores" edge to the CharacterAbilityScore entity.
func (m *AbilityScoreMutation) ClearCharacterAbilityScores() {
	m.clearedcharacter_ability_scores = true
}

// CharacterAbilityScoresCleared reports if the "character_ability_scores" edge to the CharacterAbilityScore entity was cleared.
func (m *AbilityScoreMutation) CharacterAbilityScoresCleared() bool {
	return m.clearedcharacter_ability_scores
}

// RemoveCharacterAbilityScoreIDs removes the "character_ability_scores" edge to the CharacterAbilityScore entity by IDs.
func (m *AbilityScoreMutation) RemoveCharacterAbilityScoreIDs(ids ...int) {
	if m.removedcharacter_ability_scores == nil {
		m.removedcharacter_ability_scores = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.character_ability_scores, ids[i])
		m.removedcharacter_ability_scores[ids[i]] = struct{}{}
	}
}

// RemovedCharacterAbilityScores returns the removed IDs of the "character_ability_scores" edge to the CharacterAbilityScore entity.
func (m *AbilityScoreMutation) RemovedCharacterAbilityScoresIDs() (ids []int) {
	for id := range m.removedcharacter_ability_scores {
		ids = append(ids, id)
	}
	return
}

// CharacterAbilityScoresIDs returns the "character_ability_scores" edge IDs in the mutation.
func (m *AbilityScoreMutation) CharacterAbilityScoresIDs() (ids []int) {
	for id := range m.character_ability_scores {
		ids = append(ids, id)
	}
	return
}

// ResetCharacterAbilityScores resets all changes to the "character_ability_scores" edge.
func (m *AbilityScoreMutation) ResetCharacterAbilityScores() {
	m.character_ability_scores = nil
	m.clearedcharacter_ability_scores = false
	m.removedcharacter_ability_scores = nil
}

// Where appends a list predicates to the AbilityScoreMutation builder.
func (m *AbilityScoreMutation) Where(ps ...predicate.AbilityScore) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AbilityScoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AbilityScoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AbilityScore, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AbilityScoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AbilityScoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AbilityScore).
func (m *AbilityScoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AbilityScoreMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.indx != nil {
		fields = append(fields, abilityscore.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, abilityscore.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, abilityscore.FieldDesc)
	}
	if m.full_name != nil {
		fields = append(fields, abilityscore.FieldFullName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AbilityScoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abilityscore.FieldIndx:
		return m.Indx()
	case abilityscore.FieldName:
		return m.Name()
	case abilityscore.FieldDesc:
		return m.Desc()
	case abilityscore.FieldFullName:
		return m.FullName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AbilityScoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abilityscore.FieldIndx:
		return m.OldIndx(ctx)
	case abilityscore.FieldName:
		return m.OldName(ctx)
	case abilityscore.FieldDesc:
		return m.OldDesc(ctx)
	case abilityscore.FieldFullName:
		return m.OldFullName(ctx)
	}
	return nil, fmt.Errorf("unknown AbilityScore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbilityScoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abilityscore.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case abilityscore.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case abilityscore.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case abilityscore.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	}
	return fmt.Errorf("unknown AbilityScore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AbilityScoreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AbilityScoreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbilityScoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AbilityScore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AbilityScoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(abilityscore.FieldDesc) {
		fields = append(fields, abilityscore.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AbilityScoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbilityScoreMutation) ClearField(name string) error {
	switch name {
	case abilityscore.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown AbilityScore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AbilityScoreMutation) ResetField(name string) error {
	switch name {
	case abilityscore.FieldIndx:
		m.ResetIndx()
		return nil
	case abilityscore.FieldName:
		m.ResetName()
		return nil
	case abilityscore.FieldDesc:
		m.ResetDesc()
		return nil
	case abilityscore.FieldFullName:
		m.ResetFullName()
		return nil
	}
	return fmt.Errorf("unknown AbilityScore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AbilityScoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.skills != nil {
		edges = append(edges, abilityscore.EdgeSkills)
	}
	if m.classes != nil {
		edges = append(edges, abilityscore.EdgeClasses)
	}
	if m.characters != nil {
		edges = append(edges, abilityscore.EdgeCharacters)
	}
	if m.race != nil {
		edges = append(edges, abilityscore.EdgeRace)
	}
	if m.character_ability_scores != nil {
		edges = append(edges, abilityscore.EdgeCharacterAbilityScores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AbilityScoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case abilityscore.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.skills))
		for id := range m.skills {
			ids = append(ids, id)
		}
		return ids
	case abilityscore.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.classes))
		for id := range m.classes {
			ids = append(ids, id)
		}
		return ids
	case abilityscore.EdgeCharacters:
		ids := make([]ent.Value, 0, len(m.characters))
		for id := range m.characters {
			ids = append(ids, id)
		}
		return ids
	case abilityscore.EdgeRace:
		ids := make([]ent.Value, 0, len(m.race))
		for id := range m.race {
			ids = append(ids, id)
		}
		return ids
	case abilityscore.EdgeCharacterAbilityScores:
		ids := make([]ent.Value, 0, len(m.character_ability_scores))
		for id := range m.character_ability_scores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AbilityScoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedskills != nil {
		edges = append(edges, abilityscore.EdgeSkills)
	}
	if m.removedclasses != nil {
		edges = append(edges, abilityscore.EdgeClasses)
	}
	if m.removedcharacters != nil {
		edges = append(edges, abilityscore.EdgeCharacters)
	}
	if m.removedrace != nil {
		edges = append(edges, abilityscore.EdgeRace)
	}
	if m.removedcharacter_ability_scores != nil {
		edges = append(edges, abilityscore.EdgeCharacterAbilityScores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AbilityScoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case abilityscore.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.removedskills))
		for id := range m.removedskills {
			ids = append(ids, id)
		}
		return ids
	case abilityscore.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.removedclasses))
		for id := range m.removedclasses {
			ids = append(ids, id)
		}
		return ids
	case abilityscore.EdgeCharacters:
		ids := make([]ent.Value, 0, len(m.removedcharacters))
		for id := range m.removedcharacters {
			ids = append(ids, id)
		}
		return ids
	case abilityscore.EdgeRace:
		ids := make([]ent.Value, 0, len(m.removedrace))
		for id := range m.removedrace {
			ids = append(ids, id)
		}
		return ids
	case abilityscore.EdgeCharacterAbilityScores:
		ids := make([]ent.Value, 0, len(m.removedcharacter_ability_scores))
		for id := range m.removedcharacter_ability_scores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AbilityScoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedskills {
		edges = append(edges, abilityscore.EdgeSkills)
	}
	if m.clearedclasses {
		edges = append(edges, abilityscore.EdgeClasses)
	}
	if m.clearedcharacters {
		edges = append(edges, abilityscore.EdgeCharacters)
	}
	if m.clearedrace {
		edges = append(edges, abilityscore.EdgeRace)
	}
	if m.clearedcharacter_ability_scores {
		edges = append(edges, abilityscore.EdgeCharacterAbilityScores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AbilityScoreMutation) EdgeCleared(name string) bool {
	switch name {
	case abilityscore.EdgeSkills:
		return m.clearedskills
	case abilityscore.EdgeClasses:
		return m.clearedclasses
	case abilityscore.EdgeCharacters:
		return m.clearedcharacters
	case abilityscore.EdgeRace:
		return m.clearedrace
	case abilityscore.EdgeCharacterAbilityScores:
		return m.clearedcharacter_ability_scores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AbilityScoreMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AbilityScore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AbilityScoreMutation) ResetEdge(name string) error {
	switch name {
	case abilityscore.EdgeSkills:
		m.ResetSkills()
		return nil
	case abilityscore.EdgeClasses:
		m.ResetClasses()
		return nil
	case abilityscore.EdgeCharacters:
		m.ResetCharacters()
		return nil
	case abilityscore.EdgeRace:
		m.ResetRace()
		return nil
	case abilityscore.EdgeCharacterAbilityScores:
		m.ResetCharacterAbilityScores()
		return nil
	}
	return fmt.Errorf("unknown AbilityScore edge %s", name)
}

// AlignmentMutation represents an operation that mutates the Alignment nodes in the graph.
type AlignmentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	abbr          *alignment.Abbr
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Alignment, error)
	predicates    []predicate.Alignment
}

var _ ent.Mutation = (*AlignmentMutation)(nil)

// alignmentOption allows management of the mutation configuration using functional options.
type alignmentOption func(*AlignmentMutation)

// newAlignmentMutation creates new mutation for the Alignment entity.
func newAlignmentMutation(c config, op Op, opts ...alignmentOption) *AlignmentMutation {
	m := &AlignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAlignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlignmentID sets the ID field of the mutation.
func withAlignmentID(id int) alignmentOption {
	return func(m *AlignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Alignment
		)
		m.oldValue = func(ctx context.Context) (*Alignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Alignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlignment sets the old Alignment of the mutation.
func withAlignment(node *Alignment) alignmentOption {
	return func(m *AlignmentMutation) {
		m.oldValue = func(context.Context) (*Alignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlignmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Alignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *AlignmentMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *AlignmentMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Alignment entity.
// If the Alignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlignmentMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *AlignmentMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *AlignmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlignmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Alignment entity.
// If the Alignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlignmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlignmentMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *AlignmentMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *AlignmentMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Alignment entity.
// If the Alignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlignmentMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *AlignmentMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *AlignmentMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *AlignmentMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[alignment.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *AlignmentMutation) DescCleared() bool {
	_, ok := m.clearedFields[alignment.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *AlignmentMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, alignment.FieldDesc)
}

// SetAbbr sets the "abbr" field.
func (m *AlignmentMutation) SetAbbr(a alignment.Abbr) {
	m.abbr = &a
}

// Abbr returns the value of the "abbr" field in the mutation.
func (m *AlignmentMutation) Abbr() (r alignment.Abbr, exists bool) {
	v := m.abbr
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbr returns the old "abbr" field's value of the Alignment entity.
// If the Alignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlignmentMutation) OldAbbr(ctx context.Context) (v alignment.Abbr, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbr: %w", err)
	}
	return oldValue.Abbr, nil
}

// ResetAbbr resets all changes to the "abbr" field.
func (m *AlignmentMutation) ResetAbbr() {
	m.abbr = nil
}

// Where appends a list predicates to the AlignmentMutation builder.
func (m *AlignmentMutation) Where(ps ...predicate.Alignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Alignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Alignment).
func (m *AlignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlignmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.indx != nil {
		fields = append(fields, alignment.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, alignment.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, alignment.FieldDesc)
	}
	if m.abbr != nil {
		fields = append(fields, alignment.FieldAbbr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alignment.FieldIndx:
		return m.Indx()
	case alignment.FieldName:
		return m.Name()
	case alignment.FieldDesc:
		return m.Desc()
	case alignment.FieldAbbr:
		return m.Abbr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alignment.FieldIndx:
		return m.OldIndx(ctx)
	case alignment.FieldName:
		return m.OldName(ctx)
	case alignment.FieldDesc:
		return m.OldDesc(ctx)
	case alignment.FieldAbbr:
		return m.OldAbbr(ctx)
	}
	return nil, fmt.Errorf("unknown Alignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alignment.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case alignment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case alignment.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case alignment.FieldAbbr:
		v, ok := value.(alignment.Abbr)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbr(v)
		return nil
	}
	return fmt.Errorf("unknown Alignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Alignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alignment.FieldDesc) {
		fields = append(fields, alignment.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlignmentMutation) ClearField(name string) error {
	switch name {
	case alignment.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Alignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlignmentMutation) ResetField(name string) error {
	switch name {
	case alignment.FieldIndx:
		m.ResetIndx()
		return nil
	case alignment.FieldName:
		m.ResetName()
		return nil
	case alignment.FieldDesc:
		m.ResetDesc()
		return nil
	case alignment.FieldAbbr:
		m.ResetAbbr()
		return nil
	}
	return fmt.Errorf("unknown Alignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlignmentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlignmentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlignmentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Alignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlignmentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Alignment edge %s", name)
}

// ArmorMutation represents an operation that mutates the Armor nodes in the graph.
type ArmorMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	armor_category       *armor.ArmorCategory
	str_minimum          *int
	addstr_minimum       *int
	stealth_disadvantage *bool
	ac_base              *int
	addac_base           *int
	ac_dex_bonus         *bool
	ac_max_bonus         *int
	addac_max_bonus      *int
	clearedFields        map[string]struct{}
	equipment            *int
	clearedequipment     bool
	done                 bool
	oldValue             func(context.Context) (*Armor, error)
	predicates           []predicate.Armor
}

var _ ent.Mutation = (*ArmorMutation)(nil)

// armorOption allows management of the mutation configuration using functional options.
type armorOption func(*ArmorMutation)

// newArmorMutation creates new mutation for the Armor entity.
func newArmorMutation(c config, op Op, opts ...armorOption) *ArmorMutation {
	m := &ArmorMutation{
		config:        c,
		op:            op,
		typ:           TypeArmor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArmorID sets the ID field of the mutation.
func withArmorID(id int) armorOption {
	return func(m *ArmorMutation) {
		var (
			err   error
			once  sync.Once
			value *Armor
		)
		m.oldValue = func(ctx context.Context) (*Armor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Armor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArmor sets the old Armor of the mutation.
func withArmor(node *Armor) armorOption {
	return func(m *ArmorMutation) {
		m.oldValue = func(context.Context) (*Armor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArmorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArmorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArmorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArmorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Armor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArmorCategory sets the "armor_category" field.
func (m *ArmorMutation) SetArmorCategory(ac armor.ArmorCategory) {
	m.armor_category = &ac
}

// ArmorCategory returns the value of the "armor_category" field in the mutation.
func (m *ArmorMutation) ArmorCategory() (r armor.ArmorCategory, exists bool) {
	v := m.armor_category
	if v == nil {
		return
	}
	return *v, true
}

// OldArmorCategory returns the old "armor_category" field's value of the Armor entity.
// If the Armor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArmorMutation) OldArmorCategory(ctx context.Context) (v armor.ArmorCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArmorCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArmorCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArmorCategory: %w", err)
	}
	return oldValue.ArmorCategory, nil
}

// ResetArmorCategory resets all changes to the "armor_category" field.
func (m *ArmorMutation) ResetArmorCategory() {
	m.armor_category = nil
}

// SetStrMinimum sets the "str_minimum" field.
func (m *ArmorMutation) SetStrMinimum(i int) {
	m.str_minimum = &i
	m.addstr_minimum = nil
}

// StrMinimum returns the value of the "str_minimum" field in the mutation.
func (m *ArmorMutation) StrMinimum() (r int, exists bool) {
	v := m.str_minimum
	if v == nil {
		return
	}
	return *v, true
}

// OldStrMinimum returns the old "str_minimum" field's value of the Armor entity.
// If the Armor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArmorMutation) OldStrMinimum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrMinimum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrMinimum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrMinimum: %w", err)
	}
	return oldValue.StrMinimum, nil
}

// AddStrMinimum adds i to the "str_minimum" field.
func (m *ArmorMutation) AddStrMinimum(i int) {
	if m.addstr_minimum != nil {
		*m.addstr_minimum += i
	} else {
		m.addstr_minimum = &i
	}
}

// AddedStrMinimum returns the value that was added to the "str_minimum" field in this mutation.
func (m *ArmorMutation) AddedStrMinimum() (r int, exists bool) {
	v := m.addstr_minimum
	if v == nil {
		return
	}
	return *v, true
}

// ResetStrMinimum resets all changes to the "str_minimum" field.
func (m *ArmorMutation) ResetStrMinimum() {
	m.str_minimum = nil
	m.addstr_minimum = nil
}

// SetStealthDisadvantage sets the "stealth_disadvantage" field.
func (m *ArmorMutation) SetStealthDisadvantage(b bool) {
	m.stealth_disadvantage = &b
}

// StealthDisadvantage returns the value of the "stealth_disadvantage" field in the mutation.
func (m *ArmorMutation) StealthDisadvantage() (r bool, exists bool) {
	v := m.stealth_disadvantage
	if v == nil {
		return
	}
	return *v, true
}

// OldStealthDisadvantage returns the old "stealth_disadvantage" field's value of the Armor entity.
// If the Armor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArmorMutation) OldStealthDisadvantage(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStealthDisadvantage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStealthDisadvantage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStealthDisadvantage: %w", err)
	}
	return oldValue.StealthDisadvantage, nil
}

// ResetStealthDisadvantage resets all changes to the "stealth_disadvantage" field.
func (m *ArmorMutation) ResetStealthDisadvantage() {
	m.stealth_disadvantage = nil
}

// SetAcBase sets the "ac_base" field.
func (m *ArmorMutation) SetAcBase(i int) {
	m.ac_base = &i
	m.addac_base = nil
}

// AcBase returns the value of the "ac_base" field in the mutation.
func (m *ArmorMutation) AcBase() (r int, exists bool) {
	v := m.ac_base
	if v == nil {
		return
	}
	return *v, true
}

// OldAcBase returns the old "ac_base" field's value of the Armor entity.
// If the Armor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArmorMutation) OldAcBase(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcBase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcBase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcBase: %w", err)
	}
	return oldValue.AcBase, nil
}

// AddAcBase adds i to the "ac_base" field.
func (m *ArmorMutation) AddAcBase(i int) {
	if m.addac_base != nil {
		*m.addac_base += i
	} else {
		m.addac_base = &i
	}
}

// AddedAcBase returns the value that was added to the "ac_base" field in this mutation.
func (m *ArmorMutation) AddedAcBase() (r int, exists bool) {
	v := m.addac_base
	if v == nil {
		return
	}
	return *v, true
}

// ResetAcBase resets all changes to the "ac_base" field.
func (m *ArmorMutation) ResetAcBase() {
	m.ac_base = nil
	m.addac_base = nil
}

// SetAcDexBonus sets the "ac_dex_bonus" field.
func (m *ArmorMutation) SetAcDexBonus(b bool) {
	m.ac_dex_bonus = &b
}

// AcDexBonus returns the value of the "ac_dex_bonus" field in the mutation.
func (m *ArmorMutation) AcDexBonus() (r bool, exists bool) {
	v := m.ac_dex_bonus
	if v == nil {
		return
	}
	return *v, true
}

// OldAcDexBonus returns the old "ac_dex_bonus" field's value of the Armor entity.
// If the Armor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArmorMutation) OldAcDexBonus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcDexBonus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcDexBonus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcDexBonus: %w", err)
	}
	return oldValue.AcDexBonus, nil
}

// ResetAcDexBonus resets all changes to the "ac_dex_bonus" field.
func (m *ArmorMutation) ResetAcDexBonus() {
	m.ac_dex_bonus = nil
}

// SetAcMaxBonus sets the "ac_max_bonus" field.
func (m *ArmorMutation) SetAcMaxBonus(i int) {
	m.ac_max_bonus = &i
	m.addac_max_bonus = nil
}

// AcMaxBonus returns the value of the "ac_max_bonus" field in the mutation.
func (m *ArmorMutation) AcMaxBonus() (r int, exists bool) {
	v := m.ac_max_bonus
	if v == nil {
		return
	}
	return *v, true
}

// OldAcMaxBonus returns the old "ac_max_bonus" field's value of the Armor entity.
// If the Armor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArmorMutation) OldAcMaxBonus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcMaxBonus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcMaxBonus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcMaxBonus: %w", err)
	}
	return oldValue.AcMaxBonus, nil
}

// AddAcMaxBonus adds i to the "ac_max_bonus" field.
func (m *ArmorMutation) AddAcMaxBonus(i int) {
	if m.addac_max_bonus != nil {
		*m.addac_max_bonus += i
	} else {
		m.addac_max_bonus = &i
	}
}

// AddedAcMaxBonus returns the value that was added to the "ac_max_bonus" field in this mutation.
func (m *ArmorMutation) AddedAcMaxBonus() (r int, exists bool) {
	v := m.addac_max_bonus
	if v == nil {
		return
	}
	return *v, true
}

// ResetAcMaxBonus resets all changes to the "ac_max_bonus" field.
func (m *ArmorMutation) ResetAcMaxBonus() {
	m.ac_max_bonus = nil
	m.addac_max_bonus = nil
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *ArmorMutation) SetEquipmentID(id int) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *ArmorMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *ArmorMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *ArmorMutation) EquipmentID() (id int, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *ArmorMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *ArmorMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// Where appends a list predicates to the ArmorMutation builder.
func (m *ArmorMutation) Where(ps ...predicate.Armor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArmorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArmorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Armor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArmorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArmorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Armor).
func (m *ArmorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArmorMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.armor_category != nil {
		fields = append(fields, armor.FieldArmorCategory)
	}
	if m.str_minimum != nil {
		fields = append(fields, armor.FieldStrMinimum)
	}
	if m.stealth_disadvantage != nil {
		fields = append(fields, armor.FieldStealthDisadvantage)
	}
	if m.ac_base != nil {
		fields = append(fields, armor.FieldAcBase)
	}
	if m.ac_dex_bonus != nil {
		fields = append(fields, armor.FieldAcDexBonus)
	}
	if m.ac_max_bonus != nil {
		fields = append(fields, armor.FieldAcMaxBonus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArmorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case armor.FieldArmorCategory:
		return m.ArmorCategory()
	case armor.FieldStrMinimum:
		return m.StrMinimum()
	case armor.FieldStealthDisadvantage:
		return m.StealthDisadvantage()
	case armor.FieldAcBase:
		return m.AcBase()
	case armor.FieldAcDexBonus:
		return m.AcDexBonus()
	case armor.FieldAcMaxBonus:
		return m.AcMaxBonus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArmorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case armor.FieldArmorCategory:
		return m.OldArmorCategory(ctx)
	case armor.FieldStrMinimum:
		return m.OldStrMinimum(ctx)
	case armor.FieldStealthDisadvantage:
		return m.OldStealthDisadvantage(ctx)
	case armor.FieldAcBase:
		return m.OldAcBase(ctx)
	case armor.FieldAcDexBonus:
		return m.OldAcDexBonus(ctx)
	case armor.FieldAcMaxBonus:
		return m.OldAcMaxBonus(ctx)
	}
	return nil, fmt.Errorf("unknown Armor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArmorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case armor.FieldArmorCategory:
		v, ok := value.(armor.ArmorCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArmorCategory(v)
		return nil
	case armor.FieldStrMinimum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrMinimum(v)
		return nil
	case armor.FieldStealthDisadvantage:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStealthDisadvantage(v)
		return nil
	case armor.FieldAcBase:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcBase(v)
		return nil
	case armor.FieldAcDexBonus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcDexBonus(v)
		return nil
	case armor.FieldAcMaxBonus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcMaxBonus(v)
		return nil
	}
	return fmt.Errorf("unknown Armor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArmorMutation) AddedFields() []string {
	var fields []string
	if m.addstr_minimum != nil {
		fields = append(fields, armor.FieldStrMinimum)
	}
	if m.addac_base != nil {
		fields = append(fields, armor.FieldAcBase)
	}
	if m.addac_max_bonus != nil {
		fields = append(fields, armor.FieldAcMaxBonus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArmorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case armor.FieldStrMinimum:
		return m.AddedStrMinimum()
	case armor.FieldAcBase:
		return m.AddedAcBase()
	case armor.FieldAcMaxBonus:
		return m.AddedAcMaxBonus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArmorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case armor.FieldStrMinimum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStrMinimum(v)
		return nil
	case armor.FieldAcBase:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAcBase(v)
		return nil
	case armor.FieldAcMaxBonus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAcMaxBonus(v)
		return nil
	}
	return fmt.Errorf("unknown Armor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArmorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArmorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArmorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Armor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArmorMutation) ResetField(name string) error {
	switch name {
	case armor.FieldArmorCategory:
		m.ResetArmorCategory()
		return nil
	case armor.FieldStrMinimum:
		m.ResetStrMinimum()
		return nil
	case armor.FieldStealthDisadvantage:
		m.ResetStealthDisadvantage()
		return nil
	case armor.FieldAcBase:
		m.ResetAcBase()
		return nil
	case armor.FieldAcDexBonus:
		m.ResetAcDexBonus()
		return nil
	case armor.FieldAcMaxBonus:
		m.ResetAcMaxBonus()
		return nil
	}
	return fmt.Errorf("unknown Armor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArmorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment != nil {
		edges = append(edges, armor.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArmorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case armor.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArmorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArmorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArmorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedequipment {
		edges = append(edges, armor.EdgeEquipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArmorMutation) EdgeCleared(name string) bool {
	switch name {
	case armor.EdgeEquipment:
		return m.clearedequipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArmorMutation) ClearEdge(name string) error {
	switch name {
	case armor.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown Armor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArmorMutation) ResetEdge(name string) error {
	switch name {
	case armor.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown Armor edge %s", name)
}

// CharacterMutation represents an operation that mutates the Character nodes in the graph.
type CharacterMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	name                            *string
	age                             *int
	addage                          *int
	level                           *int
	addlevel                        *int
	proficiency_bonus               *int
	addproficiency_bonus            *int
	clearedFields                   map[string]struct{}
	race                            *int
	clearedrace                     bool
	class                           *int
	clearedclass                    bool
	alignment                       *int
	clearedalignment                bool
	proficiencies                   map[int]struct{}
	removedproficiencies            map[int]struct{}
	clearedproficiencies            bool
	ability_scores                  map[int]struct{}
	removedability_scores           map[int]struct{}
	clearedability_scores           bool
	skills                          map[int]struct{}
	removedskills                   map[int]struct{}
	clearedskills                   bool
	character_ability_scores        map[int]struct{}
	removedcharacter_ability_scores map[int]struct{}
	clearedcharacter_ability_scores bool
	character_skills                map[int]struct{}
	removedcharacter_skills         map[int]struct{}
	clearedcharacter_skills         bool
	done                            bool
	oldValue                        func(context.Context) (*Character, error)
	predicates                      []predicate.Character
}

var _ ent.Mutation = (*CharacterMutation)(nil)

// characterOption allows management of the mutation configuration using functional options.
type characterOption func(*CharacterMutation)

// newCharacterMutation creates new mutation for the Character entity.
func newCharacterMutation(c config, op Op, opts ...characterOption) *CharacterMutation {
	m := &CharacterMutation{
		config:        c,
		op:            op,
		typ:           TypeCharacter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharacterID sets the ID field of the mutation.
func withCharacterID(id int) characterOption {
	return func(m *CharacterMutation) {
		var (
			err   error
			once  sync.Once
			value *Character
		)
		m.oldValue = func(ctx context.Context) (*Character, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Character.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharacter sets the old Character of the mutation.
func withCharacter(node *Character) characterOption {
	return func(m *CharacterMutation) {
		m.oldValue = func(context.Context) (*Character, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharacterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharacterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharacterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CharacterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Character.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CharacterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CharacterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CharacterMutation) ResetName() {
	m.name = nil
}

// SetAge sets the "age" field.
func (m *CharacterMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *CharacterMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *CharacterMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *CharacterMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *CharacterMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetLevel sets the "level" field.
func (m *CharacterMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *CharacterMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *CharacterMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *CharacterMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *CharacterMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetProficiencyBonus sets the "proficiency_bonus" field.
func (m *CharacterMutation) SetProficiencyBonus(i int) {
	m.proficiency_bonus = &i
	m.addproficiency_bonus = nil
}

// ProficiencyBonus returns the value of the "proficiency_bonus" field in the mutation.
func (m *CharacterMutation) ProficiencyBonus() (r int, exists bool) {
	v := m.proficiency_bonus
	if v == nil {
		return
	}
	return *v, true
}

// OldProficiencyBonus returns the old "proficiency_bonus" field's value of the Character entity.
// If the Character object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterMutation) OldProficiencyBonus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProficiencyBonus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProficiencyBonus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProficiencyBonus: %w", err)
	}
	return oldValue.ProficiencyBonus, nil
}

// AddProficiencyBonus adds i to the "proficiency_bonus" field.
func (m *CharacterMutation) AddProficiencyBonus(i int) {
	if m.addproficiency_bonus != nil {
		*m.addproficiency_bonus += i
	} else {
		m.addproficiency_bonus = &i
	}
}

// AddedProficiencyBonus returns the value that was added to the "proficiency_bonus" field in this mutation.
func (m *CharacterMutation) AddedProficiencyBonus() (r int, exists bool) {
	v := m.addproficiency_bonus
	if v == nil {
		return
	}
	return *v, true
}

// ResetProficiencyBonus resets all changes to the "proficiency_bonus" field.
func (m *CharacterMutation) ResetProficiencyBonus() {
	m.proficiency_bonus = nil
	m.addproficiency_bonus = nil
}

// SetRaceID sets the "race" edge to the Race entity by id.
func (m *CharacterMutation) SetRaceID(id int) {
	m.race = &id
}

// ClearRace clears the "race" edge to the Race entity.
func (m *CharacterMutation) ClearRace() {
	m.clearedrace = true
}

// RaceCleared reports if the "race" edge to the Race entity was cleared.
func (m *CharacterMutation) RaceCleared() bool {
	return m.clearedrace
}

// RaceID returns the "race" edge ID in the mutation.
func (m *CharacterMutation) RaceID() (id int, exists bool) {
	if m.race != nil {
		return *m.race, true
	}
	return
}

// RaceIDs returns the "race" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RaceID instead. It exists only for internal usage by the builders.
func (m *CharacterMutation) RaceIDs() (ids []int) {
	if id := m.race; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRace resets all changes to the "race" edge.
func (m *CharacterMutation) ResetRace() {
	m.race = nil
	m.clearedrace = false
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *CharacterMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *CharacterMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *CharacterMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *CharacterMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *CharacterMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *CharacterMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// SetAlignmentID sets the "alignment" edge to the Alignment entity by id.
func (m *CharacterMutation) SetAlignmentID(id int) {
	m.alignment = &id
}

// ClearAlignment clears the "alignment" edge to the Alignment entity.
func (m *CharacterMutation) ClearAlignment() {
	m.clearedalignment = true
}

// AlignmentCleared reports if the "alignment" edge to the Alignment entity was cleared.
func (m *CharacterMutation) AlignmentCleared() bool {
	return m.clearedalignment
}

// AlignmentID returns the "alignment" edge ID in the mutation.
func (m *CharacterMutation) AlignmentID() (id int, exists bool) {
	if m.alignment != nil {
		return *m.alignment, true
	}
	return
}

// AlignmentIDs returns the "alignment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlignmentID instead. It exists only for internal usage by the builders.
func (m *CharacterMutation) AlignmentIDs() (ids []int) {
	if id := m.alignment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlignment resets all changes to the "alignment" edge.
func (m *CharacterMutation) ResetAlignment() {
	m.alignment = nil
	m.clearedalignment = false
}

// AddProficiencyIDs adds the "proficiencies" edge to the Proficiency entity by ids.
func (m *CharacterMutation) AddProficiencyIDs(ids ...int) {
	if m.proficiencies == nil {
		m.proficiencies = make(map[int]struct{})
	}
	for i := range ids {
		m.proficiencies[ids[i]] = struct{}{}
	}
}

// ClearProficiencies clears the "proficiencies" edge to the Proficiency entity.
func (m *CharacterMutation) ClearProficiencies() {
	m.clearedproficiencies = true
}

// ProficienciesCleared reports if the "proficiencies" edge to the Proficiency entity was cleared.
func (m *CharacterMutation) ProficienciesCleared() bool {
	return m.clearedproficiencies
}

// RemoveProficiencyIDs removes the "proficiencies" edge to the Proficiency entity by IDs.
func (m *CharacterMutation) RemoveProficiencyIDs(ids ...int) {
	if m.removedproficiencies == nil {
		m.removedproficiencies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.proficiencies, ids[i])
		m.removedproficiencies[ids[i]] = struct{}{}
	}
}

// RemovedProficiencies returns the removed IDs of the "proficiencies" edge to the Proficiency entity.
func (m *CharacterMutation) RemovedProficienciesIDs() (ids []int) {
	for id := range m.removedproficiencies {
		ids = append(ids, id)
	}
	return
}

// ProficienciesIDs returns the "proficiencies" edge IDs in the mutation.
func (m *CharacterMutation) ProficienciesIDs() (ids []int) {
	for id := range m.proficiencies {
		ids = append(ids, id)
	}
	return
}

// ResetProficiencies resets all changes to the "proficiencies" edge.
func (m *CharacterMutation) ResetProficiencies() {
	m.proficiencies = nil
	m.clearedproficiencies = false
	m.removedproficiencies = nil
}

// AddAbilityScoreIDs adds the "ability_scores" edge to the AbilityScore entity by ids.
func (m *CharacterMutation) AddAbilityScoreIDs(ids ...int) {
	if m.ability_scores == nil {
		m.ability_scores = make(map[int]struct{})
	}
	for i := range ids {
		m.ability_scores[ids[i]] = struct{}{}
	}
}

// ClearAbilityScores clears the "ability_scores" edge to the AbilityScore entity.
func (m *CharacterMutation) ClearAbilityScores() {
	m.clearedability_scores = true
}

// AbilityScoresCleared reports if the "ability_scores" edge to the AbilityScore entity was cleared.
func (m *CharacterMutation) AbilityScoresCleared() bool {
	return m.clearedability_scores
}

// RemoveAbilityScoreIDs removes the "ability_scores" edge to the AbilityScore entity by IDs.
func (m *CharacterMutation) RemoveAbilityScoreIDs(ids ...int) {
	if m.removedability_scores == nil {
		m.removedability_scores = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ability_scores, ids[i])
		m.removedability_scores[ids[i]] = struct{}{}
	}
}

// RemovedAbilityScores returns the removed IDs of the "ability_scores" edge to the AbilityScore entity.
func (m *CharacterMutation) RemovedAbilityScoresIDs() (ids []int) {
	for id := range m.removedability_scores {
		ids = append(ids, id)
	}
	return
}

// AbilityScoresIDs returns the "ability_scores" edge IDs in the mutation.
func (m *CharacterMutation) AbilityScoresIDs() (ids []int) {
	for id := range m.ability_scores {
		ids = append(ids, id)
	}
	return
}

// ResetAbilityScores resets all changes to the "ability_scores" edge.
func (m *CharacterMutation) ResetAbilityScores() {
	m.ability_scores = nil
	m.clearedability_scores = false
	m.removedability_scores = nil
}

// AddSkillIDs adds the "skills" edge to the Skill entity by ids.
func (m *CharacterMutation) AddSkillIDs(ids ...int) {
	if m.skills == nil {
		m.skills = make(map[int]struct{})
	}
	for i := range ids {
		m.skills[ids[i]] = struct{}{}
	}
}

// ClearSkills clears the "skills" edge to the Skill entity.
func (m *CharacterMutation) ClearSkills() {
	m.clearedskills = true
}

// SkillsCleared reports if the "skills" edge to the Skill entity was cleared.
func (m *CharacterMutation) SkillsCleared() bool {
	return m.clearedskills
}

// RemoveSkillIDs removes the "skills" edge to the Skill entity by IDs.
func (m *CharacterMutation) RemoveSkillIDs(ids ...int) {
	if m.removedskills == nil {
		m.removedskills = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.skills, ids[i])
		m.removedskills[ids[i]] = struct{}{}
	}
}

// RemovedSkills returns the removed IDs of the "skills" edge to the Skill entity.
func (m *CharacterMutation) RemovedSkillsIDs() (ids []int) {
	for id := range m.removedskills {
		ids = append(ids, id)
	}
	return
}

// SkillsIDs returns the "skills" edge IDs in the mutation.
func (m *CharacterMutation) SkillsIDs() (ids []int) {
	for id := range m.skills {
		ids = append(ids, id)
	}
	return
}

// ResetSkills resets all changes to the "skills" edge.
func (m *CharacterMutation) ResetSkills() {
	m.skills = nil
	m.clearedskills = false
	m.removedskills = nil
}

// AddCharacterAbilityScoreIDs adds the "character_ability_scores" edge to the CharacterAbilityScore entity by ids.
func (m *CharacterMutation) AddCharacterAbilityScoreIDs(ids ...int) {
	if m.character_ability_scores == nil {
		m.character_ability_scores = make(map[int]struct{})
	}
	for i := range ids {
		m.character_ability_scores[ids[i]] = struct{}{}
	}
}

// ClearCharacterAbilityScores clears the "character_ability_scores" edge to the CharacterAbilityScore entity.
func (m *CharacterMutation) ClearCharacterAbilityScores() {
	m.clearedcharacter_ability_scores = true
}

// CharacterAbilityScoresCleared reports if the "character_ability_scores" edge to the CharacterAbilityScore entity was cleared.
func (m *CharacterMutation) CharacterAbilityScoresCleared() bool {
	return m.clearedcharacter_ability_scores
}

// RemoveCharacterAbilityScoreIDs removes the "character_ability_scores" edge to the CharacterAbilityScore entity by IDs.
func (m *CharacterMutation) RemoveCharacterAbilityScoreIDs(ids ...int) {
	if m.removedcharacter_ability_scores == nil {
		m.removedcharacter_ability_scores = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.character_ability_scores, ids[i])
		m.removedcharacter_ability_scores[ids[i]] = struct{}{}
	}
}

// RemovedCharacterAbilityScores returns the removed IDs of the "character_ability_scores" edge to the CharacterAbilityScore entity.
func (m *CharacterMutation) RemovedCharacterAbilityScoresIDs() (ids []int) {
	for id := range m.removedcharacter_ability_scores {
		ids = append(ids, id)
	}
	return
}

// CharacterAbilityScoresIDs returns the "character_ability_scores" edge IDs in the mutation.
func (m *CharacterMutation) CharacterAbilityScoresIDs() (ids []int) {
	for id := range m.character_ability_scores {
		ids = append(ids, id)
	}
	return
}

// ResetCharacterAbilityScores resets all changes to the "character_ability_scores" edge.
func (m *CharacterMutation) ResetCharacterAbilityScores() {
	m.character_ability_scores = nil
	m.clearedcharacter_ability_scores = false
	m.removedcharacter_ability_scores = nil
}

// AddCharacterSkillIDs adds the "character_skills" edge to the CharacterSkill entity by ids.
func (m *CharacterMutation) AddCharacterSkillIDs(ids ...int) {
	if m.character_skills == nil {
		m.character_skills = make(map[int]struct{})
	}
	for i := range ids {
		m.character_skills[ids[i]] = struct{}{}
	}
}

// ClearCharacterSkills clears the "character_skills" edge to the CharacterSkill entity.
func (m *CharacterMutation) ClearCharacterSkills() {
	m.clearedcharacter_skills = true
}

// CharacterSkillsCleared reports if the "character_skills" edge to the CharacterSkill entity was cleared.
func (m *CharacterMutation) CharacterSkillsCleared() bool {
	return m.clearedcharacter_skills
}

// RemoveCharacterSkillIDs removes the "character_skills" edge to the CharacterSkill entity by IDs.
func (m *CharacterMutation) RemoveCharacterSkillIDs(ids ...int) {
	if m.removedcharacter_skills == nil {
		m.removedcharacter_skills = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.character_skills, ids[i])
		m.removedcharacter_skills[ids[i]] = struct{}{}
	}
}

// RemovedCharacterSkills returns the removed IDs of the "character_skills" edge to the CharacterSkill entity.
func (m *CharacterMutation) RemovedCharacterSkillsIDs() (ids []int) {
	for id := range m.removedcharacter_skills {
		ids = append(ids, id)
	}
	return
}

// CharacterSkillsIDs returns the "character_skills" edge IDs in the mutation.
func (m *CharacterMutation) CharacterSkillsIDs() (ids []int) {
	for id := range m.character_skills {
		ids = append(ids, id)
	}
	return
}

// ResetCharacterSkills resets all changes to the "character_skills" edge.
func (m *CharacterMutation) ResetCharacterSkills() {
	m.character_skills = nil
	m.clearedcharacter_skills = false
	m.removedcharacter_skills = nil
}

// Where appends a list predicates to the CharacterMutation builder.
func (m *CharacterMutation) Where(ps ...predicate.Character) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CharacterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CharacterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Character, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CharacterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CharacterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Character).
func (m *CharacterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharacterMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, character.FieldName)
	}
	if m.age != nil {
		fields = append(fields, character.FieldAge)
	}
	if m.level != nil {
		fields = append(fields, character.FieldLevel)
	}
	if m.proficiency_bonus != nil {
		fields = append(fields, character.FieldProficiencyBonus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharacterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case character.FieldName:
		return m.Name()
	case character.FieldAge:
		return m.Age()
	case character.FieldLevel:
		return m.Level()
	case character.FieldProficiencyBonus:
		return m.ProficiencyBonus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharacterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case character.FieldName:
		return m.OldName(ctx)
	case character.FieldAge:
		return m.OldAge(ctx)
	case character.FieldLevel:
		return m.OldLevel(ctx)
	case character.FieldProficiencyBonus:
		return m.OldProficiencyBonus(ctx)
	}
	return nil, fmt.Errorf("unknown Character field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case character.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case character.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case character.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case character.FieldProficiencyBonus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProficiencyBonus(v)
		return nil
	}
	return fmt.Errorf("unknown Character field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharacterMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, character.FieldAge)
	}
	if m.addlevel != nil {
		fields = append(fields, character.FieldLevel)
	}
	if m.addproficiency_bonus != nil {
		fields = append(fields, character.FieldProficiencyBonus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharacterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case character.FieldAge:
		return m.AddedAge()
	case character.FieldLevel:
		return m.AddedLevel()
	case character.FieldProficiencyBonus:
		return m.AddedProficiencyBonus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case character.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case character.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case character.FieldProficiencyBonus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProficiencyBonus(v)
		return nil
	}
	return fmt.Errorf("unknown Character numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharacterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharacterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharacterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Character nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharacterMutation) ResetField(name string) error {
	switch name {
	case character.FieldName:
		m.ResetName()
		return nil
	case character.FieldAge:
		m.ResetAge()
		return nil
	case character.FieldLevel:
		m.ResetLevel()
		return nil
	case character.FieldProficiencyBonus:
		m.ResetProficiencyBonus()
		return nil
	}
	return fmt.Errorf("unknown Character field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharacterMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.race != nil {
		edges = append(edges, character.EdgeRace)
	}
	if m.class != nil {
		edges = append(edges, character.EdgeClass)
	}
	if m.alignment != nil {
		edges = append(edges, character.EdgeAlignment)
	}
	if m.proficiencies != nil {
		edges = append(edges, character.EdgeProficiencies)
	}
	if m.ability_scores != nil {
		edges = append(edges, character.EdgeAbilityScores)
	}
	if m.skills != nil {
		edges = append(edges, character.EdgeSkills)
	}
	if m.character_ability_scores != nil {
		edges = append(edges, character.EdgeCharacterAbilityScores)
	}
	if m.character_skills != nil {
		edges = append(edges, character.EdgeCharacterSkills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharacterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case character.EdgeRace:
		if id := m.race; id != nil {
			return []ent.Value{*id}
		}
	case character.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case character.EdgeAlignment:
		if id := m.alignment; id != nil {
			return []ent.Value{*id}
		}
	case character.EdgeProficiencies:
		ids := make([]ent.Value, 0, len(m.proficiencies))
		for id := range m.proficiencies {
			ids = append(ids, id)
		}
		return ids
	case character.EdgeAbilityScores:
		ids := make([]ent.Value, 0, len(m.ability_scores))
		for id := range m.ability_scores {
			ids = append(ids, id)
		}
		return ids
	case character.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.skills))
		for id := range m.skills {
			ids = append(ids, id)
		}
		return ids
	case character.EdgeCharacterAbilityScores:
		ids := make([]ent.Value, 0, len(m.character_ability_scores))
		for id := range m.character_ability_scores {
			ids = append(ids, id)
		}
		return ids
	case character.EdgeCharacterSkills:
		ids := make([]ent.Value, 0, len(m.character_skills))
		for id := range m.character_skills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharacterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedproficiencies != nil {
		edges = append(edges, character.EdgeProficiencies)
	}
	if m.removedability_scores != nil {
		edges = append(edges, character.EdgeAbilityScores)
	}
	if m.removedskills != nil {
		edges = append(edges, character.EdgeSkills)
	}
	if m.removedcharacter_ability_scores != nil {
		edges = append(edges, character.EdgeCharacterAbilityScores)
	}
	if m.removedcharacter_skills != nil {
		edges = append(edges, character.EdgeCharacterSkills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharacterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case character.EdgeProficiencies:
		ids := make([]ent.Value, 0, len(m.removedproficiencies))
		for id := range m.removedproficiencies {
			ids = append(ids, id)
		}
		return ids
	case character.EdgeAbilityScores:
		ids := make([]ent.Value, 0, len(m.removedability_scores))
		for id := range m.removedability_scores {
			ids = append(ids, id)
		}
		return ids
	case character.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.removedskills))
		for id := range m.removedskills {
			ids = append(ids, id)
		}
		return ids
	case character.EdgeCharacterAbilityScores:
		ids := make([]ent.Value, 0, len(m.removedcharacter_ability_scores))
		for id := range m.removedcharacter_ability_scores {
			ids = append(ids, id)
		}
		return ids
	case character.EdgeCharacterSkills:
		ids := make([]ent.Value, 0, len(m.removedcharacter_skills))
		for id := range m.removedcharacter_skills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharacterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedrace {
		edges = append(edges, character.EdgeRace)
	}
	if m.clearedclass {
		edges = append(edges, character.EdgeClass)
	}
	if m.clearedalignment {
		edges = append(edges, character.EdgeAlignment)
	}
	if m.clearedproficiencies {
		edges = append(edges, character.EdgeProficiencies)
	}
	if m.clearedability_scores {
		edges = append(edges, character.EdgeAbilityScores)
	}
	if m.clearedskills {
		edges = append(edges, character.EdgeSkills)
	}
	if m.clearedcharacter_ability_scores {
		edges = append(edges, character.EdgeCharacterAbilityScores)
	}
	if m.clearedcharacter_skills {
		edges = append(edges, character.EdgeCharacterSkills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharacterMutation) EdgeCleared(name string) bool {
	switch name {
	case character.EdgeRace:
		return m.clearedrace
	case character.EdgeClass:
		return m.clearedclass
	case character.EdgeAlignment:
		return m.clearedalignment
	case character.EdgeProficiencies:
		return m.clearedproficiencies
	case character.EdgeAbilityScores:
		return m.clearedability_scores
	case character.EdgeSkills:
		return m.clearedskills
	case character.EdgeCharacterAbilityScores:
		return m.clearedcharacter_ability_scores
	case character.EdgeCharacterSkills:
		return m.clearedcharacter_skills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharacterMutation) ClearEdge(name string) error {
	switch name {
	case character.EdgeRace:
		m.ClearRace()
		return nil
	case character.EdgeClass:
		m.ClearClass()
		return nil
	case character.EdgeAlignment:
		m.ClearAlignment()
		return nil
	}
	return fmt.Errorf("unknown Character unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharacterMutation) ResetEdge(name string) error {
	switch name {
	case character.EdgeRace:
		m.ResetRace()
		return nil
	case character.EdgeClass:
		m.ResetClass()
		return nil
	case character.EdgeAlignment:
		m.ResetAlignment()
		return nil
	case character.EdgeProficiencies:
		m.ResetProficiencies()
		return nil
	case character.EdgeAbilityScores:
		m.ResetAbilityScores()
		return nil
	case character.EdgeSkills:
		m.ResetSkills()
		return nil
	case character.EdgeCharacterAbilityScores:
		m.ResetCharacterAbilityScores()
		return nil
	case character.EdgeCharacterSkills:
		m.ResetCharacterSkills()
		return nil
	}
	return fmt.Errorf("unknown Character edge %s", name)
}

// CharacterAbilityScoreMutation represents an operation that mutates the CharacterAbilityScore nodes in the graph.
type CharacterAbilityScoreMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	score                *int
	addscore             *int
	modifier             *int
	addmodifier          *int
	clearedFields        map[string]struct{}
	character            *int
	clearedcharacter     bool
	ability_score        *int
	clearedability_score bool
	done                 bool
	oldValue             func(context.Context) (*CharacterAbilityScore, error)
	predicates           []predicate.CharacterAbilityScore
}

var _ ent.Mutation = (*CharacterAbilityScoreMutation)(nil)

// characterabilityscoreOption allows management of the mutation configuration using functional options.
type characterabilityscoreOption func(*CharacterAbilityScoreMutation)

// newCharacterAbilityScoreMutation creates new mutation for the CharacterAbilityScore entity.
func newCharacterAbilityScoreMutation(c config, op Op, opts ...characterabilityscoreOption) *CharacterAbilityScoreMutation {
	m := &CharacterAbilityScoreMutation{
		config:        c,
		op:            op,
		typ:           TypeCharacterAbilityScore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharacterAbilityScoreID sets the ID field of the mutation.
func withCharacterAbilityScoreID(id int) characterabilityscoreOption {
	return func(m *CharacterAbilityScoreMutation) {
		var (
			err   error
			once  sync.Once
			value *CharacterAbilityScore
		)
		m.oldValue = func(ctx context.Context) (*CharacterAbilityScore, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CharacterAbilityScore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharacterAbilityScore sets the old CharacterAbilityScore of the mutation.
func withCharacterAbilityScore(node *CharacterAbilityScore) characterabilityscoreOption {
	return func(m *CharacterAbilityScoreMutation) {
		m.oldValue = func(context.Context) (*CharacterAbilityScore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharacterAbilityScoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharacterAbilityScoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharacterAbilityScoreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CharacterAbilityScoreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CharacterAbilityScore.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScore sets the "score" field.
func (m *CharacterAbilityScoreMutation) SetScore(i int) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *CharacterAbilityScoreMutation) Score() (r int, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the CharacterAbilityScore entity.
// If the CharacterAbilityScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterAbilityScoreMutation) OldScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *CharacterAbilityScoreMutation) AddScore(i int) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *CharacterAbilityScoreMutation) AddedScore() (r int, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *CharacterAbilityScoreMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetModifier sets the "modifier" field.
func (m *CharacterAbilityScoreMutation) SetModifier(i int) {
	m.modifier = &i
	m.addmodifier = nil
}

// Modifier returns the value of the "modifier" field in the mutation.
func (m *CharacterAbilityScoreMutation) Modifier() (r int, exists bool) {
	v := m.modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldModifier returns the old "modifier" field's value of the CharacterAbilityScore entity.
// If the CharacterAbilityScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterAbilityScoreMutation) OldModifier(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifier: %w", err)
	}
	return oldValue.Modifier, nil
}

// AddModifier adds i to the "modifier" field.
func (m *CharacterAbilityScoreMutation) AddModifier(i int) {
	if m.addmodifier != nil {
		*m.addmodifier += i
	} else {
		m.addmodifier = &i
	}
}

// AddedModifier returns the value that was added to the "modifier" field in this mutation.
func (m *CharacterAbilityScoreMutation) AddedModifier() (r int, exists bool) {
	v := m.addmodifier
	if v == nil {
		return
	}
	return *v, true
}

// ResetModifier resets all changes to the "modifier" field.
func (m *CharacterAbilityScoreMutation) ResetModifier() {
	m.modifier = nil
	m.addmodifier = nil
}

// SetCharacterID sets the "character_id" field.
func (m *CharacterAbilityScoreMutation) SetCharacterID(i int) {
	m.character = &i
}

// CharacterID returns the value of the "character_id" field in the mutation.
func (m *CharacterAbilityScoreMutation) CharacterID() (r int, exists bool) {
	v := m.character
	if v == nil {
		return
	}
	return *v, true
}

// OldCharacterID returns the old "character_id" field's value of the CharacterAbilityScore entity.
// If the CharacterAbilityScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterAbilityScoreMutation) OldCharacterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCharacterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCharacterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCharacterID: %w", err)
	}
	return oldValue.CharacterID, nil
}

// ResetCharacterID resets all changes to the "character_id" field.
func (m *CharacterAbilityScoreMutation) ResetCharacterID() {
	m.character = nil
}

// SetAbilityScoreID sets the "ability_score_id" field.
func (m *CharacterAbilityScoreMutation) SetAbilityScoreID(i int) {
	m.ability_score = &i
}

// AbilityScoreID returns the value of the "ability_score_id" field in the mutation.
func (m *CharacterAbilityScoreMutation) AbilityScoreID() (r int, exists bool) {
	v := m.ability_score
	if v == nil {
		return
	}
	return *v, true
}

// OldAbilityScoreID returns the old "ability_score_id" field's value of the CharacterAbilityScore entity.
// If the CharacterAbilityScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterAbilityScoreMutation) OldAbilityScoreID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbilityScoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbilityScoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbilityScoreID: %w", err)
	}
	return oldValue.AbilityScoreID, nil
}

// ResetAbilityScoreID resets all changes to the "ability_score_id" field.
func (m *CharacterAbilityScoreMutation) ResetAbilityScoreID() {
	m.ability_score = nil
}

// ClearCharacter clears the "character" edge to the Character entity.
func (m *CharacterAbilityScoreMutation) ClearCharacter() {
	m.clearedcharacter = true
	m.clearedFields[characterabilityscore.FieldCharacterID] = struct{}{}
}

// CharacterCleared reports if the "character" edge to the Character entity was cleared.
func (m *CharacterAbilityScoreMutation) CharacterCleared() bool {
	return m.clearedcharacter
}

// CharacterIDs returns the "character" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CharacterID instead. It exists only for internal usage by the builders.
func (m *CharacterAbilityScoreMutation) CharacterIDs() (ids []int) {
	if id := m.character; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCharacter resets all changes to the "character" edge.
func (m *CharacterAbilityScoreMutation) ResetCharacter() {
	m.character = nil
	m.clearedcharacter = false
}

// ClearAbilityScore clears the "ability_score" edge to the AbilityScore entity.
func (m *CharacterAbilityScoreMutation) ClearAbilityScore() {
	m.clearedability_score = true
	m.clearedFields[characterabilityscore.FieldAbilityScoreID] = struct{}{}
}

// AbilityScoreCleared reports if the "ability_score" edge to the AbilityScore entity was cleared.
func (m *CharacterAbilityScoreMutation) AbilityScoreCleared() bool {
	return m.clearedability_score
}

// AbilityScoreIDs returns the "ability_score" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AbilityScoreID instead. It exists only for internal usage by the builders.
func (m *CharacterAbilityScoreMutation) AbilityScoreIDs() (ids []int) {
	if id := m.ability_score; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAbilityScore resets all changes to the "ability_score" edge.
func (m *CharacterAbilityScoreMutation) ResetAbilityScore() {
	m.ability_score = nil
	m.clearedability_score = false
}

// Where appends a list predicates to the CharacterAbilityScoreMutation builder.
func (m *CharacterAbilityScoreMutation) Where(ps ...predicate.CharacterAbilityScore) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CharacterAbilityScoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CharacterAbilityScoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CharacterAbilityScore, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CharacterAbilityScoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CharacterAbilityScoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CharacterAbilityScore).
func (m *CharacterAbilityScoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharacterAbilityScoreMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.score != nil {
		fields = append(fields, characterabilityscore.FieldScore)
	}
	if m.modifier != nil {
		fields = append(fields, characterabilityscore.FieldModifier)
	}
	if m.character != nil {
		fields = append(fields, characterabilityscore.FieldCharacterID)
	}
	if m.ability_score != nil {
		fields = append(fields, characterabilityscore.FieldAbilityScoreID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharacterAbilityScoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case characterabilityscore.FieldScore:
		return m.Score()
	case characterabilityscore.FieldModifier:
		return m.Modifier()
	case characterabilityscore.FieldCharacterID:
		return m.CharacterID()
	case characterabilityscore.FieldAbilityScoreID:
		return m.AbilityScoreID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharacterAbilityScoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case characterabilityscore.FieldScore:
		return m.OldScore(ctx)
	case characterabilityscore.FieldModifier:
		return m.OldModifier(ctx)
	case characterabilityscore.FieldCharacterID:
		return m.OldCharacterID(ctx)
	case characterabilityscore.FieldAbilityScoreID:
		return m.OldAbilityScoreID(ctx)
	}
	return nil, fmt.Errorf("unknown CharacterAbilityScore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterAbilityScoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case characterabilityscore.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case characterabilityscore.FieldModifier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifier(v)
		return nil
	case characterabilityscore.FieldCharacterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCharacterID(v)
		return nil
	case characterabilityscore.FieldAbilityScoreID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbilityScoreID(v)
		return nil
	}
	return fmt.Errorf("unknown CharacterAbilityScore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharacterAbilityScoreMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, characterabilityscore.FieldScore)
	}
	if m.addmodifier != nil {
		fields = append(fields, characterabilityscore.FieldModifier)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharacterAbilityScoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case characterabilityscore.FieldScore:
		return m.AddedScore()
	case characterabilityscore.FieldModifier:
		return m.AddedModifier()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterAbilityScoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case characterabilityscore.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case characterabilityscore.FieldModifier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModifier(v)
		return nil
	}
	return fmt.Errorf("unknown CharacterAbilityScore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharacterAbilityScoreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharacterAbilityScoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharacterAbilityScoreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CharacterAbilityScore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharacterAbilityScoreMutation) ResetField(name string) error {
	switch name {
	case characterabilityscore.FieldScore:
		m.ResetScore()
		return nil
	case characterabilityscore.FieldModifier:
		m.ResetModifier()
		return nil
	case characterabilityscore.FieldCharacterID:
		m.ResetCharacterID()
		return nil
	case characterabilityscore.FieldAbilityScoreID:
		m.ResetAbilityScoreID()
		return nil
	}
	return fmt.Errorf("unknown CharacterAbilityScore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharacterAbilityScoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.character != nil {
		edges = append(edges, characterabilityscore.EdgeCharacter)
	}
	if m.ability_score != nil {
		edges = append(edges, characterabilityscore.EdgeAbilityScore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharacterAbilityScoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case characterabilityscore.EdgeCharacter:
		if id := m.character; id != nil {
			return []ent.Value{*id}
		}
	case characterabilityscore.EdgeAbilityScore:
		if id := m.ability_score; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharacterAbilityScoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharacterAbilityScoreMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharacterAbilityScoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcharacter {
		edges = append(edges, characterabilityscore.EdgeCharacter)
	}
	if m.clearedability_score {
		edges = append(edges, characterabilityscore.EdgeAbilityScore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharacterAbilityScoreMutation) EdgeCleared(name string) bool {
	switch name {
	case characterabilityscore.EdgeCharacter:
		return m.clearedcharacter
	case characterabilityscore.EdgeAbilityScore:
		return m.clearedability_score
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharacterAbilityScoreMutation) ClearEdge(name string) error {
	switch name {
	case characterabilityscore.EdgeCharacter:
		m.ClearCharacter()
		return nil
	case characterabilityscore.EdgeAbilityScore:
		m.ClearAbilityScore()
		return nil
	}
	return fmt.Errorf("unknown CharacterAbilityScore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharacterAbilityScoreMutation) ResetEdge(name string) error {
	switch name {
	case characterabilityscore.EdgeCharacter:
		m.ResetCharacter()
		return nil
	case characterabilityscore.EdgeAbilityScore:
		m.ResetAbilityScore()
		return nil
	}
	return fmt.Errorf("unknown CharacterAbilityScore edge %s", name)
}

// CharacterProficiencyMutation represents an operation that mutates the CharacterProficiency nodes in the graph.
type CharacterProficiencyMutation struct {
	config
	op                 Op
	typ                string
	clearedFields      map[string]struct{}
	character          *int
	clearedcharacter   bool
	proficiency        *int
	clearedproficiency bool
	done               bool
	oldValue           func(context.Context) (*CharacterProficiency, error)
	predicates         []predicate.CharacterProficiency
}

var _ ent.Mutation = (*CharacterProficiencyMutation)(nil)

// characterproficiencyOption allows management of the mutation configuration using functional options.
type characterproficiencyOption func(*CharacterProficiencyMutation)

// newCharacterProficiencyMutation creates new mutation for the CharacterProficiency entity.
func newCharacterProficiencyMutation(c config, op Op, opts ...characterproficiencyOption) *CharacterProficiencyMutation {
	m := &CharacterProficiencyMutation{
		config:        c,
		op:            op,
		typ:           TypeCharacterProficiency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharacterProficiencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharacterProficiencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetCharacterID sets the "character_id" field.
func (m *CharacterProficiencyMutation) SetCharacterID(i int) {
	m.character = &i
}

// CharacterID returns the value of the "character_id" field in the mutation.
func (m *CharacterProficiencyMutation) CharacterID() (r int, exists bool) {
	v := m.character
	if v == nil {
		return
	}
	return *v, true
}

// ResetCharacterID resets all changes to the "character_id" field.
func (m *CharacterProficiencyMutation) ResetCharacterID() {
	m.character = nil
}

// SetProficiencyID sets the "proficiency_id" field.
func (m *CharacterProficiencyMutation) SetProficiencyID(i int) {
	m.proficiency = &i
}

// ProficiencyID returns the value of the "proficiency_id" field in the mutation.
func (m *CharacterProficiencyMutation) ProficiencyID() (r int, exists bool) {
	v := m.proficiency
	if v == nil {
		return
	}
	return *v, true
}

// ResetProficiencyID resets all changes to the "proficiency_id" field.
func (m *CharacterProficiencyMutation) ResetProficiencyID() {
	m.proficiency = nil
}

// ClearCharacter clears the "character" edge to the Character entity.
func (m *CharacterProficiencyMutation) ClearCharacter() {
	m.clearedcharacter = true
	m.clearedFields[characterproficiency.FieldCharacterID] = struct{}{}
}

// CharacterCleared reports if the "character" edge to the Character entity was cleared.
func (m *CharacterProficiencyMutation) CharacterCleared() bool {
	return m.clearedcharacter
}

// CharacterIDs returns the "character" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CharacterID instead. It exists only for internal usage by the builders.
func (m *CharacterProficiencyMutation) CharacterIDs() (ids []int) {
	if id := m.character; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCharacter resets all changes to the "character" edge.
func (m *CharacterProficiencyMutation) ResetCharacter() {
	m.character = nil
	m.clearedcharacter = false
}

// ClearProficiency clears the "proficiency" edge to the Proficiency entity.
func (m *CharacterProficiencyMutation) ClearProficiency() {
	m.clearedproficiency = true
	m.clearedFields[characterproficiency.FieldProficiencyID] = struct{}{}
}

// ProficiencyCleared reports if the "proficiency" edge to the Proficiency entity was cleared.
func (m *CharacterProficiencyMutation) ProficiencyCleared() bool {
	return m.clearedproficiency
}

// ProficiencyIDs returns the "proficiency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProficiencyID instead. It exists only for internal usage by the builders.
func (m *CharacterProficiencyMutation) ProficiencyIDs() (ids []int) {
	if id := m.proficiency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProficiency resets all changes to the "proficiency" edge.
func (m *CharacterProficiencyMutation) ResetProficiency() {
	m.proficiency = nil
	m.clearedproficiency = false
}

// Where appends a list predicates to the CharacterProficiencyMutation builder.
func (m *CharacterProficiencyMutation) Where(ps ...predicate.CharacterProficiency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CharacterProficiencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CharacterProficiencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CharacterProficiency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CharacterProficiencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CharacterProficiencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CharacterProficiency).
func (m *CharacterProficiencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharacterProficiencyMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.character != nil {
		fields = append(fields, characterproficiency.FieldCharacterID)
	}
	if m.proficiency != nil {
		fields = append(fields, characterproficiency.FieldProficiencyID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharacterProficiencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case characterproficiency.FieldCharacterID:
		return m.CharacterID()
	case characterproficiency.FieldProficiencyID:
		return m.ProficiencyID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharacterProficiencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema CharacterProficiency does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterProficiencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case characterproficiency.FieldCharacterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCharacterID(v)
		return nil
	case characterproficiency.FieldProficiencyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProficiencyID(v)
		return nil
	}
	return fmt.Errorf("unknown CharacterProficiency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharacterProficiencyMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharacterProficiencyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterProficiencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CharacterProficiency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharacterProficiencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharacterProficiencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharacterProficiencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CharacterProficiency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharacterProficiencyMutation) ResetField(name string) error {
	switch name {
	case characterproficiency.FieldCharacterID:
		m.ResetCharacterID()
		return nil
	case characterproficiency.FieldProficiencyID:
		m.ResetProficiencyID()
		return nil
	}
	return fmt.Errorf("unknown CharacterProficiency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharacterProficiencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.character != nil {
		edges = append(edges, characterproficiency.EdgeCharacter)
	}
	if m.proficiency != nil {
		edges = append(edges, characterproficiency.EdgeProficiency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharacterProficiencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case characterproficiency.EdgeCharacter:
		if id := m.character; id != nil {
			return []ent.Value{*id}
		}
	case characterproficiency.EdgeProficiency:
		if id := m.proficiency; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharacterProficiencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharacterProficiencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharacterProficiencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcharacter {
		edges = append(edges, characterproficiency.EdgeCharacter)
	}
	if m.clearedproficiency {
		edges = append(edges, characterproficiency.EdgeProficiency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharacterProficiencyMutation) EdgeCleared(name string) bool {
	switch name {
	case characterproficiency.EdgeCharacter:
		return m.clearedcharacter
	case characterproficiency.EdgeProficiency:
		return m.clearedproficiency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharacterProficiencyMutation) ClearEdge(name string) error {
	switch name {
	case characterproficiency.EdgeCharacter:
		m.ClearCharacter()
		return nil
	case characterproficiency.EdgeProficiency:
		m.ClearProficiency()
		return nil
	}
	return fmt.Errorf("unknown CharacterProficiency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharacterProficiencyMutation) ResetEdge(name string) error {
	switch name {
	case characterproficiency.EdgeCharacter:
		m.ResetCharacter()
		return nil
	case characterproficiency.EdgeProficiency:
		m.ResetProficiency()
		return nil
	}
	return fmt.Errorf("unknown CharacterProficiency edge %s", name)
}

// CharacterSkillMutation represents an operation that mutates the CharacterSkill nodes in the graph.
type CharacterSkillMutation struct {
	config
	op               Op
	typ              string
	id               *int
	proficient       *bool
	modifier         *int
	addmodifier      *int
	clearedFields    map[string]struct{}
	character        *int
	clearedcharacter bool
	skill            *int
	clearedskill     bool
	done             bool
	oldValue         func(context.Context) (*CharacterSkill, error)
	predicates       []predicate.CharacterSkill
}

var _ ent.Mutation = (*CharacterSkillMutation)(nil)

// characterskillOption allows management of the mutation configuration using functional options.
type characterskillOption func(*CharacterSkillMutation)

// newCharacterSkillMutation creates new mutation for the CharacterSkill entity.
func newCharacterSkillMutation(c config, op Op, opts ...characterskillOption) *CharacterSkillMutation {
	m := &CharacterSkillMutation{
		config:        c,
		op:            op,
		typ:           TypeCharacterSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCharacterSkillID sets the ID field of the mutation.
func withCharacterSkillID(id int) characterskillOption {
	return func(m *CharacterSkillMutation) {
		var (
			err   error
			once  sync.Once
			value *CharacterSkill
		)
		m.oldValue = func(ctx context.Context) (*CharacterSkill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CharacterSkill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharacterSkill sets the old CharacterSkill of the mutation.
func withCharacterSkill(node *CharacterSkill) characterskillOption {
	return func(m *CharacterSkillMutation) {
		m.oldValue = func(context.Context) (*CharacterSkill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CharacterSkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CharacterSkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CharacterSkillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CharacterSkillMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CharacterSkill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProficient sets the "proficient" field.
func (m *CharacterSkillMutation) SetProficient(b bool) {
	m.proficient = &b
}

// Proficient returns the value of the "proficient" field in the mutation.
func (m *CharacterSkillMutation) Proficient() (r bool, exists bool) {
	v := m.proficient
	if v == nil {
		return
	}
	return *v, true
}

// OldProficient returns the old "proficient" field's value of the CharacterSkill entity.
// If the CharacterSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterSkillMutation) OldProficient(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProficient is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProficient requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProficient: %w", err)
	}
	return oldValue.Proficient, nil
}

// ResetProficient resets all changes to the "proficient" field.
func (m *CharacterSkillMutation) ResetProficient() {
	m.proficient = nil
}

// SetModifier sets the "modifier" field.
func (m *CharacterSkillMutation) SetModifier(i int) {
	m.modifier = &i
	m.addmodifier = nil
}

// Modifier returns the value of the "modifier" field in the mutation.
func (m *CharacterSkillMutation) Modifier() (r int, exists bool) {
	v := m.modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldModifier returns the old "modifier" field's value of the CharacterSkill entity.
// If the CharacterSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterSkillMutation) OldModifier(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifier: %w", err)
	}
	return oldValue.Modifier, nil
}

// AddModifier adds i to the "modifier" field.
func (m *CharacterSkillMutation) AddModifier(i int) {
	if m.addmodifier != nil {
		*m.addmodifier += i
	} else {
		m.addmodifier = &i
	}
}

// AddedModifier returns the value that was added to the "modifier" field in this mutation.
func (m *CharacterSkillMutation) AddedModifier() (r int, exists bool) {
	v := m.addmodifier
	if v == nil {
		return
	}
	return *v, true
}

// ResetModifier resets all changes to the "modifier" field.
func (m *CharacterSkillMutation) ResetModifier() {
	m.modifier = nil
	m.addmodifier = nil
}

// SetCharacterID sets the "character_id" field.
func (m *CharacterSkillMutation) SetCharacterID(i int) {
	m.character = &i
}

// CharacterID returns the value of the "character_id" field in the mutation.
func (m *CharacterSkillMutation) CharacterID() (r int, exists bool) {
	v := m.character
	if v == nil {
		return
	}
	return *v, true
}

// OldCharacterID returns the old "character_id" field's value of the CharacterSkill entity.
// If the CharacterSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterSkillMutation) OldCharacterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCharacterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCharacterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCharacterID: %w", err)
	}
	return oldValue.CharacterID, nil
}

// ResetCharacterID resets all changes to the "character_id" field.
func (m *CharacterSkillMutation) ResetCharacterID() {
	m.character = nil
}

// SetSkillID sets the "skill_id" field.
func (m *CharacterSkillMutation) SetSkillID(i int) {
	m.skill = &i
}

// SkillID returns the value of the "skill_id" field in the mutation.
func (m *CharacterSkillMutation) SkillID() (r int, exists bool) {
	v := m.skill
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillID returns the old "skill_id" field's value of the CharacterSkill entity.
// If the CharacterSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CharacterSkillMutation) OldSkillID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillID: %w", err)
	}
	return oldValue.SkillID, nil
}

// ResetSkillID resets all changes to the "skill_id" field.
func (m *CharacterSkillMutation) ResetSkillID() {
	m.skill = nil
}

// ClearCharacter clears the "character" edge to the Character entity.
func (m *CharacterSkillMutation) ClearCharacter() {
	m.clearedcharacter = true
	m.clearedFields[characterskill.FieldCharacterID] = struct{}{}
}

// CharacterCleared reports if the "character" edge to the Character entity was cleared.
func (m *CharacterSkillMutation) CharacterCleared() bool {
	return m.clearedcharacter
}

// CharacterIDs returns the "character" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CharacterID instead. It exists only for internal usage by the builders.
func (m *CharacterSkillMutation) CharacterIDs() (ids []int) {
	if id := m.character; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCharacter resets all changes to the "character" edge.
func (m *CharacterSkillMutation) ResetCharacter() {
	m.character = nil
	m.clearedcharacter = false
}

// ClearSkill clears the "skill" edge to the Skill entity.
func (m *CharacterSkillMutation) ClearSkill() {
	m.clearedskill = true
	m.clearedFields[characterskill.FieldSkillID] = struct{}{}
}

// SkillCleared reports if the "skill" edge to the Skill entity was cleared.
func (m *CharacterSkillMutation) SkillCleared() bool {
	return m.clearedskill
}

// SkillIDs returns the "skill" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SkillID instead. It exists only for internal usage by the builders.
func (m *CharacterSkillMutation) SkillIDs() (ids []int) {
	if id := m.skill; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSkill resets all changes to the "skill" edge.
func (m *CharacterSkillMutation) ResetSkill() {
	m.skill = nil
	m.clearedskill = false
}

// Where appends a list predicates to the CharacterSkillMutation builder.
func (m *CharacterSkillMutation) Where(ps ...predicate.CharacterSkill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CharacterSkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CharacterSkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CharacterSkill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CharacterSkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CharacterSkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CharacterSkill).
func (m *CharacterSkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CharacterSkillMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.proficient != nil {
		fields = append(fields, characterskill.FieldProficient)
	}
	if m.modifier != nil {
		fields = append(fields, characterskill.FieldModifier)
	}
	if m.character != nil {
		fields = append(fields, characterskill.FieldCharacterID)
	}
	if m.skill != nil {
		fields = append(fields, characterskill.FieldSkillID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CharacterSkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case characterskill.FieldProficient:
		return m.Proficient()
	case characterskill.FieldModifier:
		return m.Modifier()
	case characterskill.FieldCharacterID:
		return m.CharacterID()
	case characterskill.FieldSkillID:
		return m.SkillID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CharacterSkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case characterskill.FieldProficient:
		return m.OldProficient(ctx)
	case characterskill.FieldModifier:
		return m.OldModifier(ctx)
	case characterskill.FieldCharacterID:
		return m.OldCharacterID(ctx)
	case characterskill.FieldSkillID:
		return m.OldSkillID(ctx)
	}
	return nil, fmt.Errorf("unknown CharacterSkill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterSkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case characterskill.FieldProficient:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProficient(v)
		return nil
	case characterskill.FieldModifier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifier(v)
		return nil
	case characterskill.FieldCharacterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCharacterID(v)
		return nil
	case characterskill.FieldSkillID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillID(v)
		return nil
	}
	return fmt.Errorf("unknown CharacterSkill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CharacterSkillMutation) AddedFields() []string {
	var fields []string
	if m.addmodifier != nil {
		fields = append(fields, characterskill.FieldModifier)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CharacterSkillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case characterskill.FieldModifier:
		return m.AddedModifier()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CharacterSkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case characterskill.FieldModifier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModifier(v)
		return nil
	}
	return fmt.Errorf("unknown CharacterSkill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CharacterSkillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CharacterSkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CharacterSkillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CharacterSkill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CharacterSkillMutation) ResetField(name string) error {
	switch name {
	case characterskill.FieldProficient:
		m.ResetProficient()
		return nil
	case characterskill.FieldModifier:
		m.ResetModifier()
		return nil
	case characterskill.FieldCharacterID:
		m.ResetCharacterID()
		return nil
	case characterskill.FieldSkillID:
		m.ResetSkillID()
		return nil
	}
	return fmt.Errorf("unknown CharacterSkill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CharacterSkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.character != nil {
		edges = append(edges, characterskill.EdgeCharacter)
	}
	if m.skill != nil {
		edges = append(edges, characterskill.EdgeSkill)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CharacterSkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case characterskill.EdgeCharacter:
		if id := m.character; id != nil {
			return []ent.Value{*id}
		}
	case characterskill.EdgeSkill:
		if id := m.skill; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CharacterSkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CharacterSkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CharacterSkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcharacter {
		edges = append(edges, characterskill.EdgeCharacter)
	}
	if m.clearedskill {
		edges = append(edges, characterskill.EdgeSkill)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CharacterSkillMutation) EdgeCleared(name string) bool {
	switch name {
	case characterskill.EdgeCharacter:
		return m.clearedcharacter
	case characterskill.EdgeSkill:
		return m.clearedskill
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CharacterSkillMutation) ClearEdge(name string) error {
	switch name {
	case characterskill.EdgeCharacter:
		m.ClearCharacter()
		return nil
	case characterskill.EdgeSkill:
		m.ClearSkill()
		return nil
	}
	return fmt.Errorf("unknown CharacterSkill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CharacterSkillMutation) ResetEdge(name string) error {
	switch name {
	case characterskill.EdgeCharacter:
		m.ResetCharacter()
		return nil
	case characterskill.EdgeSkill:
		m.ResetSkill()
		return nil
	}
	return fmt.Errorf("unknown CharacterSkill edge %s", name)
}

// ClassMutation represents an operation that mutates the Class nodes in the graph.
type ClassMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	indx                       *string
	name                       *string
	hit_die                    *int
	addhit_die                 *int
	clearedFields              map[string]struct{}
	proficiencies              map[int]struct{}
	removedproficiencies       map[int]struct{}
	clearedproficiencies       bool
	proficiency_options        map[int]struct{}
	removedproficiency_options map[int]struct{}
	clearedproficiency_options bool
	starting_equipment         map[int]struct{}
	removedstarting_equipment  map[int]struct{}
	clearedstarting_equipment  bool
	saving_throws              map[int]struct{}
	removedsaving_throws       map[int]struct{}
	clearedsaving_throws       bool
	characters                 map[int]struct{}
	removedcharacters          map[int]struct{}
	clearedcharacters          bool
	done                       bool
	oldValue                   func(context.Context) (*Class, error)
	predicates                 []predicate.Class
}

var _ ent.Mutation = (*ClassMutation)(nil)

// classOption allows management of the mutation configuration using functional options.
type classOption func(*ClassMutation)

// newClassMutation creates new mutation for the Class entity.
func newClassMutation(c config, op Op, opts ...classOption) *ClassMutation {
	m := &ClassMutation{
		config:        c,
		op:            op,
		typ:           TypeClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassID sets the ID field of the mutation.
func withClassID(id int) classOption {
	return func(m *ClassMutation) {
		var (
			err   error
			once  sync.Once
			value *Class
		)
		m.oldValue = func(ctx context.Context) (*Class, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass sets the old Class of the mutation.
func withClass(node *Class) classOption {
	return func(m *ClassMutation) {
		m.oldValue = func(context.Context) (*Class, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Class.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *ClassMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *ClassMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *ClassMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *ClassMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClassMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClassMutation) ResetName() {
	m.name = nil
}

// SetHitDie sets the "hit_die" field.
func (m *ClassMutation) SetHitDie(i int) {
	m.hit_die = &i
	m.addhit_die = nil
}

// HitDie returns the value of the "hit_die" field in the mutation.
func (m *ClassMutation) HitDie() (r int, exists bool) {
	v := m.hit_die
	if v == nil {
		return
	}
	return *v, true
}

// OldHitDie returns the old "hit_die" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldHitDie(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHitDie is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHitDie requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHitDie: %w", err)
	}
	return oldValue.HitDie, nil
}

// AddHitDie adds i to the "hit_die" field.
func (m *ClassMutation) AddHitDie(i int) {
	if m.addhit_die != nil {
		*m.addhit_die += i
	} else {
		m.addhit_die = &i
	}
}

// AddedHitDie returns the value that was added to the "hit_die" field in this mutation.
func (m *ClassMutation) AddedHitDie() (r int, exists bool) {
	v := m.addhit_die
	if v == nil {
		return
	}
	return *v, true
}

// ResetHitDie resets all changes to the "hit_die" field.
func (m *ClassMutation) ResetHitDie() {
	m.hit_die = nil
	m.addhit_die = nil
}

// AddProficiencyIDs adds the "proficiencies" edge to the Proficiency entity by ids.
func (m *ClassMutation) AddProficiencyIDs(ids ...int) {
	if m.proficiencies == nil {
		m.proficiencies = make(map[int]struct{})
	}
	for i := range ids {
		m.proficiencies[ids[i]] = struct{}{}
	}
}

// ClearProficiencies clears the "proficiencies" edge to the Proficiency entity.
func (m *ClassMutation) ClearProficiencies() {
	m.clearedproficiencies = true
}

// ProficienciesCleared reports if the "proficiencies" edge to the Proficiency entity was cleared.
func (m *ClassMutation) ProficienciesCleared() bool {
	return m.clearedproficiencies
}

// RemoveProficiencyIDs removes the "proficiencies" edge to the Proficiency entity by IDs.
func (m *ClassMutation) RemoveProficiencyIDs(ids ...int) {
	if m.removedproficiencies == nil {
		m.removedproficiencies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.proficiencies, ids[i])
		m.removedproficiencies[ids[i]] = struct{}{}
	}
}

// RemovedProficiencies returns the removed IDs of the "proficiencies" edge to the Proficiency entity.
func (m *ClassMutation) RemovedProficienciesIDs() (ids []int) {
	for id := range m.removedproficiencies {
		ids = append(ids, id)
	}
	return
}

// ProficienciesIDs returns the "proficiencies" edge IDs in the mutation.
func (m *ClassMutation) ProficienciesIDs() (ids []int) {
	for id := range m.proficiencies {
		ids = append(ids, id)
	}
	return
}

// ResetProficiencies resets all changes to the "proficiencies" edge.
func (m *ClassMutation) ResetProficiencies() {
	m.proficiencies = nil
	m.clearedproficiencies = false
	m.removedproficiencies = nil
}

// AddProficiencyOptionIDs adds the "proficiency_options" edge to the ProficiencyChoice entity by ids.
func (m *ClassMutation) AddProficiencyOptionIDs(ids ...int) {
	if m.proficiency_options == nil {
		m.proficiency_options = make(map[int]struct{})
	}
	for i := range ids {
		m.proficiency_options[ids[i]] = struct{}{}
	}
}

// ClearProficiencyOptions clears the "proficiency_options" edge to the ProficiencyChoice entity.
func (m *ClassMutation) ClearProficiencyOptions() {
	m.clearedproficiency_options = true
}

// ProficiencyOptionsCleared reports if the "proficiency_options" edge to the ProficiencyChoice entity was cleared.
func (m *ClassMutation) ProficiencyOptionsCleared() bool {
	return m.clearedproficiency_options
}

// RemoveProficiencyOptionIDs removes the "proficiency_options" edge to the ProficiencyChoice entity by IDs.
func (m *ClassMutation) RemoveProficiencyOptionIDs(ids ...int) {
	if m.removedproficiency_options == nil {
		m.removedproficiency_options = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.proficiency_options, ids[i])
		m.removedproficiency_options[ids[i]] = struct{}{}
	}
}

// RemovedProficiencyOptions returns the removed IDs of the "proficiency_options" edge to the ProficiencyChoice entity.
func (m *ClassMutation) RemovedProficiencyOptionsIDs() (ids []int) {
	for id := range m.removedproficiency_options {
		ids = append(ids, id)
	}
	return
}

// ProficiencyOptionsIDs returns the "proficiency_options" edge IDs in the mutation.
func (m *ClassMutation) ProficiencyOptionsIDs() (ids []int) {
	for id := range m.proficiency_options {
		ids = append(ids, id)
	}
	return
}

// ResetProficiencyOptions resets all changes to the "proficiency_options" edge.
func (m *ClassMutation) ResetProficiencyOptions() {
	m.proficiency_options = nil
	m.clearedproficiency_options = false
	m.removedproficiency_options = nil
}

// AddStartingEquipmentIDs adds the "starting_equipment" edge to the EquipmentEntry entity by ids.
func (m *ClassMutation) AddStartingEquipmentIDs(ids ...int) {
	if m.starting_equipment == nil {
		m.starting_equipment = make(map[int]struct{})
	}
	for i := range ids {
		m.starting_equipment[ids[i]] = struct{}{}
	}
}

// ClearStartingEquipment clears the "starting_equipment" edge to the EquipmentEntry entity.
func (m *ClassMutation) ClearStartingEquipment() {
	m.clearedstarting_equipment = true
}

// StartingEquipmentCleared reports if the "starting_equipment" edge to the EquipmentEntry entity was cleared.
func (m *ClassMutation) StartingEquipmentCleared() bool {
	return m.clearedstarting_equipment
}

// RemoveStartingEquipmentIDs removes the "starting_equipment" edge to the EquipmentEntry entity by IDs.
func (m *ClassMutation) RemoveStartingEquipmentIDs(ids ...int) {
	if m.removedstarting_equipment == nil {
		m.removedstarting_equipment = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.starting_equipment, ids[i])
		m.removedstarting_equipment[ids[i]] = struct{}{}
	}
}

// RemovedStartingEquipment returns the removed IDs of the "starting_equipment" edge to the EquipmentEntry entity.
func (m *ClassMutation) RemovedStartingEquipmentIDs() (ids []int) {
	for id := range m.removedstarting_equipment {
		ids = append(ids, id)
	}
	return
}

// StartingEquipmentIDs returns the "starting_equipment" edge IDs in the mutation.
func (m *ClassMutation) StartingEquipmentIDs() (ids []int) {
	for id := range m.starting_equipment {
		ids = append(ids, id)
	}
	return
}

// ResetStartingEquipment resets all changes to the "starting_equipment" edge.
func (m *ClassMutation) ResetStartingEquipment() {
	m.starting_equipment = nil
	m.clearedstarting_equipment = false
	m.removedstarting_equipment = nil
}

// AddSavingThrowIDs adds the "saving_throws" edge to the AbilityScore entity by ids.
func (m *ClassMutation) AddSavingThrowIDs(ids ...int) {
	if m.saving_throws == nil {
		m.saving_throws = make(map[int]struct{})
	}
	for i := range ids {
		m.saving_throws[ids[i]] = struct{}{}
	}
}

// ClearSavingThrows clears the "saving_throws" edge to the AbilityScore entity.
func (m *ClassMutation) ClearSavingThrows() {
	m.clearedsaving_throws = true
}

// SavingThrowsCleared reports if the "saving_throws" edge to the AbilityScore entity was cleared.
func (m *ClassMutation) SavingThrowsCleared() bool {
	return m.clearedsaving_throws
}

// RemoveSavingThrowIDs removes the "saving_throws" edge to the AbilityScore entity by IDs.
func (m *ClassMutation) RemoveSavingThrowIDs(ids ...int) {
	if m.removedsaving_throws == nil {
		m.removedsaving_throws = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.saving_throws, ids[i])
		m.removedsaving_throws[ids[i]] = struct{}{}
	}
}

// RemovedSavingThrows returns the removed IDs of the "saving_throws" edge to the AbilityScore entity.
func (m *ClassMutation) RemovedSavingThrowsIDs() (ids []int) {
	for id := range m.removedsaving_throws {
		ids = append(ids, id)
	}
	return
}

// SavingThrowsIDs returns the "saving_throws" edge IDs in the mutation.
func (m *ClassMutation) SavingThrowsIDs() (ids []int) {
	for id := range m.saving_throws {
		ids = append(ids, id)
	}
	return
}

// ResetSavingThrows resets all changes to the "saving_throws" edge.
func (m *ClassMutation) ResetSavingThrows() {
	m.saving_throws = nil
	m.clearedsaving_throws = false
	m.removedsaving_throws = nil
}

// AddCharacterIDs adds the "characters" edge to the Character entity by ids.
func (m *ClassMutation) AddCharacterIDs(ids ...int) {
	if m.characters == nil {
		m.characters = make(map[int]struct{})
	}
	for i := range ids {
		m.characters[ids[i]] = struct{}{}
	}
}

// ClearCharacters clears the "characters" edge to the Character entity.
func (m *ClassMutation) ClearCharacters() {
	m.clearedcharacters = true
}

// CharactersCleared reports if the "characters" edge to the Character entity was cleared.
func (m *ClassMutation) CharactersCleared() bool {
	return m.clearedcharacters
}

// RemoveCharacterIDs removes the "characters" edge to the Character entity by IDs.
func (m *ClassMutation) RemoveCharacterIDs(ids ...int) {
	if m.removedcharacters == nil {
		m.removedcharacters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.characters, ids[i])
		m.removedcharacters[ids[i]] = struct{}{}
	}
}

// RemovedCharacters returns the removed IDs of the "characters" edge to the Character entity.
func (m *ClassMutation) RemovedCharactersIDs() (ids []int) {
	for id := range m.removedcharacters {
		ids = append(ids, id)
	}
	return
}

// CharactersIDs returns the "characters" edge IDs in the mutation.
func (m *ClassMutation) CharactersIDs() (ids []int) {
	for id := range m.characters {
		ids = append(ids, id)
	}
	return
}

// ResetCharacters resets all changes to the "characters" edge.
func (m *ClassMutation) ResetCharacters() {
	m.characters = nil
	m.clearedcharacters = false
	m.removedcharacters = nil
}

// Where appends a list predicates to the ClassMutation builder.
func (m *ClassMutation) Where(ps ...predicate.Class) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Class, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Class).
func (m *ClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, class.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, class.FieldName)
	}
	if m.hit_die != nil {
		fields = append(fields, class.FieldHitDie)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class.FieldIndx:
		return m.Indx()
	case class.FieldName:
		return m.Name()
	case class.FieldHitDie:
		return m.HitDie()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class.FieldIndx:
		return m.OldIndx(ctx)
	case class.FieldName:
		return m.OldName(ctx)
	case class.FieldHitDie:
		return m.OldHitDie(ctx)
	}
	return nil, fmt.Errorf("unknown Class field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case class.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case class.FieldHitDie:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHitDie(v)
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassMutation) AddedFields() []string {
	var fields []string
	if m.addhit_die != nil {
		fields = append(fields, class.FieldHitDie)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case class.FieldHitDie:
		return m.AddedHitDie()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	case class.FieldHitDie:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHitDie(v)
		return nil
	}
	return fmt.Errorf("unknown Class numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Class nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassMutation) ResetField(name string) error {
	switch name {
	case class.FieldIndx:
		m.ResetIndx()
		return nil
	case class.FieldName:
		m.ResetName()
		return nil
	case class.FieldHitDie:
		m.ResetHitDie()
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.proficiencies != nil {
		edges = append(edges, class.EdgeProficiencies)
	}
	if m.proficiency_options != nil {
		edges = append(edges, class.EdgeProficiencyOptions)
	}
	if m.starting_equipment != nil {
		edges = append(edges, class.EdgeStartingEquipment)
	}
	if m.saving_throws != nil {
		edges = append(edges, class.EdgeSavingThrows)
	}
	if m.characters != nil {
		edges = append(edges, class.EdgeCharacters)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeProficiencies:
		ids := make([]ent.Value, 0, len(m.proficiencies))
		for id := range m.proficiencies {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeProficiencyOptions:
		ids := make([]ent.Value, 0, len(m.proficiency_options))
		for id := range m.proficiency_options {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeStartingEquipment:
		ids := make([]ent.Value, 0, len(m.starting_equipment))
		for id := range m.starting_equipment {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeSavingThrows:
		ids := make([]ent.Value, 0, len(m.saving_throws))
		for id := range m.saving_throws {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeCharacters:
		ids := make([]ent.Value, 0, len(m.characters))
		for id := range m.characters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedproficiencies != nil {
		edges = append(edges, class.EdgeProficiencies)
	}
	if m.removedproficiency_options != nil {
		edges = append(edges, class.EdgeProficiencyOptions)
	}
	if m.removedstarting_equipment != nil {
		edges = append(edges, class.EdgeStartingEquipment)
	}
	if m.removedsaving_throws != nil {
		edges = append(edges, class.EdgeSavingThrows)
	}
	if m.removedcharacters != nil {
		edges = append(edges, class.EdgeCharacters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeProficiencies:
		ids := make([]ent.Value, 0, len(m.removedproficiencies))
		for id := range m.removedproficiencies {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeProficiencyOptions:
		ids := make([]ent.Value, 0, len(m.removedproficiency_options))
		for id := range m.removedproficiency_options {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeStartingEquipment:
		ids := make([]ent.Value, 0, len(m.removedstarting_equipment))
		for id := range m.removedstarting_equipment {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeSavingThrows:
		ids := make([]ent.Value, 0, len(m.removedsaving_throws))
		for id := range m.removedsaving_throws {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeCharacters:
		ids := make([]ent.Value, 0, len(m.removedcharacters))
		for id := range m.removedcharacters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedproficiencies {
		edges = append(edges, class.EdgeProficiencies)
	}
	if m.clearedproficiency_options {
		edges = append(edges, class.EdgeProficiencyOptions)
	}
	if m.clearedstarting_equipment {
		edges = append(edges, class.EdgeStartingEquipment)
	}
	if m.clearedsaving_throws {
		edges = append(edges, class.EdgeSavingThrows)
	}
	if m.clearedcharacters {
		edges = append(edges, class.EdgeCharacters)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassMutation) EdgeCleared(name string) bool {
	switch name {
	case class.EdgeProficiencies:
		return m.clearedproficiencies
	case class.EdgeProficiencyOptions:
		return m.clearedproficiency_options
	case class.EdgeStartingEquipment:
		return m.clearedstarting_equipment
	case class.EdgeSavingThrows:
		return m.clearedsaving_throws
	case class.EdgeCharacters:
		return m.clearedcharacters
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Class unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassMutation) ResetEdge(name string) error {
	switch name {
	case class.EdgeProficiencies:
		m.ResetProficiencies()
		return nil
	case class.EdgeProficiencyOptions:
		m.ResetProficiencyOptions()
		return nil
	case class.EdgeStartingEquipment:
		m.ResetStartingEquipment()
		return nil
	case class.EdgeSavingThrows:
		m.ResetSavingThrows()
		return nil
	case class.EdgeCharacters:
		m.ResetCharacters()
		return nil
	}
	return fmt.Errorf("unknown Class edge %s", name)
}

// CoinMutation represents an operation that mutates the Coin nodes in the graph.
type CoinMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	indx                    *string
	name                    *string
	desc                    *[]string
	appenddesc              []string
	gold_conversion_rate    *float64
	addgold_conversion_rate *float64
	clearedFields           map[string]struct{}
	costs                   map[int]struct{}
	removedcosts            map[int]struct{}
	clearedcosts            bool
	done                    bool
	oldValue                func(context.Context) (*Coin, error)
	predicates              []predicate.Coin
}

var _ ent.Mutation = (*CoinMutation)(nil)

// coinOption allows management of the mutation configuration using functional options.
type coinOption func(*CoinMutation)

// newCoinMutation creates new mutation for the Coin entity.
func newCoinMutation(c config, op Op, opts ...coinOption) *CoinMutation {
	m := &CoinMutation{
		config:        c,
		op:            op,
		typ:           TypeCoin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCoinID sets the ID field of the mutation.
func withCoinID(id int) coinOption {
	return func(m *CoinMutation) {
		var (
			err   error
			once  sync.Once
			value *Coin
		)
		m.oldValue = func(ctx context.Context) (*Coin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoin sets the old Coin of the mutation.
func withCoin(node *Coin) coinOption {
	return func(m *CoinMutation) {
		m.oldValue = func(context.Context) (*Coin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CoinMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CoinMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CoinMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CoinMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Coin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *CoinMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *CoinMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *CoinMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *CoinMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CoinMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CoinMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *CoinMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *CoinMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *CoinMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *CoinMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *CoinMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[coin.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *CoinMutation) DescCleared() bool {
	_, ok := m.clearedFields[coin.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *CoinMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, coin.FieldDesc)
}

// SetGoldConversionRate sets the "gold_conversion_rate" field.
func (m *CoinMutation) SetGoldConversionRate(f float64) {
	m.gold_conversion_rate = &f
	m.addgold_conversion_rate = nil
}

// GoldConversionRate returns the value of the "gold_conversion_rate" field in the mutation.
func (m *CoinMutation) GoldConversionRate() (r float64, exists bool) {
	v := m.gold_conversion_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldGoldConversionRate returns the old "gold_conversion_rate" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldGoldConversionRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoldConversionRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoldConversionRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoldConversionRate: %w", err)
	}
	return oldValue.GoldConversionRate, nil
}

// AddGoldConversionRate adds f to the "gold_conversion_rate" field.
func (m *CoinMutation) AddGoldConversionRate(f float64) {
	if m.addgold_conversion_rate != nil {
		*m.addgold_conversion_rate += f
	} else {
		m.addgold_conversion_rate = &f
	}
}

// AddedGoldConversionRate returns the value that was added to the "gold_conversion_rate" field in this mutation.
func (m *CoinMutation) AddedGoldConversionRate() (r float64, exists bool) {
	v := m.addgold_conversion_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetGoldConversionRate resets all changes to the "gold_conversion_rate" field.
func (m *CoinMutation) ResetGoldConversionRate() {
	m.gold_conversion_rate = nil
	m.addgold_conversion_rate = nil
}

// AddCostIDs adds the "costs" edge to the Cost entity by ids.
func (m *CoinMutation) AddCostIDs(ids ...int) {
	if m.costs == nil {
		m.costs = make(map[int]struct{})
	}
	for i := range ids {
		m.costs[ids[i]] = struct{}{}
	}
}

// ClearCosts clears the "costs" edge to the Cost entity.
func (m *CoinMutation) ClearCosts() {
	m.clearedcosts = true
}

// CostsCleared reports if the "costs" edge to the Cost entity was cleared.
func (m *CoinMutation) CostsCleared() bool {
	return m.clearedcosts
}

// RemoveCostIDs removes the "costs" edge to the Cost entity by IDs.
func (m *CoinMutation) RemoveCostIDs(ids ...int) {
	if m.removedcosts == nil {
		m.removedcosts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.costs, ids[i])
		m.removedcosts[ids[i]] = struct{}{}
	}
}

// RemovedCosts returns the removed IDs of the "costs" edge to the Cost entity.
func (m *CoinMutation) RemovedCostsIDs() (ids []int) {
	for id := range m.removedcosts {
		ids = append(ids, id)
	}
	return
}

// CostsIDs returns the "costs" edge IDs in the mutation.
func (m *CoinMutation) CostsIDs() (ids []int) {
	for id := range m.costs {
		ids = append(ids, id)
	}
	return
}

// ResetCosts resets all changes to the "costs" edge.
func (m *CoinMutation) ResetCosts() {
	m.costs = nil
	m.clearedcosts = false
	m.removedcosts = nil
}

// Where appends a list predicates to the CoinMutation builder.
func (m *CoinMutation) Where(ps ...predicate.Coin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CoinMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CoinMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Coin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CoinMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CoinMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Coin).
func (m *CoinMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CoinMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.indx != nil {
		fields = append(fields, coin.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, coin.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, coin.FieldDesc)
	}
	if m.gold_conversion_rate != nil {
		fields = append(fields, coin.FieldGoldConversionRate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CoinMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coin.FieldIndx:
		return m.Indx()
	case coin.FieldName:
		return m.Name()
	case coin.FieldDesc:
		return m.Desc()
	case coin.FieldGoldConversionRate:
		return m.GoldConversionRate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CoinMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coin.FieldIndx:
		return m.OldIndx(ctx)
	case coin.FieldName:
		return m.OldName(ctx)
	case coin.FieldDesc:
		return m.OldDesc(ctx)
	case coin.FieldGoldConversionRate:
		return m.OldGoldConversionRate(ctx)
	}
	return nil, fmt.Errorf("unknown Coin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoinMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coin.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case coin.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coin.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case coin.FieldGoldConversionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoldConversionRate(v)
		return nil
	}
	return fmt.Errorf("unknown Coin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CoinMutation) AddedFields() []string {
	var fields []string
	if m.addgold_conversion_rate != nil {
		fields = append(fields, coin.FieldGoldConversionRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CoinMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coin.FieldGoldConversionRate:
		return m.AddedGoldConversionRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoinMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coin.FieldGoldConversionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoldConversionRate(v)
		return nil
	}
	return fmt.Errorf("unknown Coin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CoinMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coin.FieldDesc) {
		fields = append(fields, coin.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CoinMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CoinMutation) ClearField(name string) error {
	switch name {
	case coin.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Coin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CoinMutation) ResetField(name string) error {
	switch name {
	case coin.FieldIndx:
		m.ResetIndx()
		return nil
	case coin.FieldName:
		m.ResetName()
		return nil
	case coin.FieldDesc:
		m.ResetDesc()
		return nil
	case coin.FieldGoldConversionRate:
		m.ResetGoldConversionRate()
		return nil
	}
	return fmt.Errorf("unknown Coin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CoinMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.costs != nil {
		edges = append(edges, coin.EdgeCosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CoinMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case coin.EdgeCosts:
		ids := make([]ent.Value, 0, len(m.costs))
		for id := range m.costs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CoinMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcosts != nil {
		edges = append(edges, coin.EdgeCosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CoinMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case coin.EdgeCosts:
		ids := make([]ent.Value, 0, len(m.removedcosts))
		for id := range m.removedcosts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CoinMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcosts {
		edges = append(edges, coin.EdgeCosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CoinMutation) EdgeCleared(name string) bool {
	switch name {
	case coin.EdgeCosts:
		return m.clearedcosts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CoinMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Coin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CoinMutation) ResetEdge(name string) error {
	switch name {
	case coin.EdgeCosts:
		m.ResetCosts()
		return nil
	}
	return fmt.Errorf("unknown Coin edge %s", name)
}

// ConditionMutation represents an operation that mutates the Condition nodes in the graph.
type ConditionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Condition, error)
	predicates    []predicate.Condition
}

var _ ent.Mutation = (*ConditionMutation)(nil)

// conditionOption allows management of the mutation configuration using functional options.
type conditionOption func(*ConditionMutation)

// newConditionMutation creates new mutation for the Condition entity.
func newConditionMutation(c config, op Op, opts ...conditionOption) *ConditionMutation {
	m := &ConditionMutation{
		config:        c,
		op:            op,
		typ:           TypeCondition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConditionID sets the ID field of the mutation.
func withConditionID(id int) conditionOption {
	return func(m *ConditionMutation) {
		var (
			err   error
			once  sync.Once
			value *Condition
		)
		m.oldValue = func(ctx context.Context) (*Condition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Condition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCondition sets the old Condition of the mutation.
func withCondition(node *Condition) conditionOption {
	return func(m *ConditionMutation) {
		m.oldValue = func(context.Context) (*Condition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConditionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConditionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConditionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConditionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Condition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *ConditionMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *ConditionMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Condition entity.
// If the Condition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConditionMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *ConditionMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *ConditionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConditionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Condition entity.
// If the Condition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConditionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConditionMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *ConditionMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *ConditionMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Condition entity.
// If the Condition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConditionMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *ConditionMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *ConditionMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *ConditionMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[condition.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *ConditionMutation) DescCleared() bool {
	_, ok := m.clearedFields[condition.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *ConditionMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, condition.FieldDesc)
}

// Where appends a list predicates to the ConditionMutation builder.
func (m *ConditionMutation) Where(ps ...predicate.Condition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConditionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConditionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Condition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConditionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConditionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Condition).
func (m *ConditionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConditionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, condition.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, condition.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, condition.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConditionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case condition.FieldIndx:
		return m.Indx()
	case condition.FieldName:
		return m.Name()
	case condition.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConditionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case condition.FieldIndx:
		return m.OldIndx(ctx)
	case condition.FieldName:
		return m.OldName(ctx)
	case condition.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Condition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConditionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case condition.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case condition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case condition.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Condition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConditionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConditionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConditionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Condition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConditionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(condition.FieldDesc) {
		fields = append(fields, condition.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConditionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConditionMutation) ClearField(name string) error {
	switch name {
	case condition.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Condition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConditionMutation) ResetField(name string) error {
	switch name {
	case condition.FieldIndx:
		m.ResetIndx()
		return nil
	case condition.FieldName:
		m.ResetName()
		return nil
	case condition.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Condition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConditionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConditionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConditionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConditionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConditionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConditionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConditionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Condition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConditionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Condition edge %s", name)
}

// CostMutation represents an operation that mutates the Cost nodes in the graph.
type CostMutation struct {
	config
	op               Op
	typ              string
	id               *int
	quantity         *int
	addquantity      *int
	clearedFields    map[string]struct{}
	coin             *int
	clearedcoin      bool
	equipment        *int
	clearedequipment bool
	done             bool
	oldValue         func(context.Context) (*Cost, error)
	predicates       []predicate.Cost
}

var _ ent.Mutation = (*CostMutation)(nil)

// costOption allows management of the mutation configuration using functional options.
type costOption func(*CostMutation)

// newCostMutation creates new mutation for the Cost entity.
func newCostMutation(c config, op Op, opts ...costOption) *CostMutation {
	m := &CostMutation{
		config:        c,
		op:            op,
		typ:           TypeCost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCostID sets the ID field of the mutation.
func withCostID(id int) costOption {
	return func(m *CostMutation) {
		var (
			err   error
			once  sync.Once
			value *Cost
		)
		m.oldValue = func(ctx context.Context) (*Cost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCost sets the old Cost of the mutation.
func withCost(node *Cost) costOption {
	return func(m *CostMutation) {
		m.oldValue = func(context.Context) (*Cost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *CostMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *CostMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Cost entity.
// If the Cost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *CostMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *CostMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *CostMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetCoinID sets the "coin" edge to the Coin entity by id.
func (m *CostMutation) SetCoinID(id int) {
	m.coin = &id
}

// ClearCoin clears the "coin" edge to the Coin entity.
func (m *CostMutation) ClearCoin() {
	m.clearedcoin = true
}

// CoinCleared reports if the "coin" edge to the Coin entity was cleared.
func (m *CostMutation) CoinCleared() bool {
	return m.clearedcoin
}

// CoinID returns the "coin" edge ID in the mutation.
func (m *CostMutation) CoinID() (id int, exists bool) {
	if m.coin != nil {
		return *m.coin, true
	}
	return
}

// CoinIDs returns the "coin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoinID instead. It exists only for internal usage by the builders.
func (m *CostMutation) CoinIDs() (ids []int) {
	if id := m.coin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoin resets all changes to the "coin" edge.
func (m *CostMutation) ResetCoin() {
	m.coin = nil
	m.clearedcoin = false
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *CostMutation) SetEquipmentID(id int) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *CostMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *CostMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *CostMutation) EquipmentID() (id int, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *CostMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *CostMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// Where appends a list predicates to the CostMutation builder.
func (m *CostMutation) Where(ps ...predicate.Cost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cost).
func (m *CostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CostMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.quantity != nil {
		fields = append(fields, cost.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cost.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cost.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown Cost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cost.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Cost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CostMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, cost.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cost.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cost.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Cost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CostMutation) ResetField(name string) error {
	switch name {
	case cost.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown Cost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.coin != nil {
		edges = append(edges, cost.EdgeCoin)
	}
	if m.equipment != nil {
		edges = append(edges, cost.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cost.EdgeCoin:
		if id := m.coin; id != nil {
			return []ent.Value{*id}
		}
	case cost.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcoin {
		edges = append(edges, cost.EdgeCoin)
	}
	if m.clearedequipment {
		edges = append(edges, cost.EdgeEquipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CostMutation) EdgeCleared(name string) bool {
	switch name {
	case cost.EdgeCoin:
		return m.clearedcoin
	case cost.EdgeEquipment:
		return m.clearedequipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CostMutation) ClearEdge(name string) error {
	switch name {
	case cost.EdgeCoin:
		m.ClearCoin()
		return nil
	case cost.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown Cost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CostMutation) ResetEdge(name string) error {
	switch name {
	case cost.EdgeCoin:
		m.ResetCoin()
		return nil
	case cost.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown Cost edge %s", name)
}

// DamageTypeMutation represents an operation that mutates the DamageType nodes in the graph.
type DamageTypeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	indx           *string
	name           *string
	desc           *[]string
	appenddesc     []string
	clearedFields  map[string]struct{}
	weapons        map[int]struct{}
	removedweapons map[int]struct{}
	clearedweapons bool
	done           bool
	oldValue       func(context.Context) (*DamageType, error)
	predicates     []predicate.DamageType
}

var _ ent.Mutation = (*DamageTypeMutation)(nil)

// damagetypeOption allows management of the mutation configuration using functional options.
type damagetypeOption func(*DamageTypeMutation)

// newDamageTypeMutation creates new mutation for the DamageType entity.
func newDamageTypeMutation(c config, op Op, opts ...damagetypeOption) *DamageTypeMutation {
	m := &DamageTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeDamageType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDamageTypeID sets the ID field of the mutation.
func withDamageTypeID(id int) damagetypeOption {
	return func(m *DamageTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *DamageType
		)
		m.oldValue = func(ctx context.Context) (*DamageType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DamageType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDamageType sets the old DamageType of the mutation.
func withDamageType(node *DamageType) damagetypeOption {
	return func(m *DamageTypeMutation) {
		m.oldValue = func(context.Context) (*DamageType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DamageTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DamageTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DamageTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DamageTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DamageType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *DamageTypeMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *DamageTypeMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the DamageType entity.
// If the DamageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DamageTypeMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *DamageTypeMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *DamageTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DamageTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DamageType entity.
// If the DamageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DamageTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DamageTypeMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *DamageTypeMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *DamageTypeMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the DamageType entity.
// If the DamageType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DamageTypeMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *DamageTypeMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *DamageTypeMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *DamageTypeMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[damagetype.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *DamageTypeMutation) DescCleared() bool {
	_, ok := m.clearedFields[damagetype.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *DamageTypeMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, damagetype.FieldDesc)
}

// AddWeaponIDs adds the "weapons" edge to the Weapon entity by ids.
func (m *DamageTypeMutation) AddWeaponIDs(ids ...int) {
	if m.weapons == nil {
		m.weapons = make(map[int]struct{})
	}
	for i := range ids {
		m.weapons[ids[i]] = struct{}{}
	}
}

// ClearWeapons clears the "weapons" edge to the Weapon entity.
func (m *DamageTypeMutation) ClearWeapons() {
	m.clearedweapons = true
}

// WeaponsCleared reports if the "weapons" edge to the Weapon entity was cleared.
func (m *DamageTypeMutation) WeaponsCleared() bool {
	return m.clearedweapons
}

// RemoveWeaponIDs removes the "weapons" edge to the Weapon entity by IDs.
func (m *DamageTypeMutation) RemoveWeaponIDs(ids ...int) {
	if m.removedweapons == nil {
		m.removedweapons = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.weapons, ids[i])
		m.removedweapons[ids[i]] = struct{}{}
	}
}

// RemovedWeapons returns the removed IDs of the "weapons" edge to the Weapon entity.
func (m *DamageTypeMutation) RemovedWeaponsIDs() (ids []int) {
	for id := range m.removedweapons {
		ids = append(ids, id)
	}
	return
}

// WeaponsIDs returns the "weapons" edge IDs in the mutation.
func (m *DamageTypeMutation) WeaponsIDs() (ids []int) {
	for id := range m.weapons {
		ids = append(ids, id)
	}
	return
}

// ResetWeapons resets all changes to the "weapons" edge.
func (m *DamageTypeMutation) ResetWeapons() {
	m.weapons = nil
	m.clearedweapons = false
	m.removedweapons = nil
}

// Where appends a list predicates to the DamageTypeMutation builder.
func (m *DamageTypeMutation) Where(ps ...predicate.DamageType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DamageTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DamageTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DamageType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DamageTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DamageTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DamageType).
func (m *DamageTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DamageTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, damagetype.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, damagetype.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, damagetype.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DamageTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case damagetype.FieldIndx:
		return m.Indx()
	case damagetype.FieldName:
		return m.Name()
	case damagetype.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DamageTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case damagetype.FieldIndx:
		return m.OldIndx(ctx)
	case damagetype.FieldName:
		return m.OldName(ctx)
	case damagetype.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown DamageType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DamageTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case damagetype.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case damagetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case damagetype.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown DamageType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DamageTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DamageTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DamageTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DamageType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DamageTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(damagetype.FieldDesc) {
		fields = append(fields, damagetype.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DamageTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DamageTypeMutation) ClearField(name string) error {
	switch name {
	case damagetype.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown DamageType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DamageTypeMutation) ResetField(name string) error {
	switch name {
	case damagetype.FieldIndx:
		m.ResetIndx()
		return nil
	case damagetype.FieldName:
		m.ResetName()
		return nil
	case damagetype.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown DamageType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DamageTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.weapons != nil {
		edges = append(edges, damagetype.EdgeWeapons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DamageTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case damagetype.EdgeWeapons:
		ids := make([]ent.Value, 0, len(m.weapons))
		for id := range m.weapons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DamageTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedweapons != nil {
		edges = append(edges, damagetype.EdgeWeapons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DamageTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case damagetype.EdgeWeapons:
		ids := make([]ent.Value, 0, len(m.removedweapons))
		for id := range m.removedweapons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DamageTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedweapons {
		edges = append(edges, damagetype.EdgeWeapons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DamageTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case damagetype.EdgeWeapons:
		return m.clearedweapons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DamageTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DamageType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DamageTypeMutation) ResetEdge(name string) error {
	switch name {
	case damagetype.EdgeWeapons:
		m.ResetWeapons()
		return nil
	}
	return fmt.Errorf("unknown DamageType edge %s", name)
}

// EquipmentMutation represents an operation that mutates the Equipment nodes in the graph.
type EquipmentMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	indx                     *string
	name                     *string
	equipment_category       *equipment.EquipmentCategory
	weight                   *float64
	addweight                *float64
	clearedFields            map[string]struct{}
	cost                     *int
	clearedcost              bool
	gear                     *int
	clearedgear              bool
	tool                     *int
	clearedtool              bool
	weapon                   *int
	clearedweapon            bool
	vehicle                  *int
	clearedvehicle           bool
	armor                    *int
	clearedarmor             bool
	equipment_entries        map[int]struct{}
	removedequipment_entries map[int]struct{}
	clearedequipment_entries bool
	done                     bool
	oldValue                 func(context.Context) (*Equipment, error)
	predicates               []predicate.Equipment
}

var _ ent.Mutation = (*EquipmentMutation)(nil)

// equipmentOption allows management of the mutation configuration using functional options.
type equipmentOption func(*EquipmentMutation)

// newEquipmentMutation creates new mutation for the Equipment entity.
func newEquipmentMutation(c config, op Op, opts ...equipmentOption) *EquipmentMutation {
	m := &EquipmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentID sets the ID field of the mutation.
func withEquipmentID(id int) equipmentOption {
	return func(m *EquipmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Equipment
		)
		m.oldValue = func(ctx context.Context) (*Equipment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Equipment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipment sets the old Equipment of the mutation.
func withEquipment(node *Equipment) equipmentOption {
	return func(m *EquipmentMutation) {
		m.oldValue = func(context.Context) (*Equipment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Equipment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *EquipmentMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *EquipmentMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *EquipmentMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *EquipmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EquipmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EquipmentMutation) ResetName() {
	m.name = nil
}

// SetEquipmentCategory sets the "equipment_category" field.
func (m *EquipmentMutation) SetEquipmentCategory(ec equipment.EquipmentCategory) {
	m.equipment_category = &ec
}

// EquipmentCategory returns the value of the "equipment_category" field in the mutation.
func (m *EquipmentMutation) EquipmentCategory() (r equipment.EquipmentCategory, exists bool) {
	v := m.equipment_category
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentCategory returns the old "equipment_category" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldEquipmentCategory(ctx context.Context) (v equipment.EquipmentCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentCategory: %w", err)
	}
	return oldValue.EquipmentCategory, nil
}

// ResetEquipmentCategory resets all changes to the "equipment_category" field.
func (m *EquipmentMutation) ResetEquipmentCategory() {
	m.equipment_category = nil
}

// SetWeight sets the "weight" field.
func (m *EquipmentMutation) SetWeight(f float64) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *EquipmentMutation) Weight() (r float64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *EquipmentMutation) AddWeight(f float64) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *EquipmentMutation) AddedWeight() (r float64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *EquipmentMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[equipment.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *EquipmentMutation) WeightCleared() bool {
	_, ok := m.clearedFields[equipment.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *EquipmentMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, equipment.FieldWeight)
}

// SetCostID sets the "cost" edge to the Cost entity by id.
func (m *EquipmentMutation) SetCostID(id int) {
	m.cost = &id
}

// ClearCost clears the "cost" edge to the Cost entity.
func (m *EquipmentMutation) ClearCost() {
	m.clearedcost = true
}

// CostCleared reports if the "cost" edge to the Cost entity was cleared.
func (m *EquipmentMutation) CostCleared() bool {
	return m.clearedcost
}

// CostID returns the "cost" edge ID in the mutation.
func (m *EquipmentMutation) CostID() (id int, exists bool) {
	if m.cost != nil {
		return *m.cost, true
	}
	return
}

// CostIDs returns the "cost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CostID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) CostIDs() (ids []int) {
	if id := m.cost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCost resets all changes to the "cost" edge.
func (m *EquipmentMutation) ResetCost() {
	m.cost = nil
	m.clearedcost = false
}

// SetGearID sets the "gear" edge to the Gear entity by id.
func (m *EquipmentMutation) SetGearID(id int) {
	m.gear = &id
}

// ClearGear clears the "gear" edge to the Gear entity.
func (m *EquipmentMutation) ClearGear() {
	m.clearedgear = true
}

// GearCleared reports if the "gear" edge to the Gear entity was cleared.
func (m *EquipmentMutation) GearCleared() bool {
	return m.clearedgear
}

// GearID returns the "gear" edge ID in the mutation.
func (m *EquipmentMutation) GearID() (id int, exists bool) {
	if m.gear != nil {
		return *m.gear, true
	}
	return
}

// GearIDs returns the "gear" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GearID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) GearIDs() (ids []int) {
	if id := m.gear; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGear resets all changes to the "gear" edge.
func (m *EquipmentMutation) ResetGear() {
	m.gear = nil
	m.clearedgear = false
}

// SetToolID sets the "tool" edge to the Tool entity by id.
func (m *EquipmentMutation) SetToolID(id int) {
	m.tool = &id
}

// ClearTool clears the "tool" edge to the Tool entity.
func (m *EquipmentMutation) ClearTool() {
	m.clearedtool = true
}

// ToolCleared reports if the "tool" edge to the Tool entity was cleared.
func (m *EquipmentMutation) ToolCleared() bool {
	return m.clearedtool
}

// ToolID returns the "tool" edge ID in the mutation.
func (m *EquipmentMutation) ToolID() (id int, exists bool) {
	if m.tool != nil {
		return *m.tool, true
	}
	return
}

// ToolIDs returns the "tool" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToolID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) ToolIDs() (ids []int) {
	if id := m.tool; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTool resets all changes to the "tool" edge.
func (m *EquipmentMutation) ResetTool() {
	m.tool = nil
	m.clearedtool = false
}

// SetWeaponID sets the "weapon" edge to the Weapon entity by id.
func (m *EquipmentMutation) SetWeaponID(id int) {
	m.weapon = &id
}

// ClearWeapon clears the "weapon" edge to the Weapon entity.
func (m *EquipmentMutation) ClearWeapon() {
	m.clearedweapon = true
}

// WeaponCleared reports if the "weapon" edge to the Weapon entity was cleared.
func (m *EquipmentMutation) WeaponCleared() bool {
	return m.clearedweapon
}

// WeaponID returns the "weapon" edge ID in the mutation.
func (m *EquipmentMutation) WeaponID() (id int, exists bool) {
	if m.weapon != nil {
		return *m.weapon, true
	}
	return
}

// WeaponIDs returns the "weapon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WeaponID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) WeaponIDs() (ids []int) {
	if id := m.weapon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWeapon resets all changes to the "weapon" edge.
func (m *EquipmentMutation) ResetWeapon() {
	m.weapon = nil
	m.clearedweapon = false
}

// SetVehicleID sets the "vehicle" edge to the Vehicle entity by id.
func (m *EquipmentMutation) SetVehicleID(id int) {
	m.vehicle = &id
}

// ClearVehicle clears the "vehicle" edge to the Vehicle entity.
func (m *EquipmentMutation) ClearVehicle() {
	m.clearedvehicle = true
}

// VehicleCleared reports if the "vehicle" edge to the Vehicle entity was cleared.
func (m *EquipmentMutation) VehicleCleared() bool {
	return m.clearedvehicle
}

// VehicleID returns the "vehicle" edge ID in the mutation.
func (m *EquipmentMutation) VehicleID() (id int, exists bool) {
	if m.vehicle != nil {
		return *m.vehicle, true
	}
	return
}

// VehicleIDs returns the "vehicle" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VehicleID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) VehicleIDs() (ids []int) {
	if id := m.vehicle; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVehicle resets all changes to the "vehicle" edge.
func (m *EquipmentMutation) ResetVehicle() {
	m.vehicle = nil
	m.clearedvehicle = false
}

// SetArmorID sets the "armor" edge to the Armor entity by id.
func (m *EquipmentMutation) SetArmorID(id int) {
	m.armor = &id
}

// ClearArmor clears the "armor" edge to the Armor entity.
func (m *EquipmentMutation) ClearArmor() {
	m.clearedarmor = true
}

// ArmorCleared reports if the "armor" edge to the Armor entity was cleared.
func (m *EquipmentMutation) ArmorCleared() bool {
	return m.clearedarmor
}

// ArmorID returns the "armor" edge ID in the mutation.
func (m *EquipmentMutation) ArmorID() (id int, exists bool) {
	if m.armor != nil {
		return *m.armor, true
	}
	return
}

// ArmorIDs returns the "armor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArmorID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) ArmorIDs() (ids []int) {
	if id := m.armor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArmor resets all changes to the "armor" edge.
func (m *EquipmentMutation) ResetArmor() {
	m.armor = nil
	m.clearedarmor = false
}

// AddEquipmentEntryIDs adds the "equipment_entries" edge to the EquipmentEntry entity by ids.
func (m *EquipmentMutation) AddEquipmentEntryIDs(ids ...int) {
	if m.equipment_entries == nil {
		m.equipment_entries = make(map[int]struct{})
	}
	for i := range ids {
		m.equipment_entries[ids[i]] = struct{}{}
	}
}

// ClearEquipmentEntries clears the "equipment_entries" edge to the EquipmentEntry entity.
func (m *EquipmentMutation) ClearEquipmentEntries() {
	m.clearedequipment_entries = true
}

// EquipmentEntriesCleared reports if the "equipment_entries" edge to the EquipmentEntry entity was cleared.
func (m *EquipmentMutation) EquipmentEntriesCleared() bool {
	return m.clearedequipment_entries
}

// RemoveEquipmentEntryIDs removes the "equipment_entries" edge to the EquipmentEntry entity by IDs.
func (m *EquipmentMutation) RemoveEquipmentEntryIDs(ids ...int) {
	if m.removedequipment_entries == nil {
		m.removedequipment_entries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.equipment_entries, ids[i])
		m.removedequipment_entries[ids[i]] = struct{}{}
	}
}

// RemovedEquipmentEntries returns the removed IDs of the "equipment_entries" edge to the EquipmentEntry entity.
func (m *EquipmentMutation) RemovedEquipmentEntriesIDs() (ids []int) {
	for id := range m.removedequipment_entries {
		ids = append(ids, id)
	}
	return
}

// EquipmentEntriesIDs returns the "equipment_entries" edge IDs in the mutation.
func (m *EquipmentMutation) EquipmentEntriesIDs() (ids []int) {
	for id := range m.equipment_entries {
		ids = append(ids, id)
	}
	return
}

// ResetEquipmentEntries resets all changes to the "equipment_entries" edge.
func (m *EquipmentMutation) ResetEquipmentEntries() {
	m.equipment_entries = nil
	m.clearedequipment_entries = false
	m.removedequipment_entries = nil
}

// Where appends a list predicates to the EquipmentMutation builder.
func (m *EquipmentMutation) Where(ps ...predicate.Equipment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EquipmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EquipmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Equipment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EquipmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EquipmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Equipment).
func (m *EquipmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.indx != nil {
		fields = append(fields, equipment.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, equipment.FieldName)
	}
	if m.equipment_category != nil {
		fields = append(fields, equipment.FieldEquipmentCategory)
	}
	if m.weight != nil {
		fields = append(fields, equipment.FieldWeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipment.FieldIndx:
		return m.Indx()
	case equipment.FieldName:
		return m.Name()
	case equipment.FieldEquipmentCategory:
		return m.EquipmentCategory()
	case equipment.FieldWeight:
		return m.Weight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipment.FieldIndx:
		return m.OldIndx(ctx)
	case equipment.FieldName:
		return m.OldName(ctx)
	case equipment.FieldEquipmentCategory:
		return m.OldEquipmentCategory(ctx)
	case equipment.FieldWeight:
		return m.OldWeight(ctx)
	}
	return nil, fmt.Errorf("unknown Equipment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipment.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case equipment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case equipment.FieldEquipmentCategory:
		v, ok := value.(equipment.EquipmentCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentCategory(v)
		return nil
	case equipment.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, equipment.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipment.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipment.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Equipment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipment.FieldWeight) {
		fields = append(fields, equipment.FieldWeight)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentMutation) ClearField(name string) error {
	switch name {
	case equipment.FieldWeight:
		m.ClearWeight()
		return nil
	}
	return fmt.Errorf("unknown Equipment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentMutation) ResetField(name string) error {
	switch name {
	case equipment.FieldIndx:
		m.ResetIndx()
		return nil
	case equipment.FieldName:
		m.ResetName()
		return nil
	case equipment.FieldEquipmentCategory:
		m.ResetEquipmentCategory()
		return nil
	case equipment.FieldWeight:
		m.ResetWeight()
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cost != nil {
		edges = append(edges, equipment.EdgeCost)
	}
	if m.gear != nil {
		edges = append(edges, equipment.EdgeGear)
	}
	if m.tool != nil {
		edges = append(edges, equipment.EdgeTool)
	}
	if m.weapon != nil {
		edges = append(edges, equipment.EdgeWeapon)
	}
	if m.vehicle != nil {
		edges = append(edges, equipment.EdgeVehicle)
	}
	if m.armor != nil {
		edges = append(edges, equipment.EdgeArmor)
	}
	if m.equipment_entries != nil {
		edges = append(edges, equipment.EdgeEquipmentEntries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeCost:
		if id := m.cost; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeGear:
		if id := m.gear; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeTool:
		if id := m.tool; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeWeapon:
		if id := m.weapon; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeVehicle:
		if id := m.vehicle; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeArmor:
		if id := m.armor; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeEquipmentEntries:
		ids := make([]ent.Value, 0, len(m.equipment_entries))
		for id := range m.equipment_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedequipment_entries != nil {
		edges = append(edges, equipment.EdgeEquipmentEntries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeEquipmentEntries:
		ids := make([]ent.Value, 0, len(m.removedequipment_entries))
		for id := range m.removedequipment_entries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedcost {
		edges = append(edges, equipment.EdgeCost)
	}
	if m.clearedgear {
		edges = append(edges, equipment.EdgeGear)
	}
	if m.clearedtool {
		edges = append(edges, equipment.EdgeTool)
	}
	if m.clearedweapon {
		edges = append(edges, equipment.EdgeWeapon)
	}
	if m.clearedvehicle {
		edges = append(edges, equipment.EdgeVehicle)
	}
	if m.clearedarmor {
		edges = append(edges, equipment.EdgeArmor)
	}
	if m.clearedequipment_entries {
		edges = append(edges, equipment.EdgeEquipmentEntries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentMutation) EdgeCleared(name string) bool {
	switch name {
	case equipment.EdgeCost:
		return m.clearedcost
	case equipment.EdgeGear:
		return m.clearedgear
	case equipment.EdgeTool:
		return m.clearedtool
	case equipment.EdgeWeapon:
		return m.clearedweapon
	case equipment.EdgeVehicle:
		return m.clearedvehicle
	case equipment.EdgeArmor:
		return m.clearedarmor
	case equipment.EdgeEquipmentEntries:
		return m.clearedequipment_entries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentMutation) ClearEdge(name string) error {
	switch name {
	case equipment.EdgeCost:
		m.ClearCost()
		return nil
	case equipment.EdgeGear:
		m.ClearGear()
		return nil
	case equipment.EdgeTool:
		m.ClearTool()
		return nil
	case equipment.EdgeWeapon:
		m.ClearWeapon()
		return nil
	case equipment.EdgeVehicle:
		m.ClearVehicle()
		return nil
	case equipment.EdgeArmor:
		m.ClearArmor()
		return nil
	}
	return fmt.Errorf("unknown Equipment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentMutation) ResetEdge(name string) error {
	switch name {
	case equipment.EdgeCost:
		m.ResetCost()
		return nil
	case equipment.EdgeGear:
		m.ResetGear()
		return nil
	case equipment.EdgeTool:
		m.ResetTool()
		return nil
	case equipment.EdgeWeapon:
		m.ResetWeapon()
		return nil
	case equipment.EdgeVehicle:
		m.ResetVehicle()
		return nil
	case equipment.EdgeArmor:
		m.ResetArmor()
		return nil
	case equipment.EdgeEquipmentEntries:
		m.ResetEquipmentEntries()
		return nil
	}
	return fmt.Errorf("unknown Equipment edge %s", name)
}

// EquipmentEntryMutation represents an operation that mutates the EquipmentEntry nodes in the graph.
type EquipmentEntryMutation struct {
	config
	op               Op
	typ              string
	id               *int
	quantity         *int
	addquantity      *int
	clearedFields    map[string]struct{}
	class            map[int]struct{}
	removedclass     map[int]struct{}
	clearedclass     bool
	equipment        *int
	clearedequipment bool
	done             bool
	oldValue         func(context.Context) (*EquipmentEntry, error)
	predicates       []predicate.EquipmentEntry
}

var _ ent.Mutation = (*EquipmentEntryMutation)(nil)

// equipmententryOption allows management of the mutation configuration using functional options.
type equipmententryOption func(*EquipmentEntryMutation)

// newEquipmentEntryMutation creates new mutation for the EquipmentEntry entity.
func newEquipmentEntryMutation(c config, op Op, opts ...equipmententryOption) *EquipmentEntryMutation {
	m := &EquipmentEntryMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentEntry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentEntryID sets the ID field of the mutation.
func withEquipmentEntryID(id int) equipmententryOption {
	return func(m *EquipmentEntryMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentEntry
		)
		m.oldValue = func(ctx context.Context) (*EquipmentEntry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentEntry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentEntry sets the old EquipmentEntry of the mutation.
func withEquipmentEntry(node *EquipmentEntry) equipmententryOption {
	return func(m *EquipmentEntryMutation) {
		m.oldValue = func(context.Context) (*EquipmentEntry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentEntryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentEntryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentEntryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentEntryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EquipmentEntry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *EquipmentEntryMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *EquipmentEntryMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the EquipmentEntry entity.
// If the EquipmentEntry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentEntryMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *EquipmentEntryMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *EquipmentEntryMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *EquipmentEntryMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// AddClasIDs adds the "class" edge to the Class entity by ids.
func (m *EquipmentEntryMutation) AddClasIDs(ids ...int) {
	if m.class == nil {
		m.class = make(map[int]struct{})
	}
	for i := range ids {
		m.class[ids[i]] = struct{}{}
	}
}

// ClearClass clears the "class" edge to the Class entity.
func (m *EquipmentEntryMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *EquipmentEntryMutation) ClassCleared() bool {
	return m.clearedclass
}

// RemoveClasIDs removes the "class" edge to the Class entity by IDs.
func (m *EquipmentEntryMutation) RemoveClasIDs(ids ...int) {
	if m.removedclass == nil {
		m.removedclass = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.class, ids[i])
		m.removedclass[ids[i]] = struct{}{}
	}
}

// RemovedClass returns the removed IDs of the "class" edge to the Class entity.
func (m *EquipmentEntryMutation) RemovedClassIDs() (ids []int) {
	for id := range m.removedclass {
		ids = append(ids, id)
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
func (m *EquipmentEntryMutation) ClassIDs() (ids []int) {
	for id := range m.class {
		ids = append(ids, id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *EquipmentEntryMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
	m.removedclass = nil
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *EquipmentEntryMutation) SetEquipmentID(id int) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *EquipmentEntryMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *EquipmentEntryMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *EquipmentEntryMutation) EquipmentID() (id int, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *EquipmentEntryMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *EquipmentEntryMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// Where appends a list predicates to the EquipmentEntryMutation builder.
func (m *EquipmentEntryMutation) Where(ps ...predicate.EquipmentEntry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EquipmentEntryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EquipmentEntryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EquipmentEntry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EquipmentEntryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EquipmentEntryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EquipmentEntry).
func (m *EquipmentEntryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentEntryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.quantity != nil {
		fields = append(fields, equipmententry.FieldQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentEntryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmententry.FieldQuantity:
		return m.Quantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentEntryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmententry.FieldQuantity:
		return m.OldQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentEntry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentEntryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmententry.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentEntry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentEntryMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, equipmententry.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentEntryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmententry.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentEntryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmententry.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentEntry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentEntryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentEntryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentEntryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EquipmentEntry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentEntryMutation) ResetField(name string) error {
	switch name {
	case equipmententry.FieldQuantity:
		m.ResetQuantity()
		return nil
	}
	return fmt.Errorf("unknown EquipmentEntry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentEntryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.class != nil {
		edges = append(edges, equipmententry.EdgeClass)
	}
	if m.equipment != nil {
		edges = append(edges, equipmententry.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentEntryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmententry.EdgeClass:
		ids := make([]ent.Value, 0, len(m.class))
		for id := range m.class {
			ids = append(ids, id)
		}
		return ids
	case equipmententry.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentEntryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedclass != nil {
		edges = append(edges, equipmententry.EdgeClass)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentEntryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipmententry.EdgeClass:
		ids := make([]ent.Value, 0, len(m.removedclass))
		for id := range m.removedclass {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentEntryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclass {
		edges = append(edges, equipmententry.EdgeClass)
	}
	if m.clearedequipment {
		edges = append(edges, equipmententry.EdgeEquipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentEntryMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmententry.EdgeClass:
		return m.clearedclass
	case equipmententry.EdgeEquipment:
		return m.clearedequipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentEntryMutation) ClearEdge(name string) error {
	switch name {
	case equipmententry.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentEntry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentEntryMutation) ResetEdge(name string) error {
	switch name {
	case equipmententry.EdgeClass:
		m.ResetClass()
		return nil
	case equipmententry.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentEntry edge %s", name)
}

// FeatMutation represents an operation that mutates the Feat nodes in the graph.
type FeatMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Feat, error)
	predicates    []predicate.Feat
}

var _ ent.Mutation = (*FeatMutation)(nil)

// featOption allows management of the mutation configuration using functional options.
type featOption func(*FeatMutation)

// newFeatMutation creates new mutation for the Feat entity.
func newFeatMutation(c config, op Op, opts ...featOption) *FeatMutation {
	m := &FeatMutation{
		config:        c,
		op:            op,
		typ:           TypeFeat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatID sets the ID field of the mutation.
func withFeatID(id int) featOption {
	return func(m *FeatMutation) {
		var (
			err   error
			once  sync.Once
			value *Feat
		)
		m.oldValue = func(ctx context.Context) (*Feat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeat sets the old Feat of the mutation.
func withFeat(node *Feat) featOption {
	return func(m *FeatMutation) {
		m.oldValue = func(context.Context) (*Feat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *FeatMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *FeatMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Feat entity.
// If the Feat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *FeatMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *FeatMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Feat entity.
// If the Feat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *FeatMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *FeatMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Feat entity.
// If the Feat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *FeatMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *FeatMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *FeatMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[feat.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *FeatMutation) DescCleared() bool {
	_, ok := m.clearedFields[feat.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *FeatMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, feat.FieldDesc)
}

// Where appends a list predicates to the FeatMutation builder.
func (m *FeatMutation) Where(ps ...predicate.Feat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feat).
func (m *FeatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, feat.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, feat.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, feat.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feat.FieldIndx:
		return m.Indx()
	case feat.FieldName:
		return m.Name()
	case feat.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feat.FieldIndx:
		return m.OldIndx(ctx)
	case feat.FieldName:
		return m.OldName(ctx)
	case feat.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Feat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feat.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case feat.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feat.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Feat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feat.FieldDesc) {
		fields = append(fields, feat.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatMutation) ClearField(name string) error {
	switch name {
	case feat.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Feat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatMutation) ResetField(name string) error {
	switch name {
	case feat.FieldIndx:
		m.ResetIndx()
		return nil
	case feat.FieldName:
		m.ResetName()
		return nil
	case feat.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Feat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Feat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Feat edge %s", name)
}

// FeatureMutation represents an operation that mutates the Feature nodes in the graph.
type FeatureMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	indx                 *string
	name                 *string
	desc                 *[]string
	appenddesc           []string
	level                *int
	addlevel             *int
	clearedFields        map[string]struct{}
	prerequisites        map[int]struct{}
	removedprerequisites map[int]struct{}
	clearedprerequisites bool
	done                 bool
	oldValue             func(context.Context) (*Feature, error)
	predicates           []predicate.Feature
}

var _ ent.Mutation = (*FeatureMutation)(nil)

// featureOption allows management of the mutation configuration using functional options.
type featureOption func(*FeatureMutation)

// newFeatureMutation creates new mutation for the Feature entity.
func newFeatureMutation(c config, op Op, opts ...featureOption) *FeatureMutation {
	m := &FeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureID sets the ID field of the mutation.
func withFeatureID(id int) featureOption {
	return func(m *FeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *Feature
		)
		m.oldValue = func(ctx context.Context) (*Feature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeature sets the old Feature of the mutation.
func withFeature(node *Feature) featureOption {
	return func(m *FeatureMutation) {
		m.oldValue = func(context.Context) (*Feature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *FeatureMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *FeatureMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *FeatureMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *FeatureMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatureMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatureMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *FeatureMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *FeatureMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *FeatureMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *FeatureMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *FeatureMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[feature.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *FeatureMutation) DescCleared() bool {
	_, ok := m.clearedFields[feature.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *FeatureMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, feature.FieldDesc)
}

// SetLevel sets the "level" field.
func (m *FeatureMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *FeatureMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *FeatureMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *FeatureMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *FeatureMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// AddPrerequisiteIDs adds the "prerequisites" edge to the Prerequisite entity by ids.
func (m *FeatureMutation) AddPrerequisiteIDs(ids ...int) {
	if m.prerequisites == nil {
		m.prerequisites = make(map[int]struct{})
	}
	for i := range ids {
		m.prerequisites[ids[i]] = struct{}{}
	}
}

// ClearPrerequisites clears the "prerequisites" edge to the Prerequisite entity.
func (m *FeatureMutation) ClearPrerequisites() {
	m.clearedprerequisites = true
}

// PrerequisitesCleared reports if the "prerequisites" edge to the Prerequisite entity was cleared.
func (m *FeatureMutation) PrerequisitesCleared() bool {
	return m.clearedprerequisites
}

// RemovePrerequisiteIDs removes the "prerequisites" edge to the Prerequisite entity by IDs.
func (m *FeatureMutation) RemovePrerequisiteIDs(ids ...int) {
	if m.removedprerequisites == nil {
		m.removedprerequisites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.prerequisites, ids[i])
		m.removedprerequisites[ids[i]] = struct{}{}
	}
}

// RemovedPrerequisites returns the removed IDs of the "prerequisites" edge to the Prerequisite entity.
func (m *FeatureMutation) RemovedPrerequisitesIDs() (ids []int) {
	for id := range m.removedprerequisites {
		ids = append(ids, id)
	}
	return
}

// PrerequisitesIDs returns the "prerequisites" edge IDs in the mutation.
func (m *FeatureMutation) PrerequisitesIDs() (ids []int) {
	for id := range m.prerequisites {
		ids = append(ids, id)
	}
	return
}

// ResetPrerequisites resets all changes to the "prerequisites" edge.
func (m *FeatureMutation) ResetPrerequisites() {
	m.prerequisites = nil
	m.clearedprerequisites = false
	m.removedprerequisites = nil
}

// Where appends a list predicates to the FeatureMutation builder.
func (m *FeatureMutation) Where(ps ...predicate.Feature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feature).
func (m *FeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.indx != nil {
		fields = append(fields, feature.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, feature.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, feature.FieldDesc)
	}
	if m.level != nil {
		fields = append(fields, feature.FieldLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feature.FieldIndx:
		return m.Indx()
	case feature.FieldName:
		return m.Name()
	case feature.FieldDesc:
		return m.Desc()
	case feature.FieldLevel:
		return m.Level()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feature.FieldIndx:
		return m.OldIndx(ctx)
	case feature.FieldName:
		return m.OldName(ctx)
	case feature.FieldDesc:
		return m.OldDesc(ctx)
	case feature.FieldLevel:
		return m.OldLevel(ctx)
	}
	return nil, fmt.Errorf("unknown Feature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feature.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case feature.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feature.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case feature.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, feature.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feature.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feature.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Feature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feature.FieldDesc) {
		fields = append(fields, feature.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureMutation) ClearField(name string) error {
	switch name {
	case feature.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Feature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureMutation) ResetField(name string) error {
	switch name {
	case feature.FieldIndx:
		m.ResetIndx()
		return nil
	case feature.FieldName:
		m.ResetName()
		return nil
	case feature.FieldDesc:
		m.ResetDesc()
		return nil
	case feature.FieldLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.prerequisites != nil {
		edges = append(edges, feature.EdgePrerequisites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgePrerequisites:
		ids := make([]ent.Value, 0, len(m.prerequisites))
		for id := range m.prerequisites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprerequisites != nil {
		edges = append(edges, feature.EdgePrerequisites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgePrerequisites:
		ids := make([]ent.Value, 0, len(m.removedprerequisites))
		for id := range m.removedprerequisites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprerequisites {
		edges = append(edges, feature.EdgePrerequisites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case feature.EdgePrerequisites:
		return m.clearedprerequisites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureMutation) ResetEdge(name string) error {
	switch name {
	case feature.EdgePrerequisites:
		m.ResetPrerequisites()
		return nil
	}
	return fmt.Errorf("unknown Feature edge %s", name)
}

// GearMutation represents an operation that mutates the Gear nodes in the graph.
type GearMutation struct {
	config
	op               Op
	typ              string
	id               *int
	gear_category    *string
	desc             *[]string
	appenddesc       []string
	clearedFields    map[string]struct{}
	equipment        *int
	clearedequipment bool
	done             bool
	oldValue         func(context.Context) (*Gear, error)
	predicates       []predicate.Gear
}

var _ ent.Mutation = (*GearMutation)(nil)

// gearOption allows management of the mutation configuration using functional options.
type gearOption func(*GearMutation)

// newGearMutation creates new mutation for the Gear entity.
func newGearMutation(c config, op Op, opts ...gearOption) *GearMutation {
	m := &GearMutation{
		config:        c,
		op:            op,
		typ:           TypeGear,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGearID sets the ID field of the mutation.
func withGearID(id int) gearOption {
	return func(m *GearMutation) {
		var (
			err   error
			once  sync.Once
			value *Gear
		)
		m.oldValue = func(ctx context.Context) (*Gear, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gear.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGear sets the old Gear of the mutation.
func withGear(node *Gear) gearOption {
	return func(m *GearMutation) {
		m.oldValue = func(context.Context) (*Gear, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GearMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GearMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GearMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GearMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Gear.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGearCategory sets the "gear_category" field.
func (m *GearMutation) SetGearCategory(s string) {
	m.gear_category = &s
}

// GearCategory returns the value of the "gear_category" field in the mutation.
func (m *GearMutation) GearCategory() (r string, exists bool) {
	v := m.gear_category
	if v == nil {
		return
	}
	return *v, true
}

// OldGearCategory returns the old "gear_category" field's value of the Gear entity.
// If the Gear object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GearMutation) OldGearCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGearCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGearCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGearCategory: %w", err)
	}
	return oldValue.GearCategory, nil
}

// ResetGearCategory resets all changes to the "gear_category" field.
func (m *GearMutation) ResetGearCategory() {
	m.gear_category = nil
}

// SetDesc sets the "desc" field.
func (m *GearMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *GearMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Gear entity.
// If the Gear object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GearMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *GearMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *GearMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *GearMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[gear.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *GearMutation) DescCleared() bool {
	_, ok := m.clearedFields[gear.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *GearMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, gear.FieldDesc)
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *GearMutation) SetEquipmentID(id int) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *GearMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *GearMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *GearMutation) EquipmentID() (id int, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *GearMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *GearMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// Where appends a list predicates to the GearMutation builder.
func (m *GearMutation) Where(ps ...predicate.Gear) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GearMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GearMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Gear, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GearMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GearMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Gear).
func (m *GearMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GearMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.gear_category != nil {
		fields = append(fields, gear.FieldGearCategory)
	}
	if m.desc != nil {
		fields = append(fields, gear.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GearMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gear.FieldGearCategory:
		return m.GearCategory()
	case gear.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GearMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gear.FieldGearCategory:
		return m.OldGearCategory(ctx)
	case gear.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Gear field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GearMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gear.FieldGearCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGearCategory(v)
		return nil
	case gear.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Gear field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GearMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GearMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GearMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gear numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GearMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gear.FieldDesc) {
		fields = append(fields, gear.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GearMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GearMutation) ClearField(name string) error {
	switch name {
	case gear.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Gear nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GearMutation) ResetField(name string) error {
	switch name {
	case gear.FieldGearCategory:
		m.ResetGearCategory()
		return nil
	case gear.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Gear field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GearMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment != nil {
		edges = append(edges, gear.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GearMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gear.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GearMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GearMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GearMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedequipment {
		edges = append(edges, gear.EdgeEquipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GearMutation) EdgeCleared(name string) bool {
	switch name {
	case gear.EdgeEquipment:
		return m.clearedequipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GearMutation) ClearEdge(name string) error {
	switch name {
	case gear.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown Gear unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GearMutation) ResetEdge(name string) error {
	switch name {
	case gear.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown Gear edge %s", name)
}

// LanguageMutation represents an operation that mutates the Language nodes in the graph.
type LanguageMutation struct {
	config
	op             Op
	typ            string
	id             *int
	indx           *string
	name           *string
	desc           *[]string
	appenddesc     []string
	language_type  *language.LanguageType
	script         *language.Script
	clearedFields  map[string]struct{}
	race           map[int]struct{}
	removedrace    map[int]struct{}
	clearedrace    bool
	options        map[int]struct{}
	removedoptions map[int]struct{}
	clearedoptions bool
	done           bool
	oldValue       func(context.Context) (*Language, error)
	predicates     []predicate.Language
}

var _ ent.Mutation = (*LanguageMutation)(nil)

// languageOption allows management of the mutation configuration using functional options.
type languageOption func(*LanguageMutation)

// newLanguageMutation creates new mutation for the Language entity.
func newLanguageMutation(c config, op Op, opts ...languageOption) *LanguageMutation {
	m := &LanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLanguageID sets the ID field of the mutation.
func withLanguageID(id int) languageOption {
	return func(m *LanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *Language
		)
		m.oldValue = func(ctx context.Context) (*Language, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Language.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLanguage sets the old Language of the mutation.
func withLanguage(node *Language) languageOption {
	return func(m *LanguageMutation) {
		m.oldValue = func(context.Context) (*Language, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LanguageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LanguageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Language.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *LanguageMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *LanguageMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *LanguageMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *LanguageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LanguageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LanguageMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *LanguageMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *LanguageMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *LanguageMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *LanguageMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *LanguageMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[language.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *LanguageMutation) DescCleared() bool {
	_, ok := m.clearedFields[language.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *LanguageMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, language.FieldDesc)
}

// SetLanguageType sets the "language_type" field.
func (m *LanguageMutation) SetLanguageType(lt language.LanguageType) {
	m.language_type = &lt
}

// LanguageType returns the value of the "language_type" field in the mutation.
func (m *LanguageMutation) LanguageType() (r language.LanguageType, exists bool) {
	v := m.language_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageType returns the old "language_type" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldLanguageType(ctx context.Context) (v language.LanguageType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageType: %w", err)
	}
	return oldValue.LanguageType, nil
}

// ResetLanguageType resets all changes to the "language_type" field.
func (m *LanguageMutation) ResetLanguageType() {
	m.language_type = nil
}

// SetScript sets the "script" field.
func (m *LanguageMutation) SetScript(l language.Script) {
	m.script = &l
}

// Script returns the value of the "script" field in the mutation.
func (m *LanguageMutation) Script() (r language.Script, exists bool) {
	v := m.script
	if v == nil {
		return
	}
	return *v, true
}

// OldScript returns the old "script" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldScript(ctx context.Context) (v language.Script, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScript is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScript requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScript: %w", err)
	}
	return oldValue.Script, nil
}

// ResetScript resets all changes to the "script" field.
func (m *LanguageMutation) ResetScript() {
	m.script = nil
}

// AddRaceIDs adds the "race" edge to the Race entity by ids.
func (m *LanguageMutation) AddRaceIDs(ids ...int) {
	if m.race == nil {
		m.race = make(map[int]struct{})
	}
	for i := range ids {
		m.race[ids[i]] = struct{}{}
	}
}

// ClearRace clears the "race" edge to the Race entity.
func (m *LanguageMutation) ClearRace() {
	m.clearedrace = true
}

// RaceCleared reports if the "race" edge to the Race entity was cleared.
func (m *LanguageMutation) RaceCleared() bool {
	return m.clearedrace
}

// RemoveRaceIDs removes the "race" edge to the Race entity by IDs.
func (m *LanguageMutation) RemoveRaceIDs(ids ...int) {
	if m.removedrace == nil {
		m.removedrace = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.race, ids[i])
		m.removedrace[ids[i]] = struct{}{}
	}
}

// RemovedRace returns the removed IDs of the "race" edge to the Race entity.
func (m *LanguageMutation) RemovedRaceIDs() (ids []int) {
	for id := range m.removedrace {
		ids = append(ids, id)
	}
	return
}

// RaceIDs returns the "race" edge IDs in the mutation.
func (m *LanguageMutation) RaceIDs() (ids []int) {
	for id := range m.race {
		ids = append(ids, id)
	}
	return
}

// ResetRace resets all changes to the "race" edge.
func (m *LanguageMutation) ResetRace() {
	m.race = nil
	m.clearedrace = false
	m.removedrace = nil
}

// AddOptionIDs adds the "options" edge to the LanguageChoice entity by ids.
func (m *LanguageMutation) AddOptionIDs(ids ...int) {
	if m.options == nil {
		m.options = make(map[int]struct{})
	}
	for i := range ids {
		m.options[ids[i]] = struct{}{}
	}
}

// ClearOptions clears the "options" edge to the LanguageChoice entity.
func (m *LanguageMutation) ClearOptions() {
	m.clearedoptions = true
}

// OptionsCleared reports if the "options" edge to the LanguageChoice entity was cleared.
func (m *LanguageMutation) OptionsCleared() bool {
	return m.clearedoptions
}

// RemoveOptionIDs removes the "options" edge to the LanguageChoice entity by IDs.
func (m *LanguageMutation) RemoveOptionIDs(ids ...int) {
	if m.removedoptions == nil {
		m.removedoptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.options, ids[i])
		m.removedoptions[ids[i]] = struct{}{}
	}
}

// RemovedOptions returns the removed IDs of the "options" edge to the LanguageChoice entity.
func (m *LanguageMutation) RemovedOptionsIDs() (ids []int) {
	for id := range m.removedoptions {
		ids = append(ids, id)
	}
	return
}

// OptionsIDs returns the "options" edge IDs in the mutation.
func (m *LanguageMutation) OptionsIDs() (ids []int) {
	for id := range m.options {
		ids = append(ids, id)
	}
	return
}

// ResetOptions resets all changes to the "options" edge.
func (m *LanguageMutation) ResetOptions() {
	m.options = nil
	m.clearedoptions = false
	m.removedoptions = nil
}

// Where appends a list predicates to the LanguageMutation builder.
func (m *LanguageMutation) Where(ps ...predicate.Language) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Language, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Language).
func (m *LanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LanguageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.indx != nil {
		fields = append(fields, language.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, language.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, language.FieldDesc)
	}
	if m.language_type != nil {
		fields = append(fields, language.FieldLanguageType)
	}
	if m.script != nil {
		fields = append(fields, language.FieldScript)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case language.FieldIndx:
		return m.Indx()
	case language.FieldName:
		return m.Name()
	case language.FieldDesc:
		return m.Desc()
	case language.FieldLanguageType:
		return m.LanguageType()
	case language.FieldScript:
		return m.Script()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case language.FieldIndx:
		return m.OldIndx(ctx)
	case language.FieldName:
		return m.OldName(ctx)
	case language.FieldDesc:
		return m.OldDesc(ctx)
	case language.FieldLanguageType:
		return m.OldLanguageType(ctx)
	case language.FieldScript:
		return m.OldScript(ctx)
	}
	return nil, fmt.Errorf("unknown Language field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case language.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case language.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case language.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case language.FieldLanguageType:
		v, ok := value.(language.LanguageType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageType(v)
		return nil
	case language.FieldScript:
		v, ok := value.(language.Script)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScript(v)
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LanguageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LanguageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Language numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LanguageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(language.FieldDesc) {
		fields = append(fields, language.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LanguageMutation) ClearField(name string) error {
	switch name {
	case language.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Language nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LanguageMutation) ResetField(name string) error {
	switch name {
	case language.FieldIndx:
		m.ResetIndx()
		return nil
	case language.FieldName:
		m.ResetName()
		return nil
	case language.FieldDesc:
		m.ResetDesc()
		return nil
	case language.FieldLanguageType:
		m.ResetLanguageType()
		return nil
	case language.FieldScript:
		m.ResetScript()
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.race != nil {
		edges = append(edges, language.EdgeRace)
	}
	if m.options != nil {
		edges = append(edges, language.EdgeOptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LanguageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case language.EdgeRace:
		ids := make([]ent.Value, 0, len(m.race))
		for id := range m.race {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeOptions:
		ids := make([]ent.Value, 0, len(m.options))
		for id := range m.options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrace != nil {
		edges = append(edges, language.EdgeRace)
	}
	if m.removedoptions != nil {
		edges = append(edges, language.EdgeOptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LanguageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case language.EdgeRace:
		ids := make([]ent.Value, 0, len(m.removedrace))
		for id := range m.removedrace {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeOptions:
		ids := make([]ent.Value, 0, len(m.removedoptions))
		for id := range m.removedoptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrace {
		edges = append(edges, language.EdgeRace)
	}
	if m.clearedoptions {
		edges = append(edges, language.EdgeOptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LanguageMutation) EdgeCleared(name string) bool {
	switch name {
	case language.EdgeRace:
		return m.clearedrace
	case language.EdgeOptions:
		return m.clearedoptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LanguageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Language unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LanguageMutation) ResetEdge(name string) error {
	switch name {
	case language.EdgeRace:
		m.ResetRace()
		return nil
	case language.EdgeOptions:
		m.ResetOptions()
		return nil
	}
	return fmt.Errorf("unknown Language edge %s", name)
}

// LanguageChoiceMutation represents an operation that mutates the LanguageChoice nodes in the graph.
type LanguageChoiceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	choose           *int
	addchoose        *int
	clearedFields    map[string]struct{}
	languages        map[int]struct{}
	removedlanguages map[int]struct{}
	clearedlanguages bool
	race             *int
	clearedrace      bool
	done             bool
	oldValue         func(context.Context) (*LanguageChoice, error)
	predicates       []predicate.LanguageChoice
}

var _ ent.Mutation = (*LanguageChoiceMutation)(nil)

// languagechoiceOption allows management of the mutation configuration using functional options.
type languagechoiceOption func(*LanguageChoiceMutation)

// newLanguageChoiceMutation creates new mutation for the LanguageChoice entity.
func newLanguageChoiceMutation(c config, op Op, opts ...languagechoiceOption) *LanguageChoiceMutation {
	m := &LanguageChoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeLanguageChoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLanguageChoiceID sets the ID field of the mutation.
func withLanguageChoiceID(id int) languagechoiceOption {
	return func(m *LanguageChoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *LanguageChoice
		)
		m.oldValue = func(ctx context.Context) (*LanguageChoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LanguageChoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLanguageChoice sets the old LanguageChoice of the mutation.
func withLanguageChoice(node *LanguageChoice) languagechoiceOption {
	return func(m *LanguageChoiceMutation) {
		m.oldValue = func(context.Context) (*LanguageChoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LanguageChoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LanguageChoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LanguageChoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LanguageChoiceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LanguageChoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChoose sets the "choose" field.
func (m *LanguageChoiceMutation) SetChoose(i int) {
	m.choose = &i
	m.addchoose = nil
}

// Choose returns the value of the "choose" field in the mutation.
func (m *LanguageChoiceMutation) Choose() (r int, exists bool) {
	v := m.choose
	if v == nil {
		return
	}
	return *v, true
}

// OldChoose returns the old "choose" field's value of the LanguageChoice entity.
// If the LanguageChoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageChoiceMutation) OldChoose(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChoose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChoose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChoose: %w", err)
	}
	return oldValue.Choose, nil
}

// AddChoose adds i to the "choose" field.
func (m *LanguageChoiceMutation) AddChoose(i int) {
	if m.addchoose != nil {
		*m.addchoose += i
	} else {
		m.addchoose = &i
	}
}

// AddedChoose returns the value that was added to the "choose" field in this mutation.
func (m *LanguageChoiceMutation) AddedChoose() (r int, exists bool) {
	v := m.addchoose
	if v == nil {
		return
	}
	return *v, true
}

// ResetChoose resets all changes to the "choose" field.
func (m *LanguageChoiceMutation) ResetChoose() {
	m.choose = nil
	m.addchoose = nil
}

// AddLanguageIDs adds the "languages" edge to the Language entity by ids.
func (m *LanguageChoiceMutation) AddLanguageIDs(ids ...int) {
	if m.languages == nil {
		m.languages = make(map[int]struct{})
	}
	for i := range ids {
		m.languages[ids[i]] = struct{}{}
	}
}

// ClearLanguages clears the "languages" edge to the Language entity.
func (m *LanguageChoiceMutation) ClearLanguages() {
	m.clearedlanguages = true
}

// LanguagesCleared reports if the "languages" edge to the Language entity was cleared.
func (m *LanguageChoiceMutation) LanguagesCleared() bool {
	return m.clearedlanguages
}

// RemoveLanguageIDs removes the "languages" edge to the Language entity by IDs.
func (m *LanguageChoiceMutation) RemoveLanguageIDs(ids ...int) {
	if m.removedlanguages == nil {
		m.removedlanguages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.languages, ids[i])
		m.removedlanguages[ids[i]] = struct{}{}
	}
}

// RemovedLanguages returns the removed IDs of the "languages" edge to the Language entity.
func (m *LanguageChoiceMutation) RemovedLanguagesIDs() (ids []int) {
	for id := range m.removedlanguages {
		ids = append(ids, id)
	}
	return
}

// LanguagesIDs returns the "languages" edge IDs in the mutation.
func (m *LanguageChoiceMutation) LanguagesIDs() (ids []int) {
	for id := range m.languages {
		ids = append(ids, id)
	}
	return
}

// ResetLanguages resets all changes to the "languages" edge.
func (m *LanguageChoiceMutation) ResetLanguages() {
	m.languages = nil
	m.clearedlanguages = false
	m.removedlanguages = nil
}

// SetRaceID sets the "race" edge to the Race entity by id.
func (m *LanguageChoiceMutation) SetRaceID(id int) {
	m.race = &id
}

// ClearRace clears the "race" edge to the Race entity.
func (m *LanguageChoiceMutation) ClearRace() {
	m.clearedrace = true
}

// RaceCleared reports if the "race" edge to the Race entity was cleared.
func (m *LanguageChoiceMutation) RaceCleared() bool {
	return m.clearedrace
}

// RaceID returns the "race" edge ID in the mutation.
func (m *LanguageChoiceMutation) RaceID() (id int, exists bool) {
	if m.race != nil {
		return *m.race, true
	}
	return
}

// RaceIDs returns the "race" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RaceID instead. It exists only for internal usage by the builders.
func (m *LanguageChoiceMutation) RaceIDs() (ids []int) {
	if id := m.race; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRace resets all changes to the "race" edge.
func (m *LanguageChoiceMutation) ResetRace() {
	m.race = nil
	m.clearedrace = false
}

// Where appends a list predicates to the LanguageChoiceMutation builder.
func (m *LanguageChoiceMutation) Where(ps ...predicate.LanguageChoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LanguageChoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LanguageChoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LanguageChoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LanguageChoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LanguageChoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LanguageChoice).
func (m *LanguageChoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LanguageChoiceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.choose != nil {
		fields = append(fields, languagechoice.FieldChoose)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LanguageChoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case languagechoice.FieldChoose:
		return m.Choose()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LanguageChoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case languagechoice.FieldChoose:
		return m.OldChoose(ctx)
	}
	return nil, fmt.Errorf("unknown LanguageChoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageChoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case languagechoice.FieldChoose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChoose(v)
		return nil
	}
	return fmt.Errorf("unknown LanguageChoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LanguageChoiceMutation) AddedFields() []string {
	var fields []string
	if m.addchoose != nil {
		fields = append(fields, languagechoice.FieldChoose)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LanguageChoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case languagechoice.FieldChoose:
		return m.AddedChoose()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageChoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case languagechoice.FieldChoose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChoose(v)
		return nil
	}
	return fmt.Errorf("unknown LanguageChoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LanguageChoiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LanguageChoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LanguageChoiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LanguageChoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LanguageChoiceMutation) ResetField(name string) error {
	switch name {
	case languagechoice.FieldChoose:
		m.ResetChoose()
		return nil
	}
	return fmt.Errorf("unknown LanguageChoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LanguageChoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.languages != nil {
		edges = append(edges, languagechoice.EdgeLanguages)
	}
	if m.race != nil {
		edges = append(edges, languagechoice.EdgeRace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LanguageChoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case languagechoice.EdgeLanguages:
		ids := make([]ent.Value, 0, len(m.languages))
		for id := range m.languages {
			ids = append(ids, id)
		}
		return ids
	case languagechoice.EdgeRace:
		if id := m.race; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LanguageChoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedlanguages != nil {
		edges = append(edges, languagechoice.EdgeLanguages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LanguageChoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case languagechoice.EdgeLanguages:
		ids := make([]ent.Value, 0, len(m.removedlanguages))
		for id := range m.removedlanguages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LanguageChoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlanguages {
		edges = append(edges, languagechoice.EdgeLanguages)
	}
	if m.clearedrace {
		edges = append(edges, languagechoice.EdgeRace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LanguageChoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case languagechoice.EdgeLanguages:
		return m.clearedlanguages
	case languagechoice.EdgeRace:
		return m.clearedrace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LanguageChoiceMutation) ClearEdge(name string) error {
	switch name {
	case languagechoice.EdgeRace:
		m.ClearRace()
		return nil
	}
	return fmt.Errorf("unknown LanguageChoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LanguageChoiceMutation) ResetEdge(name string) error {
	switch name {
	case languagechoice.EdgeLanguages:
		m.ResetLanguages()
		return nil
	case languagechoice.EdgeRace:
		m.ResetRace()
		return nil
	}
	return fmt.Errorf("unknown LanguageChoice edge %s", name)
}

// MagicSchoolMutation represents an operation that mutates the MagicSchool nodes in the graph.
type MagicSchoolMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MagicSchool, error)
	predicates    []predicate.MagicSchool
}

var _ ent.Mutation = (*MagicSchoolMutation)(nil)

// magicschoolOption allows management of the mutation configuration using functional options.
type magicschoolOption func(*MagicSchoolMutation)

// newMagicSchoolMutation creates new mutation for the MagicSchool entity.
func newMagicSchoolMutation(c config, op Op, opts ...magicschoolOption) *MagicSchoolMutation {
	m := &MagicSchoolMutation{
		config:        c,
		op:            op,
		typ:           TypeMagicSchool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMagicSchoolID sets the ID field of the mutation.
func withMagicSchoolID(id int) magicschoolOption {
	return func(m *MagicSchoolMutation) {
		var (
			err   error
			once  sync.Once
			value *MagicSchool
		)
		m.oldValue = func(ctx context.Context) (*MagicSchool, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MagicSchool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMagicSchool sets the old MagicSchool of the mutation.
func withMagicSchool(node *MagicSchool) magicschoolOption {
	return func(m *MagicSchoolMutation) {
		m.oldValue = func(context.Context) (*MagicSchool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MagicSchoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MagicSchoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MagicSchoolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MagicSchoolMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MagicSchool.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *MagicSchoolMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *MagicSchoolMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the MagicSchool entity.
// If the MagicSchool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicSchoolMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *MagicSchoolMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *MagicSchoolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MagicSchoolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MagicSchool entity.
// If the MagicSchool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicSchoolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MagicSchoolMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *MagicSchoolMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *MagicSchoolMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the MagicSchool entity.
// If the MagicSchool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagicSchoolMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *MagicSchoolMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *MagicSchoolMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *MagicSchoolMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[magicschool.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *MagicSchoolMutation) DescCleared() bool {
	_, ok := m.clearedFields[magicschool.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *MagicSchoolMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, magicschool.FieldDesc)
}

// Where appends a list predicates to the MagicSchoolMutation builder.
func (m *MagicSchoolMutation) Where(ps ...predicate.MagicSchool) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MagicSchoolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MagicSchoolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MagicSchool, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MagicSchoolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MagicSchoolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MagicSchool).
func (m *MagicSchoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MagicSchoolMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, magicschool.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, magicschool.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, magicschool.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MagicSchoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case magicschool.FieldIndx:
		return m.Indx()
	case magicschool.FieldName:
		return m.Name()
	case magicschool.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MagicSchoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case magicschool.FieldIndx:
		return m.OldIndx(ctx)
	case magicschool.FieldName:
		return m.OldName(ctx)
	case magicschool.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown MagicSchool field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MagicSchoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case magicschool.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case magicschool.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case magicschool.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown MagicSchool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MagicSchoolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MagicSchoolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MagicSchoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MagicSchool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MagicSchoolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(magicschool.FieldDesc) {
		fields = append(fields, magicschool.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MagicSchoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MagicSchoolMutation) ClearField(name string) error {
	switch name {
	case magicschool.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown MagicSchool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MagicSchoolMutation) ResetField(name string) error {
	switch name {
	case magicschool.FieldIndx:
		m.ResetIndx()
		return nil
	case magicschool.FieldName:
		m.ResetName()
		return nil
	case magicschool.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown MagicSchool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MagicSchoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MagicSchoolMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MagicSchoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MagicSchoolMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MagicSchoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MagicSchoolMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MagicSchoolMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MagicSchool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MagicSchoolMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MagicSchool edge %s", name)
}

// PrerequisiteMutation represents an operation that mutates the Prerequisite nodes in the graph.
type PrerequisiteMutation struct {
	config
	op                Op
	typ               string
	id                *int
	prerequisite_type *prerequisite.PrerequisiteType
	level_value       *int
	addlevel_value    *int
	feature_value     *string
	spell_value       *string
	clearedFields     map[string]struct{}
	feature           *int
	clearedfeature    bool
	done              bool
	oldValue          func(context.Context) (*Prerequisite, error)
	predicates        []predicate.Prerequisite
}

var _ ent.Mutation = (*PrerequisiteMutation)(nil)

// prerequisiteOption allows management of the mutation configuration using functional options.
type prerequisiteOption func(*PrerequisiteMutation)

// newPrerequisiteMutation creates new mutation for the Prerequisite entity.
func newPrerequisiteMutation(c config, op Op, opts ...prerequisiteOption) *PrerequisiteMutation {
	m := &PrerequisiteMutation{
		config:        c,
		op:            op,
		typ:           TypePrerequisite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrerequisiteID sets the ID field of the mutation.
func withPrerequisiteID(id int) prerequisiteOption {
	return func(m *PrerequisiteMutation) {
		var (
			err   error
			once  sync.Once
			value *Prerequisite
		)
		m.oldValue = func(ctx context.Context) (*Prerequisite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prerequisite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrerequisite sets the old Prerequisite of the mutation.
func withPrerequisite(node *Prerequisite) prerequisiteOption {
	return func(m *PrerequisiteMutation) {
		m.oldValue = func(context.Context) (*Prerequisite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrerequisiteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrerequisiteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrerequisiteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrerequisiteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Prerequisite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrerequisiteType sets the "prerequisite_type" field.
func (m *PrerequisiteMutation) SetPrerequisiteType(pt prerequisite.PrerequisiteType) {
	m.prerequisite_type = &pt
}

// PrerequisiteType returns the value of the "prerequisite_type" field in the mutation.
func (m *PrerequisiteMutation) PrerequisiteType() (r prerequisite.PrerequisiteType, exists bool) {
	v := m.prerequisite_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPrerequisiteType returns the old "prerequisite_type" field's value of the Prerequisite entity.
// If the Prerequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrerequisiteMutation) OldPrerequisiteType(ctx context.Context) (v prerequisite.PrerequisiteType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrerequisiteType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrerequisiteType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrerequisiteType: %w", err)
	}
	return oldValue.PrerequisiteType, nil
}

// ResetPrerequisiteType resets all changes to the "prerequisite_type" field.
func (m *PrerequisiteMutation) ResetPrerequisiteType() {
	m.prerequisite_type = nil
}

// SetLevelValue sets the "level_value" field.
func (m *PrerequisiteMutation) SetLevelValue(i int) {
	m.level_value = &i
	m.addlevel_value = nil
}

// LevelValue returns the value of the "level_value" field in the mutation.
func (m *PrerequisiteMutation) LevelValue() (r int, exists bool) {
	v := m.level_value
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelValue returns the old "level_value" field's value of the Prerequisite entity.
// If the Prerequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrerequisiteMutation) OldLevelValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelValue: %w", err)
	}
	return oldValue.LevelValue, nil
}

// AddLevelValue adds i to the "level_value" field.
func (m *PrerequisiteMutation) AddLevelValue(i int) {
	if m.addlevel_value != nil {
		*m.addlevel_value += i
	} else {
		m.addlevel_value = &i
	}
}

// AddedLevelValue returns the value that was added to the "level_value" field in this mutation.
func (m *PrerequisiteMutation) AddedLevelValue() (r int, exists bool) {
	v := m.addlevel_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevelValue clears the value of the "level_value" field.
func (m *PrerequisiteMutation) ClearLevelValue() {
	m.level_value = nil
	m.addlevel_value = nil
	m.clearedFields[prerequisite.FieldLevelValue] = struct{}{}
}

// LevelValueCleared returns if the "level_value" field was cleared in this mutation.
func (m *PrerequisiteMutation) LevelValueCleared() bool {
	_, ok := m.clearedFields[prerequisite.FieldLevelValue]
	return ok
}

// ResetLevelValue resets all changes to the "level_value" field.
func (m *PrerequisiteMutation) ResetLevelValue() {
	m.level_value = nil
	m.addlevel_value = nil
	delete(m.clearedFields, prerequisite.FieldLevelValue)
}

// SetFeatureValue sets the "feature_value" field.
func (m *PrerequisiteMutation) SetFeatureValue(s string) {
	m.feature_value = &s
}

// FeatureValue returns the value of the "feature_value" field in the mutation.
func (m *PrerequisiteMutation) FeatureValue() (r string, exists bool) {
	v := m.feature_value
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureValue returns the old "feature_value" field's value of the Prerequisite entity.
// If the Prerequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrerequisiteMutation) OldFeatureValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureValue: %w", err)
	}
	return oldValue.FeatureValue, nil
}

// ClearFeatureValue clears the value of the "feature_value" field.
func (m *PrerequisiteMutation) ClearFeatureValue() {
	m.feature_value = nil
	m.clearedFields[prerequisite.FieldFeatureValue] = struct{}{}
}

// FeatureValueCleared returns if the "feature_value" field was cleared in this mutation.
func (m *PrerequisiteMutation) FeatureValueCleared() bool {
	_, ok := m.clearedFields[prerequisite.FieldFeatureValue]
	return ok
}

// ResetFeatureValue resets all changes to the "feature_value" field.
func (m *PrerequisiteMutation) ResetFeatureValue() {
	m.feature_value = nil
	delete(m.clearedFields, prerequisite.FieldFeatureValue)
}

// SetSpellValue sets the "spell_value" field.
func (m *PrerequisiteMutation) SetSpellValue(s string) {
	m.spell_value = &s
}

// SpellValue returns the value of the "spell_value" field in the mutation.
func (m *PrerequisiteMutation) SpellValue() (r string, exists bool) {
	v := m.spell_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSpellValue returns the old "spell_value" field's value of the Prerequisite entity.
// If the Prerequisite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrerequisiteMutation) OldSpellValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpellValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpellValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpellValue: %w", err)
	}
	return oldValue.SpellValue, nil
}

// ClearSpellValue clears the value of the "spell_value" field.
func (m *PrerequisiteMutation) ClearSpellValue() {
	m.spell_value = nil
	m.clearedFields[prerequisite.FieldSpellValue] = struct{}{}
}

// SpellValueCleared returns if the "spell_value" field was cleared in this mutation.
func (m *PrerequisiteMutation) SpellValueCleared() bool {
	_, ok := m.clearedFields[prerequisite.FieldSpellValue]
	return ok
}

// ResetSpellValue resets all changes to the "spell_value" field.
func (m *PrerequisiteMutation) ResetSpellValue() {
	m.spell_value = nil
	delete(m.clearedFields, prerequisite.FieldSpellValue)
}

// SetFeatureID sets the "feature" edge to the Feature entity by id.
func (m *PrerequisiteMutation) SetFeatureID(id int) {
	m.feature = &id
}

// ClearFeature clears the "feature" edge to the Feature entity.
func (m *PrerequisiteMutation) ClearFeature() {
	m.clearedfeature = true
}

// FeatureCleared reports if the "feature" edge to the Feature entity was cleared.
func (m *PrerequisiteMutation) FeatureCleared() bool {
	return m.clearedfeature
}

// FeatureID returns the "feature" edge ID in the mutation.
func (m *PrerequisiteMutation) FeatureID() (id int, exists bool) {
	if m.feature != nil {
		return *m.feature, true
	}
	return
}

// FeatureIDs returns the "feature" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureID instead. It exists only for internal usage by the builders.
func (m *PrerequisiteMutation) FeatureIDs() (ids []int) {
	if id := m.feature; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeature resets all changes to the "feature" edge.
func (m *PrerequisiteMutation) ResetFeature() {
	m.feature = nil
	m.clearedfeature = false
}

// Where appends a list predicates to the PrerequisiteMutation builder.
func (m *PrerequisiteMutation) Where(ps ...predicate.Prerequisite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrerequisiteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrerequisiteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Prerequisite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrerequisiteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrerequisiteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Prerequisite).
func (m *PrerequisiteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrerequisiteMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.prerequisite_type != nil {
		fields = append(fields, prerequisite.FieldPrerequisiteType)
	}
	if m.level_value != nil {
		fields = append(fields, prerequisite.FieldLevelValue)
	}
	if m.feature_value != nil {
		fields = append(fields, prerequisite.FieldFeatureValue)
	}
	if m.spell_value != nil {
		fields = append(fields, prerequisite.FieldSpellValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrerequisiteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prerequisite.FieldPrerequisiteType:
		return m.PrerequisiteType()
	case prerequisite.FieldLevelValue:
		return m.LevelValue()
	case prerequisite.FieldFeatureValue:
		return m.FeatureValue()
	case prerequisite.FieldSpellValue:
		return m.SpellValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrerequisiteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prerequisite.FieldPrerequisiteType:
		return m.OldPrerequisiteType(ctx)
	case prerequisite.FieldLevelValue:
		return m.OldLevelValue(ctx)
	case prerequisite.FieldFeatureValue:
		return m.OldFeatureValue(ctx)
	case prerequisite.FieldSpellValue:
		return m.OldSpellValue(ctx)
	}
	return nil, fmt.Errorf("unknown Prerequisite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrerequisiteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prerequisite.FieldPrerequisiteType:
		v, ok := value.(prerequisite.PrerequisiteType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrerequisiteType(v)
		return nil
	case prerequisite.FieldLevelValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelValue(v)
		return nil
	case prerequisite.FieldFeatureValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureValue(v)
		return nil
	case prerequisite.FieldSpellValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpellValue(v)
		return nil
	}
	return fmt.Errorf("unknown Prerequisite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrerequisiteMutation) AddedFields() []string {
	var fields []string
	if m.addlevel_value != nil {
		fields = append(fields, prerequisite.FieldLevelValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrerequisiteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prerequisite.FieldLevelValue:
		return m.AddedLevelValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrerequisiteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prerequisite.FieldLevelValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevelValue(v)
		return nil
	}
	return fmt.Errorf("unknown Prerequisite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrerequisiteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prerequisite.FieldLevelValue) {
		fields = append(fields, prerequisite.FieldLevelValue)
	}
	if m.FieldCleared(prerequisite.FieldFeatureValue) {
		fields = append(fields, prerequisite.FieldFeatureValue)
	}
	if m.FieldCleared(prerequisite.FieldSpellValue) {
		fields = append(fields, prerequisite.FieldSpellValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrerequisiteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrerequisiteMutation) ClearField(name string) error {
	switch name {
	case prerequisite.FieldLevelValue:
		m.ClearLevelValue()
		return nil
	case prerequisite.FieldFeatureValue:
		m.ClearFeatureValue()
		return nil
	case prerequisite.FieldSpellValue:
		m.ClearSpellValue()
		return nil
	}
	return fmt.Errorf("unknown Prerequisite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrerequisiteMutation) ResetField(name string) error {
	switch name {
	case prerequisite.FieldPrerequisiteType:
		m.ResetPrerequisiteType()
		return nil
	case prerequisite.FieldLevelValue:
		m.ResetLevelValue()
		return nil
	case prerequisite.FieldFeatureValue:
		m.ResetFeatureValue()
		return nil
	case prerequisite.FieldSpellValue:
		m.ResetSpellValue()
		return nil
	}
	return fmt.Errorf("unknown Prerequisite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrerequisiteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.feature != nil {
		edges = append(edges, prerequisite.EdgeFeature)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrerequisiteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prerequisite.EdgeFeature:
		if id := m.feature; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrerequisiteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrerequisiteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrerequisiteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfeature {
		edges = append(edges, prerequisite.EdgeFeature)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrerequisiteMutation) EdgeCleared(name string) bool {
	switch name {
	case prerequisite.EdgeFeature:
		return m.clearedfeature
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrerequisiteMutation) ClearEdge(name string) error {
	switch name {
	case prerequisite.EdgeFeature:
		m.ClearFeature()
		return nil
	}
	return fmt.Errorf("unknown Prerequisite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrerequisiteMutation) ResetEdge(name string) error {
	switch name {
	case prerequisite.EdgeFeature:
		m.ResetFeature()
		return nil
	}
	return fmt.Errorf("unknown Prerequisite edge %s", name)
}

// ProficiencyMutation represents an operation that mutates the Proficiency nodes in the graph.
type ProficiencyMutation struct {
	config
	op               Op
	typ              string
	id               *int
	indx             *string
	name             *string
	reference        *string
	clearedFields    map[string]struct{}
	race             map[int]struct{}
	removedrace      map[int]struct{}
	clearedrace      bool
	options          map[int]struct{}
	removedoptions   map[int]struct{}
	clearedoptions   bool
	class            map[int]struct{}
	removedclass     map[int]struct{}
	clearedclass     bool
	character        map[int]struct{}
	removedcharacter map[int]struct{}
	clearedcharacter bool
	done             bool
	oldValue         func(context.Context) (*Proficiency, error)
	predicates       []predicate.Proficiency
}

var _ ent.Mutation = (*ProficiencyMutation)(nil)

// proficiencyOption allows management of the mutation configuration using functional options.
type proficiencyOption func(*ProficiencyMutation)

// newProficiencyMutation creates new mutation for the Proficiency entity.
func newProficiencyMutation(c config, op Op, opts ...proficiencyOption) *ProficiencyMutation {
	m := &ProficiencyMutation{
		config:        c,
		op:            op,
		typ:           TypeProficiency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProficiencyID sets the ID field of the mutation.
func withProficiencyID(id int) proficiencyOption {
	return func(m *ProficiencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Proficiency
		)
		m.oldValue = func(ctx context.Context) (*Proficiency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Proficiency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProficiency sets the old Proficiency of the mutation.
func withProficiency(node *Proficiency) proficiencyOption {
	return func(m *ProficiencyMutation) {
		m.oldValue = func(context.Context) (*Proficiency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProficiencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProficiencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProficiencyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProficiencyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Proficiency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *ProficiencyMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *ProficiencyMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Proficiency entity.
// If the Proficiency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProficiencyMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *ProficiencyMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *ProficiencyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProficiencyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Proficiency entity.
// If the Proficiency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProficiencyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProficiencyMutation) ResetName() {
	m.name = nil
}

// SetReference sets the "reference" field.
func (m *ProficiencyMutation) SetReference(s string) {
	m.reference = &s
}

// Reference returns the value of the "reference" field in the mutation.
func (m *ProficiencyMutation) Reference() (r string, exists bool) {
	v := m.reference
	if v == nil {
		return
	}
	return *v, true
}

// OldReference returns the old "reference" field's value of the Proficiency entity.
// If the Proficiency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProficiencyMutation) OldReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReference: %w", err)
	}
	return oldValue.Reference, nil
}

// ResetReference resets all changes to the "reference" field.
func (m *ProficiencyMutation) ResetReference() {
	m.reference = nil
}

// AddRaceIDs adds the "race" edge to the Race entity by ids.
func (m *ProficiencyMutation) AddRaceIDs(ids ...int) {
	if m.race == nil {
		m.race = make(map[int]struct{})
	}
	for i := range ids {
		m.race[ids[i]] = struct{}{}
	}
}

// ClearRace clears the "race" edge to the Race entity.
func (m *ProficiencyMutation) ClearRace() {
	m.clearedrace = true
}

// RaceCleared reports if the "race" edge to the Race entity was cleared.
func (m *ProficiencyMutation) RaceCleared() bool {
	return m.clearedrace
}

// RemoveRaceIDs removes the "race" edge to the Race entity by IDs.
func (m *ProficiencyMutation) RemoveRaceIDs(ids ...int) {
	if m.removedrace == nil {
		m.removedrace = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.race, ids[i])
		m.removedrace[ids[i]] = struct{}{}
	}
}

// RemovedRace returns the removed IDs of the "race" edge to the Race entity.
func (m *ProficiencyMutation) RemovedRaceIDs() (ids []int) {
	for id := range m.removedrace {
		ids = append(ids, id)
	}
	return
}

// RaceIDs returns the "race" edge IDs in the mutation.
func (m *ProficiencyMutation) RaceIDs() (ids []int) {
	for id := range m.race {
		ids = append(ids, id)
	}
	return
}

// ResetRace resets all changes to the "race" edge.
func (m *ProficiencyMutation) ResetRace() {
	m.race = nil
	m.clearedrace = false
	m.removedrace = nil
}

// AddOptionIDs adds the "options" edge to the ProficiencyChoice entity by ids.
func (m *ProficiencyMutation) AddOptionIDs(ids ...int) {
	if m.options == nil {
		m.options = make(map[int]struct{})
	}
	for i := range ids {
		m.options[ids[i]] = struct{}{}
	}
}

// ClearOptions clears the "options" edge to the ProficiencyChoice entity.
func (m *ProficiencyMutation) ClearOptions() {
	m.clearedoptions = true
}

// OptionsCleared reports if the "options" edge to the ProficiencyChoice entity was cleared.
func (m *ProficiencyMutation) OptionsCleared() bool {
	return m.clearedoptions
}

// RemoveOptionIDs removes the "options" edge to the ProficiencyChoice entity by IDs.
func (m *ProficiencyMutation) RemoveOptionIDs(ids ...int) {
	if m.removedoptions == nil {
		m.removedoptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.options, ids[i])
		m.removedoptions[ids[i]] = struct{}{}
	}
}

// RemovedOptions returns the removed IDs of the "options" edge to the ProficiencyChoice entity.
func (m *ProficiencyMutation) RemovedOptionsIDs() (ids []int) {
	for id := range m.removedoptions {
		ids = append(ids, id)
	}
	return
}

// OptionsIDs returns the "options" edge IDs in the mutation.
func (m *ProficiencyMutation) OptionsIDs() (ids []int) {
	for id := range m.options {
		ids = append(ids, id)
	}
	return
}

// ResetOptions resets all changes to the "options" edge.
func (m *ProficiencyMutation) ResetOptions() {
	m.options = nil
	m.clearedoptions = false
	m.removedoptions = nil
}

// AddClasIDs adds the "class" edge to the Class entity by ids.
func (m *ProficiencyMutation) AddClasIDs(ids ...int) {
	if m.class == nil {
		m.class = make(map[int]struct{})
	}
	for i := range ids {
		m.class[ids[i]] = struct{}{}
	}
}

// ClearClass clears the "class" edge to the Class entity.
func (m *ProficiencyMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *ProficiencyMutation) ClassCleared() bool {
	return m.clearedclass
}

// RemoveClasIDs removes the "class" edge to the Class entity by IDs.
func (m *ProficiencyMutation) RemoveClasIDs(ids ...int) {
	if m.removedclass == nil {
		m.removedclass = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.class, ids[i])
		m.removedclass[ids[i]] = struct{}{}
	}
}

// RemovedClass returns the removed IDs of the "class" edge to the Class entity.
func (m *ProficiencyMutation) RemovedClassIDs() (ids []int) {
	for id := range m.removedclass {
		ids = append(ids, id)
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
func (m *ProficiencyMutation) ClassIDs() (ids []int) {
	for id := range m.class {
		ids = append(ids, id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ProficiencyMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
	m.removedclass = nil
}

// AddCharacterIDs adds the "character" edge to the Character entity by ids.
func (m *ProficiencyMutation) AddCharacterIDs(ids ...int) {
	if m.character == nil {
		m.character = make(map[int]struct{})
	}
	for i := range ids {
		m.character[ids[i]] = struct{}{}
	}
}

// ClearCharacter clears the "character" edge to the Character entity.
func (m *ProficiencyMutation) ClearCharacter() {
	m.clearedcharacter = true
}

// CharacterCleared reports if the "character" edge to the Character entity was cleared.
func (m *ProficiencyMutation) CharacterCleared() bool {
	return m.clearedcharacter
}

// RemoveCharacterIDs removes the "character" edge to the Character entity by IDs.
func (m *ProficiencyMutation) RemoveCharacterIDs(ids ...int) {
	if m.removedcharacter == nil {
		m.removedcharacter = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.character, ids[i])
		m.removedcharacter[ids[i]] = struct{}{}
	}
}

// RemovedCharacter returns the removed IDs of the "character" edge to the Character entity.
func (m *ProficiencyMutation) RemovedCharacterIDs() (ids []int) {
	for id := range m.removedcharacter {
		ids = append(ids, id)
	}
	return
}

// CharacterIDs returns the "character" edge IDs in the mutation.
func (m *ProficiencyMutation) CharacterIDs() (ids []int) {
	for id := range m.character {
		ids = append(ids, id)
	}
	return
}

// ResetCharacter resets all changes to the "character" edge.
func (m *ProficiencyMutation) ResetCharacter() {
	m.character = nil
	m.clearedcharacter = false
	m.removedcharacter = nil
}

// Where appends a list predicates to the ProficiencyMutation builder.
func (m *ProficiencyMutation) Where(ps ...predicate.Proficiency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProficiencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProficiencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Proficiency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProficiencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProficiencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Proficiency).
func (m *ProficiencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProficiencyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, proficiency.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, proficiency.FieldName)
	}
	if m.reference != nil {
		fields = append(fields, proficiency.FieldReference)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProficiencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proficiency.FieldIndx:
		return m.Indx()
	case proficiency.FieldName:
		return m.Name()
	case proficiency.FieldReference:
		return m.Reference()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProficiencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proficiency.FieldIndx:
		return m.OldIndx(ctx)
	case proficiency.FieldName:
		return m.OldName(ctx)
	case proficiency.FieldReference:
		return m.OldReference(ctx)
	}
	return nil, fmt.Errorf("unknown Proficiency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProficiencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proficiency.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case proficiency.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case proficiency.FieldReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReference(v)
		return nil
	}
	return fmt.Errorf("unknown Proficiency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProficiencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProficiencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProficiencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Proficiency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProficiencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProficiencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProficiencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Proficiency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProficiencyMutation) ResetField(name string) error {
	switch name {
	case proficiency.FieldIndx:
		m.ResetIndx()
		return nil
	case proficiency.FieldName:
		m.ResetName()
		return nil
	case proficiency.FieldReference:
		m.ResetReference()
		return nil
	}
	return fmt.Errorf("unknown Proficiency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProficiencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.race != nil {
		edges = append(edges, proficiency.EdgeRace)
	}
	if m.options != nil {
		edges = append(edges, proficiency.EdgeOptions)
	}
	if m.class != nil {
		edges = append(edges, proficiency.EdgeClass)
	}
	if m.character != nil {
		edges = append(edges, proficiency.EdgeCharacter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProficiencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proficiency.EdgeRace:
		ids := make([]ent.Value, 0, len(m.race))
		for id := range m.race {
			ids = append(ids, id)
		}
		return ids
	case proficiency.EdgeOptions:
		ids := make([]ent.Value, 0, len(m.options))
		for id := range m.options {
			ids = append(ids, id)
		}
		return ids
	case proficiency.EdgeClass:
		ids := make([]ent.Value, 0, len(m.class))
		for id := range m.class {
			ids = append(ids, id)
		}
		return ids
	case proficiency.EdgeCharacter:
		ids := make([]ent.Value, 0, len(m.character))
		for id := range m.character {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProficiencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedrace != nil {
		edges = append(edges, proficiency.EdgeRace)
	}
	if m.removedoptions != nil {
		edges = append(edges, proficiency.EdgeOptions)
	}
	if m.removedclass != nil {
		edges = append(edges, proficiency.EdgeClass)
	}
	if m.removedcharacter != nil {
		edges = append(edges, proficiency.EdgeCharacter)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProficiencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case proficiency.EdgeRace:
		ids := make([]ent.Value, 0, len(m.removedrace))
		for id := range m.removedrace {
			ids = append(ids, id)
		}
		return ids
	case proficiency.EdgeOptions:
		ids := make([]ent.Value, 0, len(m.removedoptions))
		for id := range m.removedoptions {
			ids = append(ids, id)
		}
		return ids
	case proficiency.EdgeClass:
		ids := make([]ent.Value, 0, len(m.removedclass))
		for id := range m.removedclass {
			ids = append(ids, id)
		}
		return ids
	case proficiency.EdgeCharacter:
		ids := make([]ent.Value, 0, len(m.removedcharacter))
		for id := range m.removedcharacter {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProficiencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedrace {
		edges = append(edges, proficiency.EdgeRace)
	}
	if m.clearedoptions {
		edges = append(edges, proficiency.EdgeOptions)
	}
	if m.clearedclass {
		edges = append(edges, proficiency.EdgeClass)
	}
	if m.clearedcharacter {
		edges = append(edges, proficiency.EdgeCharacter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProficiencyMutation) EdgeCleared(name string) bool {
	switch name {
	case proficiency.EdgeRace:
		return m.clearedrace
	case proficiency.EdgeOptions:
		return m.clearedoptions
	case proficiency.EdgeClass:
		return m.clearedclass
	case proficiency.EdgeCharacter:
		return m.clearedcharacter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProficiencyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Proficiency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProficiencyMutation) ResetEdge(name string) error {
	switch name {
	case proficiency.EdgeRace:
		m.ResetRace()
		return nil
	case proficiency.EdgeOptions:
		m.ResetOptions()
		return nil
	case proficiency.EdgeClass:
		m.ResetClass()
		return nil
	case proficiency.EdgeCharacter:
		m.ResetCharacter()
		return nil
	}
	return fmt.Errorf("unknown Proficiency edge %s", name)
}

// ProficiencyChoiceMutation represents an operation that mutates the ProficiencyChoice nodes in the graph.
type ProficiencyChoiceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	choose               *int
	addchoose            *int
	desc                 *[]string
	appenddesc           []string
	clearedFields        map[string]struct{}
	proficiencies        map[int]struct{}
	removedproficiencies map[int]struct{}
	clearedproficiencies bool
	race                 *int
	clearedrace          bool
	class                *int
	clearedclass         bool
	done                 bool
	oldValue             func(context.Context) (*ProficiencyChoice, error)
	predicates           []predicate.ProficiencyChoice
}

var _ ent.Mutation = (*ProficiencyChoiceMutation)(nil)

// proficiencychoiceOption allows management of the mutation configuration using functional options.
type proficiencychoiceOption func(*ProficiencyChoiceMutation)

// newProficiencyChoiceMutation creates new mutation for the ProficiencyChoice entity.
func newProficiencyChoiceMutation(c config, op Op, opts ...proficiencychoiceOption) *ProficiencyChoiceMutation {
	m := &ProficiencyChoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeProficiencyChoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProficiencyChoiceID sets the ID field of the mutation.
func withProficiencyChoiceID(id int) proficiencychoiceOption {
	return func(m *ProficiencyChoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *ProficiencyChoice
		)
		m.oldValue = func(ctx context.Context) (*ProficiencyChoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProficiencyChoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProficiencyChoice sets the old ProficiencyChoice of the mutation.
func withProficiencyChoice(node *ProficiencyChoice) proficiencychoiceOption {
	return func(m *ProficiencyChoiceMutation) {
		m.oldValue = func(context.Context) (*ProficiencyChoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProficiencyChoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProficiencyChoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProficiencyChoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProficiencyChoiceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProficiencyChoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChoose sets the "choose" field.
func (m *ProficiencyChoiceMutation) SetChoose(i int) {
	m.choose = &i
	m.addchoose = nil
}

// Choose returns the value of the "choose" field in the mutation.
func (m *ProficiencyChoiceMutation) Choose() (r int, exists bool) {
	v := m.choose
	if v == nil {
		return
	}
	return *v, true
}

// OldChoose returns the old "choose" field's value of the ProficiencyChoice entity.
// If the ProficiencyChoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProficiencyChoiceMutation) OldChoose(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChoose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChoose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChoose: %w", err)
	}
	return oldValue.Choose, nil
}

// AddChoose adds i to the "choose" field.
func (m *ProficiencyChoiceMutation) AddChoose(i int) {
	if m.addchoose != nil {
		*m.addchoose += i
	} else {
		m.addchoose = &i
	}
}

// AddedChoose returns the value that was added to the "choose" field in this mutation.
func (m *ProficiencyChoiceMutation) AddedChoose() (r int, exists bool) {
	v := m.addchoose
	if v == nil {
		return
	}
	return *v, true
}

// ResetChoose resets all changes to the "choose" field.
func (m *ProficiencyChoiceMutation) ResetChoose() {
	m.choose = nil
	m.addchoose = nil
}

// SetDesc sets the "desc" field.
func (m *ProficiencyChoiceMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *ProficiencyChoiceMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the ProficiencyChoice entity.
// If the ProficiencyChoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProficiencyChoiceMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *ProficiencyChoiceMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *ProficiencyChoiceMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ResetDesc resets all changes to the "desc" field.
func (m *ProficiencyChoiceMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
}

// AddProficiencyIDs adds the "proficiencies" edge to the Proficiency entity by ids.
func (m *ProficiencyChoiceMutation) AddProficiencyIDs(ids ...int) {
	if m.proficiencies == nil {
		m.proficiencies = make(map[int]struct{})
	}
	for i := range ids {
		m.proficiencies[ids[i]] = struct{}{}
	}
}

// ClearProficiencies clears the "proficiencies" edge to the Proficiency entity.
func (m *ProficiencyChoiceMutation) ClearProficiencies() {
	m.clearedproficiencies = true
}

// ProficienciesCleared reports if the "proficiencies" edge to the Proficiency entity was cleared.
func (m *ProficiencyChoiceMutation) ProficienciesCleared() bool {
	return m.clearedproficiencies
}

// RemoveProficiencyIDs removes the "proficiencies" edge to the Proficiency entity by IDs.
func (m *ProficiencyChoiceMutation) RemoveProficiencyIDs(ids ...int) {
	if m.removedproficiencies == nil {
		m.removedproficiencies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.proficiencies, ids[i])
		m.removedproficiencies[ids[i]] = struct{}{}
	}
}

// RemovedProficiencies returns the removed IDs of the "proficiencies" edge to the Proficiency entity.
func (m *ProficiencyChoiceMutation) RemovedProficienciesIDs() (ids []int) {
	for id := range m.removedproficiencies {
		ids = append(ids, id)
	}
	return
}

// ProficienciesIDs returns the "proficiencies" edge IDs in the mutation.
func (m *ProficiencyChoiceMutation) ProficienciesIDs() (ids []int) {
	for id := range m.proficiencies {
		ids = append(ids, id)
	}
	return
}

// ResetProficiencies resets all changes to the "proficiencies" edge.
func (m *ProficiencyChoiceMutation) ResetProficiencies() {
	m.proficiencies = nil
	m.clearedproficiencies = false
	m.removedproficiencies = nil
}

// SetRaceID sets the "race" edge to the Race entity by id.
func (m *ProficiencyChoiceMutation) SetRaceID(id int) {
	m.race = &id
}

// ClearRace clears the "race" edge to the Race entity.
func (m *ProficiencyChoiceMutation) ClearRace() {
	m.clearedrace = true
}

// RaceCleared reports if the "race" edge to the Race entity was cleared.
func (m *ProficiencyChoiceMutation) RaceCleared() bool {
	return m.clearedrace
}

// RaceID returns the "race" edge ID in the mutation.
func (m *ProficiencyChoiceMutation) RaceID() (id int, exists bool) {
	if m.race != nil {
		return *m.race, true
	}
	return
}

// RaceIDs returns the "race" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RaceID instead. It exists only for internal usage by the builders.
func (m *ProficiencyChoiceMutation) RaceIDs() (ids []int) {
	if id := m.race; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRace resets all changes to the "race" edge.
func (m *ProficiencyChoiceMutation) ResetRace() {
	m.race = nil
	m.clearedrace = false
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *ProficiencyChoiceMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *ProficiencyChoiceMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *ProficiencyChoiceMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *ProficiencyChoiceMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *ProficiencyChoiceMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ProficiencyChoiceMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the ProficiencyChoiceMutation builder.
func (m *ProficiencyChoiceMutation) Where(ps ...predicate.ProficiencyChoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProficiencyChoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProficiencyChoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProficiencyChoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProficiencyChoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProficiencyChoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProficiencyChoice).
func (m *ProficiencyChoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProficiencyChoiceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.choose != nil {
		fields = append(fields, proficiencychoice.FieldChoose)
	}
	if m.desc != nil {
		fields = append(fields, proficiencychoice.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProficiencyChoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proficiencychoice.FieldChoose:
		return m.Choose()
	case proficiencychoice.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProficiencyChoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proficiencychoice.FieldChoose:
		return m.OldChoose(ctx)
	case proficiencychoice.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown ProficiencyChoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProficiencyChoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proficiencychoice.FieldChoose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChoose(v)
		return nil
	case proficiencychoice.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown ProficiencyChoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProficiencyChoiceMutation) AddedFields() []string {
	var fields []string
	if m.addchoose != nil {
		fields = append(fields, proficiencychoice.FieldChoose)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProficiencyChoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case proficiencychoice.FieldChoose:
		return m.AddedChoose()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProficiencyChoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case proficiencychoice.FieldChoose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChoose(v)
		return nil
	}
	return fmt.Errorf("unknown ProficiencyChoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProficiencyChoiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProficiencyChoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProficiencyChoiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProficiencyChoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProficiencyChoiceMutation) ResetField(name string) error {
	switch name {
	case proficiencychoice.FieldChoose:
		m.ResetChoose()
		return nil
	case proficiencychoice.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown ProficiencyChoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProficiencyChoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.proficiencies != nil {
		edges = append(edges, proficiencychoice.EdgeProficiencies)
	}
	if m.race != nil {
		edges = append(edges, proficiencychoice.EdgeRace)
	}
	if m.class != nil {
		edges = append(edges, proficiencychoice.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProficiencyChoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proficiencychoice.EdgeProficiencies:
		ids := make([]ent.Value, 0, len(m.proficiencies))
		for id := range m.proficiencies {
			ids = append(ids, id)
		}
		return ids
	case proficiencychoice.EdgeRace:
		if id := m.race; id != nil {
			return []ent.Value{*id}
		}
	case proficiencychoice.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProficiencyChoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproficiencies != nil {
		edges = append(edges, proficiencychoice.EdgeProficiencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProficiencyChoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case proficiencychoice.EdgeProficiencies:
		ids := make([]ent.Value, 0, len(m.removedproficiencies))
		for id := range m.removedproficiencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProficiencyChoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproficiencies {
		edges = append(edges, proficiencychoice.EdgeProficiencies)
	}
	if m.clearedrace {
		edges = append(edges, proficiencychoice.EdgeRace)
	}
	if m.clearedclass {
		edges = append(edges, proficiencychoice.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProficiencyChoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case proficiencychoice.EdgeProficiencies:
		return m.clearedproficiencies
	case proficiencychoice.EdgeRace:
		return m.clearedrace
	case proficiencychoice.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProficiencyChoiceMutation) ClearEdge(name string) error {
	switch name {
	case proficiencychoice.EdgeRace:
		m.ClearRace()
		return nil
	case proficiencychoice.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown ProficiencyChoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProficiencyChoiceMutation) ResetEdge(name string) error {
	switch name {
	case proficiencychoice.EdgeProficiencies:
		m.ResetProficiencies()
		return nil
	case proficiencychoice.EdgeRace:
		m.ResetRace()
		return nil
	case proficiencychoice.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown ProficiencyChoice edge %s", name)
}

// PropertyMutation represents an operation that mutates the Property nodes in the graph.
type PropertyMutation struct {
	config
	op             Op
	typ            string
	id             *int
	indx           *string
	name           *string
	desc           *[]string
	appenddesc     []string
	clearedFields  map[string]struct{}
	weapons        map[int]struct{}
	removedweapons map[int]struct{}
	clearedweapons bool
	done           bool
	oldValue       func(context.Context) (*Property, error)
	predicates     []predicate.Property
}

var _ ent.Mutation = (*PropertyMutation)(nil)

// propertyOption allows management of the mutation configuration using functional options.
type propertyOption func(*PropertyMutation)

// newPropertyMutation creates new mutation for the Property entity.
func newPropertyMutation(c config, op Op, opts ...propertyOption) *PropertyMutation {
	m := &PropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyID sets the ID field of the mutation.
func withPropertyID(id int) propertyOption {
	return func(m *PropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *Property
		)
		m.oldValue = func(ctx context.Context) (*Property, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Property.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProperty sets the old Property of the mutation.
func withProperty(node *Property) propertyOption {
	return func(m *PropertyMutation) {
		m.oldValue = func(context.Context) (*Property, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Property.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *PropertyMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *PropertyMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *PropertyMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *PropertyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PropertyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PropertyMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *PropertyMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *PropertyMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *PropertyMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *PropertyMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *PropertyMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[property.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *PropertyMutation) DescCleared() bool {
	_, ok := m.clearedFields[property.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *PropertyMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, property.FieldDesc)
}

// AddWeaponIDs adds the "weapons" edge to the Weapon entity by ids.
func (m *PropertyMutation) AddWeaponIDs(ids ...int) {
	if m.weapons == nil {
		m.weapons = make(map[int]struct{})
	}
	for i := range ids {
		m.weapons[ids[i]] = struct{}{}
	}
}

// ClearWeapons clears the "weapons" edge to the Weapon entity.
func (m *PropertyMutation) ClearWeapons() {
	m.clearedweapons = true
}

// WeaponsCleared reports if the "weapons" edge to the Weapon entity was cleared.
func (m *PropertyMutation) WeaponsCleared() bool {
	return m.clearedweapons
}

// RemoveWeaponIDs removes the "weapons" edge to the Weapon entity by IDs.
func (m *PropertyMutation) RemoveWeaponIDs(ids ...int) {
	if m.removedweapons == nil {
		m.removedweapons = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.weapons, ids[i])
		m.removedweapons[ids[i]] = struct{}{}
	}
}

// RemovedWeapons returns the removed IDs of the "weapons" edge to the Weapon entity.
func (m *PropertyMutation) RemovedWeaponsIDs() (ids []int) {
	for id := range m.removedweapons {
		ids = append(ids, id)
	}
	return
}

// WeaponsIDs returns the "weapons" edge IDs in the mutation.
func (m *PropertyMutation) WeaponsIDs() (ids []int) {
	for id := range m.weapons {
		ids = append(ids, id)
	}
	return
}

// ResetWeapons resets all changes to the "weapons" edge.
func (m *PropertyMutation) ResetWeapons() {
	m.weapons = nil
	m.clearedweapons = false
	m.removedweapons = nil
}

// Where appends a list predicates to the PropertyMutation builder.
func (m *PropertyMutation) Where(ps ...predicate.Property) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Property, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Property).
func (m *PropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, property.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, property.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, property.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case property.FieldIndx:
		return m.Indx()
	case property.FieldName:
		return m.Name()
	case property.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case property.FieldIndx:
		return m.OldIndx(ctx)
	case property.FieldName:
		return m.OldName(ctx)
	case property.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Property field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case property.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case property.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case property.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Property numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(property.FieldDesc) {
		fields = append(fields, property.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyMutation) ClearField(name string) error {
	switch name {
	case property.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Property nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertyMutation) ResetField(name string) error {
	switch name {
	case property.FieldIndx:
		m.ResetIndx()
		return nil
	case property.FieldName:
		m.ResetName()
		return nil
	case property.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.weapons != nil {
		edges = append(edges, property.EdgeWeapons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeWeapons:
		ids := make([]ent.Value, 0, len(m.weapons))
		for id := range m.weapons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedweapons != nil {
		edges = append(edges, property.EdgeWeapons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeWeapons:
		ids := make([]ent.Value, 0, len(m.removedweapons))
		for id := range m.removedweapons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedweapons {
		edges = append(edges, property.EdgeWeapons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case property.EdgeWeapons:
		return m.clearedweapons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Property unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertyMutation) ResetEdge(name string) error {
	switch name {
	case property.EdgeWeapons:
		m.ResetWeapons()
		return nil
	}
	return fmt.Errorf("unknown Property edge %s", name)
}

// RaceMutation represents an operation that mutates the Race nodes in the graph.
type RaceMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	indx                                *string
	name                                *string
	speed                               *int
	addspeed                            *int
	size                                *race.Size
	size_desc                           *string
	alignment_desc                      *string
	age_desc                            *string
	language_desc                       *string
	clearedFields                       map[string]struct{}
	traits                              map[int]struct{}
	removedtraits                       map[int]struct{}
	clearedtraits                       bool
	starting_proficiencies              map[int]struct{}
	removedstarting_proficiencies       map[int]struct{}
	clearedstarting_proficiencies       bool
	starting_proficiency_options        *int
	clearedstarting_proficiency_options bool
	ability_bonuses                     map[int]struct{}
	removedability_bonuses              map[int]struct{}
	clearedability_bonuses              bool
	languages                           map[int]struct{}
	removedlanguages                    map[int]struct{}
	clearedlanguages                    bool
	language_options                    *int
	clearedlanguage_options             bool
	characters                          map[int]struct{}
	removedcharacters                   map[int]struct{}
	clearedcharacters                   bool
	done                                bool
	oldValue                            func(context.Context) (*Race, error)
	predicates                          []predicate.Race
}

var _ ent.Mutation = (*RaceMutation)(nil)

// raceOption allows management of the mutation configuration using functional options.
type raceOption func(*RaceMutation)

// newRaceMutation creates new mutation for the Race entity.
func newRaceMutation(c config, op Op, opts ...raceOption) *RaceMutation {
	m := &RaceMutation{
		config:        c,
		op:            op,
		typ:           TypeRace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRaceID sets the ID field of the mutation.
func withRaceID(id int) raceOption {
	return func(m *RaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Race
		)
		m.oldValue = func(ctx context.Context) (*Race, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Race.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRace sets the old Race of the mutation.
func withRace(node *Race) raceOption {
	return func(m *RaceMutation) {
		m.oldValue = func(context.Context) (*Race, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RaceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Race.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *RaceMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *RaceMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *RaceMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *RaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RaceMutation) ResetName() {
	m.name = nil
}

// SetSpeed sets the "speed" field.
func (m *RaceMutation) SetSpeed(i int) {
	m.speed = &i
	m.addspeed = nil
}

// Speed returns the value of the "speed" field in the mutation.
func (m *RaceMutation) Speed() (r int, exists bool) {
	v := m.speed
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeed returns the old "speed" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldSpeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeed: %w", err)
	}
	return oldValue.Speed, nil
}

// AddSpeed adds i to the "speed" field.
func (m *RaceMutation) AddSpeed(i int) {
	if m.addspeed != nil {
		*m.addspeed += i
	} else {
		m.addspeed = &i
	}
}

// AddedSpeed returns the value that was added to the "speed" field in this mutation.
func (m *RaceMutation) AddedSpeed() (r int, exists bool) {
	v := m.addspeed
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpeed resets all changes to the "speed" field.
func (m *RaceMutation) ResetSpeed() {
	m.speed = nil
	m.addspeed = nil
}

// SetSize sets the "size" field.
func (m *RaceMutation) SetSize(r race.Size) {
	m.size = &r
}

// Size returns the value of the "size" field in the mutation.
func (m *RaceMutation) Size() (r race.Size, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldSize(ctx context.Context) (v race.Size, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *RaceMutation) ResetSize() {
	m.size = nil
}

// SetSizeDesc sets the "size_desc" field.
func (m *RaceMutation) SetSizeDesc(s string) {
	m.size_desc = &s
}

// SizeDesc returns the value of the "size_desc" field in the mutation.
func (m *RaceMutation) SizeDesc() (r string, exists bool) {
	v := m.size_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeDesc returns the old "size_desc" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldSizeDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeDesc: %w", err)
	}
	return oldValue.SizeDesc, nil
}

// ResetSizeDesc resets all changes to the "size_desc" field.
func (m *RaceMutation) ResetSizeDesc() {
	m.size_desc = nil
}

// SetAlignmentDesc sets the "alignment_desc" field.
func (m *RaceMutation) SetAlignmentDesc(s string) {
	m.alignment_desc = &s
}

// AlignmentDesc returns the value of the "alignment_desc" field in the mutation.
func (m *RaceMutation) AlignmentDesc() (r string, exists bool) {
	v := m.alignment_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldAlignmentDesc returns the old "alignment_desc" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldAlignmentDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlignmentDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlignmentDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlignmentDesc: %w", err)
	}
	return oldValue.AlignmentDesc, nil
}

// ResetAlignmentDesc resets all changes to the "alignment_desc" field.
func (m *RaceMutation) ResetAlignmentDesc() {
	m.alignment_desc = nil
}

// SetAgeDesc sets the "age_desc" field.
func (m *RaceMutation) SetAgeDesc(s string) {
	m.age_desc = &s
}

// AgeDesc returns the value of the "age_desc" field in the mutation.
func (m *RaceMutation) AgeDesc() (r string, exists bool) {
	v := m.age_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldAgeDesc returns the old "age_desc" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldAgeDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgeDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgeDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgeDesc: %w", err)
	}
	return oldValue.AgeDesc, nil
}

// ResetAgeDesc resets all changes to the "age_desc" field.
func (m *RaceMutation) ResetAgeDesc() {
	m.age_desc = nil
}

// SetLanguageDesc sets the "language_desc" field.
func (m *RaceMutation) SetLanguageDesc(s string) {
	m.language_desc = &s
}

// LanguageDesc returns the value of the "language_desc" field in the mutation.
func (m *RaceMutation) LanguageDesc() (r string, exists bool) {
	v := m.language_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageDesc returns the old "language_desc" field's value of the Race entity.
// If the Race object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RaceMutation) OldLanguageDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageDesc: %w", err)
	}
	return oldValue.LanguageDesc, nil
}

// ResetLanguageDesc resets all changes to the "language_desc" field.
func (m *RaceMutation) ResetLanguageDesc() {
	m.language_desc = nil
}

// AddTraitIDs adds the "traits" edge to the Trait entity by ids.
func (m *RaceMutation) AddTraitIDs(ids ...int) {
	if m.traits == nil {
		m.traits = make(map[int]struct{})
	}
	for i := range ids {
		m.traits[ids[i]] = struct{}{}
	}
}

// ClearTraits clears the "traits" edge to the Trait entity.
func (m *RaceMutation) ClearTraits() {
	m.clearedtraits = true
}

// TraitsCleared reports if the "traits" edge to the Trait entity was cleared.
func (m *RaceMutation) TraitsCleared() bool {
	return m.clearedtraits
}

// RemoveTraitIDs removes the "traits" edge to the Trait entity by IDs.
func (m *RaceMutation) RemoveTraitIDs(ids ...int) {
	if m.removedtraits == nil {
		m.removedtraits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.traits, ids[i])
		m.removedtraits[ids[i]] = struct{}{}
	}
}

// RemovedTraits returns the removed IDs of the "traits" edge to the Trait entity.
func (m *RaceMutation) RemovedTraitsIDs() (ids []int) {
	for id := range m.removedtraits {
		ids = append(ids, id)
	}
	return
}

// TraitsIDs returns the "traits" edge IDs in the mutation.
func (m *RaceMutation) TraitsIDs() (ids []int) {
	for id := range m.traits {
		ids = append(ids, id)
	}
	return
}

// ResetTraits resets all changes to the "traits" edge.
func (m *RaceMutation) ResetTraits() {
	m.traits = nil
	m.clearedtraits = false
	m.removedtraits = nil
}

// AddStartingProficiencyIDs adds the "starting_proficiencies" edge to the Proficiency entity by ids.
func (m *RaceMutation) AddStartingProficiencyIDs(ids ...int) {
	if m.starting_proficiencies == nil {
		m.starting_proficiencies = make(map[int]struct{})
	}
	for i := range ids {
		m.starting_proficiencies[ids[i]] = struct{}{}
	}
}

// ClearStartingProficiencies clears the "starting_proficiencies" edge to the Proficiency entity.
func (m *RaceMutation) ClearStartingProficiencies() {
	m.clearedstarting_proficiencies = true
}

// StartingProficienciesCleared reports if the "starting_proficiencies" edge to the Proficiency entity was cleared.
func (m *RaceMutation) StartingProficienciesCleared() bool {
	return m.clearedstarting_proficiencies
}

// RemoveStartingProficiencyIDs removes the "starting_proficiencies" edge to the Proficiency entity by IDs.
func (m *RaceMutation) RemoveStartingProficiencyIDs(ids ...int) {
	if m.removedstarting_proficiencies == nil {
		m.removedstarting_proficiencies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.starting_proficiencies, ids[i])
		m.removedstarting_proficiencies[ids[i]] = struct{}{}
	}
}

// RemovedStartingProficiencies returns the removed IDs of the "starting_proficiencies" edge to the Proficiency entity.
func (m *RaceMutation) RemovedStartingProficienciesIDs() (ids []int) {
	for id := range m.removedstarting_proficiencies {
		ids = append(ids, id)
	}
	return
}

// StartingProficienciesIDs returns the "starting_proficiencies" edge IDs in the mutation.
func (m *RaceMutation) StartingProficienciesIDs() (ids []int) {
	for id := range m.starting_proficiencies {
		ids = append(ids, id)
	}
	return
}

// ResetStartingProficiencies resets all changes to the "starting_proficiencies" edge.
func (m *RaceMutation) ResetStartingProficiencies() {
	m.starting_proficiencies = nil
	m.clearedstarting_proficiencies = false
	m.removedstarting_proficiencies = nil
}

// SetStartingProficiencyOptionsID sets the "starting_proficiency_options" edge to the ProficiencyChoice entity by id.
func (m *RaceMutation) SetStartingProficiencyOptionsID(id int) {
	m.starting_proficiency_options = &id
}

// ClearStartingProficiencyOptions clears the "starting_proficiency_options" edge to the ProficiencyChoice entity.
func (m *RaceMutation) ClearStartingProficiencyOptions() {
	m.clearedstarting_proficiency_options = true
}

// StartingProficiencyOptionsCleared reports if the "starting_proficiency_options" edge to the ProficiencyChoice entity was cleared.
func (m *RaceMutation) StartingProficiencyOptionsCleared() bool {
	return m.clearedstarting_proficiency_options
}

// StartingProficiencyOptionsID returns the "starting_proficiency_options" edge ID in the mutation.
func (m *RaceMutation) StartingProficiencyOptionsID() (id int, exists bool) {
	if m.starting_proficiency_options != nil {
		return *m.starting_proficiency_options, true
	}
	return
}

// StartingProficiencyOptionsIDs returns the "starting_proficiency_options" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StartingProficiencyOptionsID instead. It exists only for internal usage by the builders.
func (m *RaceMutation) StartingProficiencyOptionsIDs() (ids []int) {
	if id := m.starting_proficiency_options; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStartingProficiencyOptions resets all changes to the "starting_proficiency_options" edge.
func (m *RaceMutation) ResetStartingProficiencyOptions() {
	m.starting_proficiency_options = nil
	m.clearedstarting_proficiency_options = false
}

// AddAbilityBonuseIDs adds the "ability_bonuses" edge to the AbilityScore entity by ids.
func (m *RaceMutation) AddAbilityBonuseIDs(ids ...int) {
	if m.ability_bonuses == nil {
		m.ability_bonuses = make(map[int]struct{})
	}
	for i := range ids {
		m.ability_bonuses[ids[i]] = struct{}{}
	}
}

// ClearAbilityBonuses clears the "ability_bonuses" edge to the AbilityScore entity.
func (m *RaceMutation) ClearAbilityBonuses() {
	m.clearedability_bonuses = true
}

// AbilityBonusesCleared reports if the "ability_bonuses" edge to the AbilityScore entity was cleared.
func (m *RaceMutation) AbilityBonusesCleared() bool {
	return m.clearedability_bonuses
}

// RemoveAbilityBonuseIDs removes the "ability_bonuses" edge to the AbilityScore entity by IDs.
func (m *RaceMutation) RemoveAbilityBonuseIDs(ids ...int) {
	if m.removedability_bonuses == nil {
		m.removedability_bonuses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ability_bonuses, ids[i])
		m.removedability_bonuses[ids[i]] = struct{}{}
	}
}

// RemovedAbilityBonuses returns the removed IDs of the "ability_bonuses" edge to the AbilityScore entity.
func (m *RaceMutation) RemovedAbilityBonusesIDs() (ids []int) {
	for id := range m.removedability_bonuses {
		ids = append(ids, id)
	}
	return
}

// AbilityBonusesIDs returns the "ability_bonuses" edge IDs in the mutation.
func (m *RaceMutation) AbilityBonusesIDs() (ids []int) {
	for id := range m.ability_bonuses {
		ids = append(ids, id)
	}
	return
}

// ResetAbilityBonuses resets all changes to the "ability_bonuses" edge.
func (m *RaceMutation) ResetAbilityBonuses() {
	m.ability_bonuses = nil
	m.clearedability_bonuses = false
	m.removedability_bonuses = nil
}

// AddLanguageIDs adds the "languages" edge to the Language entity by ids.
func (m *RaceMutation) AddLanguageIDs(ids ...int) {
	if m.languages == nil {
		m.languages = make(map[int]struct{})
	}
	for i := range ids {
		m.languages[ids[i]] = struct{}{}
	}
}

// ClearLanguages clears the "languages" edge to the Language entity.
func (m *RaceMutation) ClearLanguages() {
	m.clearedlanguages = true
}

// LanguagesCleared reports if the "languages" edge to the Language entity was cleared.
func (m *RaceMutation) LanguagesCleared() bool {
	return m.clearedlanguages
}

// RemoveLanguageIDs removes the "languages" edge to the Language entity by IDs.
func (m *RaceMutation) RemoveLanguageIDs(ids ...int) {
	if m.removedlanguages == nil {
		m.removedlanguages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.languages, ids[i])
		m.removedlanguages[ids[i]] = struct{}{}
	}
}

// RemovedLanguages returns the removed IDs of the "languages" edge to the Language entity.
func (m *RaceMutation) RemovedLanguagesIDs() (ids []int) {
	for id := range m.removedlanguages {
		ids = append(ids, id)
	}
	return
}

// LanguagesIDs returns the "languages" edge IDs in the mutation.
func (m *RaceMutation) LanguagesIDs() (ids []int) {
	for id := range m.languages {
		ids = append(ids, id)
	}
	return
}

// ResetLanguages resets all changes to the "languages" edge.
func (m *RaceMutation) ResetLanguages() {
	m.languages = nil
	m.clearedlanguages = false
	m.removedlanguages = nil
}

// SetLanguageOptionsID sets the "language_options" edge to the LanguageChoice entity by id.
func (m *RaceMutation) SetLanguageOptionsID(id int) {
	m.language_options = &id
}

// ClearLanguageOptions clears the "language_options" edge to the LanguageChoice entity.
func (m *RaceMutation) ClearLanguageOptions() {
	m.clearedlanguage_options = true
}

// LanguageOptionsCleared reports if the "language_options" edge to the LanguageChoice entity was cleared.
func (m *RaceMutation) LanguageOptionsCleared() bool {
	return m.clearedlanguage_options
}

// LanguageOptionsID returns the "language_options" edge ID in the mutation.
func (m *RaceMutation) LanguageOptionsID() (id int, exists bool) {
	if m.language_options != nil {
		return *m.language_options, true
	}
	return
}

// LanguageOptionsIDs returns the "language_options" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageOptionsID instead. It exists only for internal usage by the builders.
func (m *RaceMutation) LanguageOptionsIDs() (ids []int) {
	if id := m.language_options; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguageOptions resets all changes to the "language_options" edge.
func (m *RaceMutation) ResetLanguageOptions() {
	m.language_options = nil
	m.clearedlanguage_options = false
}

// AddCharacterIDs adds the "characters" edge to the Character entity by ids.
func (m *RaceMutation) AddCharacterIDs(ids ...int) {
	if m.characters == nil {
		m.characters = make(map[int]struct{})
	}
	for i := range ids {
		m.characters[ids[i]] = struct{}{}
	}
}

// ClearCharacters clears the "characters" edge to the Character entity.
func (m *RaceMutation) ClearCharacters() {
	m.clearedcharacters = true
}

// CharactersCleared reports if the "characters" edge to the Character entity was cleared.
func (m *RaceMutation) CharactersCleared() bool {
	return m.clearedcharacters
}

// RemoveCharacterIDs removes the "characters" edge to the Character entity by IDs.
func (m *RaceMutation) RemoveCharacterIDs(ids ...int) {
	if m.removedcharacters == nil {
		m.removedcharacters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.characters, ids[i])
		m.removedcharacters[ids[i]] = struct{}{}
	}
}

// RemovedCharacters returns the removed IDs of the "characters" edge to the Character entity.
func (m *RaceMutation) RemovedCharactersIDs() (ids []int) {
	for id := range m.removedcharacters {
		ids = append(ids, id)
	}
	return
}

// CharactersIDs returns the "characters" edge IDs in the mutation.
func (m *RaceMutation) CharactersIDs() (ids []int) {
	for id := range m.characters {
		ids = append(ids, id)
	}
	return
}

// ResetCharacters resets all changes to the "characters" edge.
func (m *RaceMutation) ResetCharacters() {
	m.characters = nil
	m.clearedcharacters = false
	m.removedcharacters = nil
}

// Where appends a list predicates to the RaceMutation builder.
func (m *RaceMutation) Where(ps ...predicate.Race) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Race, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Race).
func (m *RaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RaceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.indx != nil {
		fields = append(fields, race.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, race.FieldName)
	}
	if m.speed != nil {
		fields = append(fields, race.FieldSpeed)
	}
	if m.size != nil {
		fields = append(fields, race.FieldSize)
	}
	if m.size_desc != nil {
		fields = append(fields, race.FieldSizeDesc)
	}
	if m.alignment_desc != nil {
		fields = append(fields, race.FieldAlignmentDesc)
	}
	if m.age_desc != nil {
		fields = append(fields, race.FieldAgeDesc)
	}
	if m.language_desc != nil {
		fields = append(fields, race.FieldLanguageDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case race.FieldIndx:
		return m.Indx()
	case race.FieldName:
		return m.Name()
	case race.FieldSpeed:
		return m.Speed()
	case race.FieldSize:
		return m.Size()
	case race.FieldSizeDesc:
		return m.SizeDesc()
	case race.FieldAlignmentDesc:
		return m.AlignmentDesc()
	case race.FieldAgeDesc:
		return m.AgeDesc()
	case race.FieldLanguageDesc:
		return m.LanguageDesc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case race.FieldIndx:
		return m.OldIndx(ctx)
	case race.FieldName:
		return m.OldName(ctx)
	case race.FieldSpeed:
		return m.OldSpeed(ctx)
	case race.FieldSize:
		return m.OldSize(ctx)
	case race.FieldSizeDesc:
		return m.OldSizeDesc(ctx)
	case race.FieldAlignmentDesc:
		return m.OldAlignmentDesc(ctx)
	case race.FieldAgeDesc:
		return m.OldAgeDesc(ctx)
	case race.FieldLanguageDesc:
		return m.OldLanguageDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Race field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case race.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case race.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case race.FieldSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeed(v)
		return nil
	case race.FieldSize:
		v, ok := value.(race.Size)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case race.FieldSizeDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeDesc(v)
		return nil
	case race.FieldAlignmentDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlignmentDesc(v)
		return nil
	case race.FieldAgeDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgeDesc(v)
		return nil
	case race.FieldLanguageDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Race field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RaceMutation) AddedFields() []string {
	var fields []string
	if m.addspeed != nil {
		fields = append(fields, race.FieldSpeed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case race.FieldSpeed:
		return m.AddedSpeed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case race.FieldSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown Race numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Race nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RaceMutation) ResetField(name string) error {
	switch name {
	case race.FieldIndx:
		m.ResetIndx()
		return nil
	case race.FieldName:
		m.ResetName()
		return nil
	case race.FieldSpeed:
		m.ResetSpeed()
		return nil
	case race.FieldSize:
		m.ResetSize()
		return nil
	case race.FieldSizeDesc:
		m.ResetSizeDesc()
		return nil
	case race.FieldAlignmentDesc:
		m.ResetAlignmentDesc()
		return nil
	case race.FieldAgeDesc:
		m.ResetAgeDesc()
		return nil
	case race.FieldLanguageDesc:
		m.ResetLanguageDesc()
		return nil
	}
	return fmt.Errorf("unknown Race field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.traits != nil {
		edges = append(edges, race.EdgeTraits)
	}
	if m.starting_proficiencies != nil {
		edges = append(edges, race.EdgeStartingProficiencies)
	}
	if m.starting_proficiency_options != nil {
		edges = append(edges, race.EdgeStartingProficiencyOptions)
	}
	if m.ability_bonuses != nil {
		edges = append(edges, race.EdgeAbilityBonuses)
	}
	if m.languages != nil {
		edges = append(edges, race.EdgeLanguages)
	}
	if m.language_options != nil {
		edges = append(edges, race.EdgeLanguageOptions)
	}
	if m.characters != nil {
		edges = append(edges, race.EdgeCharacters)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case race.EdgeTraits:
		ids := make([]ent.Value, 0, len(m.traits))
		for id := range m.traits {
			ids = append(ids, id)
		}
		return ids
	case race.EdgeStartingProficiencies:
		ids := make([]ent.Value, 0, len(m.starting_proficiencies))
		for id := range m.starting_proficiencies {
			ids = append(ids, id)
		}
		return ids
	case race.EdgeStartingProficiencyOptions:
		if id := m.starting_proficiency_options; id != nil {
			return []ent.Value{*id}
		}
	case race.EdgeAbilityBonuses:
		ids := make([]ent.Value, 0, len(m.ability_bonuses))
		for id := range m.ability_bonuses {
			ids = append(ids, id)
		}
		return ids
	case race.EdgeLanguages:
		ids := make([]ent.Value, 0, len(m.languages))
		for id := range m.languages {
			ids = append(ids, id)
		}
		return ids
	case race.EdgeLanguageOptions:
		if id := m.language_options; id != nil {
			return []ent.Value{*id}
		}
	case race.EdgeCharacters:
		ids := make([]ent.Value, 0, len(m.characters))
		for id := range m.characters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedtraits != nil {
		edges = append(edges, race.EdgeTraits)
	}
	if m.removedstarting_proficiencies != nil {
		edges = append(edges, race.EdgeStartingProficiencies)
	}
	if m.removedability_bonuses != nil {
		edges = append(edges, race.EdgeAbilityBonuses)
	}
	if m.removedlanguages != nil {
		edges = append(edges, race.EdgeLanguages)
	}
	if m.removedcharacters != nil {
		edges = append(edges, race.EdgeCharacters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case race.EdgeTraits:
		ids := make([]ent.Value, 0, len(m.removedtraits))
		for id := range m.removedtraits {
			ids = append(ids, id)
		}
		return ids
	case race.EdgeStartingProficiencies:
		ids := make([]ent.Value, 0, len(m.removedstarting_proficiencies))
		for id := range m.removedstarting_proficiencies {
			ids = append(ids, id)
		}
		return ids
	case race.EdgeAbilityBonuses:
		ids := make([]ent.Value, 0, len(m.removedability_bonuses))
		for id := range m.removedability_bonuses {
			ids = append(ids, id)
		}
		return ids
	case race.EdgeLanguages:
		ids := make([]ent.Value, 0, len(m.removedlanguages))
		for id := range m.removedlanguages {
			ids = append(ids, id)
		}
		return ids
	case race.EdgeCharacters:
		ids := make([]ent.Value, 0, len(m.removedcharacters))
		for id := range m.removedcharacters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedtraits {
		edges = append(edges, race.EdgeTraits)
	}
	if m.clearedstarting_proficiencies {
		edges = append(edges, race.EdgeStartingProficiencies)
	}
	if m.clearedstarting_proficiency_options {
		edges = append(edges, race.EdgeStartingProficiencyOptions)
	}
	if m.clearedability_bonuses {
		edges = append(edges, race.EdgeAbilityBonuses)
	}
	if m.clearedlanguages {
		edges = append(edges, race.EdgeLanguages)
	}
	if m.clearedlanguage_options {
		edges = append(edges, race.EdgeLanguageOptions)
	}
	if m.clearedcharacters {
		edges = append(edges, race.EdgeCharacters)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RaceMutation) EdgeCleared(name string) bool {
	switch name {
	case race.EdgeTraits:
		return m.clearedtraits
	case race.EdgeStartingProficiencies:
		return m.clearedstarting_proficiencies
	case race.EdgeStartingProficiencyOptions:
		return m.clearedstarting_proficiency_options
	case race.EdgeAbilityBonuses:
		return m.clearedability_bonuses
	case race.EdgeLanguages:
		return m.clearedlanguages
	case race.EdgeLanguageOptions:
		return m.clearedlanguage_options
	case race.EdgeCharacters:
		return m.clearedcharacters
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RaceMutation) ClearEdge(name string) error {
	switch name {
	case race.EdgeStartingProficiencyOptions:
		m.ClearStartingProficiencyOptions()
		return nil
	case race.EdgeLanguageOptions:
		m.ClearLanguageOptions()
		return nil
	}
	return fmt.Errorf("unknown Race unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RaceMutation) ResetEdge(name string) error {
	switch name {
	case race.EdgeTraits:
		m.ResetTraits()
		return nil
	case race.EdgeStartingProficiencies:
		m.ResetStartingProficiencies()
		return nil
	case race.EdgeStartingProficiencyOptions:
		m.ResetStartingProficiencyOptions()
		return nil
	case race.EdgeAbilityBonuses:
		m.ResetAbilityBonuses()
		return nil
	case race.EdgeLanguages:
		m.ResetLanguages()
		return nil
	case race.EdgeLanguageOptions:
		m.ResetLanguageOptions()
		return nil
	case race.EdgeCharacters:
		m.ResetCharacters()
		return nil
	}
	return fmt.Errorf("unknown Race edge %s", name)
}

// RuleMutation represents an operation that mutates the Rule nodes in the graph.
type RuleMutation struct {
	config
	op              Op
	typ             string
	id              *int
	indx            *string
	name            *string
	desc            *[]string
	appenddesc      []string
	clearedFields   map[string]struct{}
	sections        map[int]struct{}
	removedsections map[int]struct{}
	clearedsections bool
	done            bool
	oldValue        func(context.Context) (*Rule, error)
	predicates      []predicate.Rule
}

var _ ent.Mutation = (*RuleMutation)(nil)

// ruleOption allows management of the mutation configuration using functional options.
type ruleOption func(*RuleMutation)

// newRuleMutation creates new mutation for the Rule entity.
func newRuleMutation(c config, op Op, opts ...ruleOption) *RuleMutation {
	m := &RuleMutation{
		config:        c,
		op:            op,
		typ:           TypeRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRuleID sets the ID field of the mutation.
func withRuleID(id int) ruleOption {
	return func(m *RuleMutation) {
		var (
			err   error
			once  sync.Once
			value *Rule
		)
		m.oldValue = func(ctx context.Context) (*Rule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRule sets the old Rule of the mutation.
func withRule(node *Rule) ruleOption {
	return func(m *RuleMutation) {
		m.oldValue = func(context.Context) (*Rule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RuleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *RuleMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *RuleMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *RuleMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *RuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RuleMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *RuleMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *RuleMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *RuleMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *RuleMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *RuleMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[rule.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *RuleMutation) DescCleared() bool {
	_, ok := m.clearedFields[rule.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *RuleMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, rule.FieldDesc)
}

// AddSectionIDs adds the "sections" edge to the RuleSection entity by ids.
func (m *RuleMutation) AddSectionIDs(ids ...int) {
	if m.sections == nil {
		m.sections = make(map[int]struct{})
	}
	for i := range ids {
		m.sections[ids[i]] = struct{}{}
	}
}

// ClearSections clears the "sections" edge to the RuleSection entity.
func (m *RuleMutation) ClearSections() {
	m.clearedsections = true
}

// SectionsCleared reports if the "sections" edge to the RuleSection entity was cleared.
func (m *RuleMutation) SectionsCleared() bool {
	return m.clearedsections
}

// RemoveSectionIDs removes the "sections" edge to the RuleSection entity by IDs.
func (m *RuleMutation) RemoveSectionIDs(ids ...int) {
	if m.removedsections == nil {
		m.removedsections = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sections, ids[i])
		m.removedsections[ids[i]] = struct{}{}
	}
}

// RemovedSections returns the removed IDs of the "sections" edge to the RuleSection entity.
func (m *RuleMutation) RemovedSectionsIDs() (ids []int) {
	for id := range m.removedsections {
		ids = append(ids, id)
	}
	return
}

// SectionsIDs returns the "sections" edge IDs in the mutation.
func (m *RuleMutation) SectionsIDs() (ids []int) {
	for id := range m.sections {
		ids = append(ids, id)
	}
	return
}

// ResetSections resets all changes to the "sections" edge.
func (m *RuleMutation) ResetSections() {
	m.sections = nil
	m.clearedsections = false
	m.removedsections = nil
}

// Where appends a list predicates to the RuleMutation builder.
func (m *RuleMutation) Where(ps ...predicate.Rule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Rule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Rule).
func (m *RuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RuleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, rule.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, rule.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, rule.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rule.FieldIndx:
		return m.Indx()
	case rule.FieldName:
		return m.Name()
	case rule.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rule.FieldIndx:
		return m.OldIndx(ctx)
	case rule.FieldName:
		return m.OldName(ctx)
	case rule.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Rule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rule.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case rule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rule.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Rule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Rule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rule.FieldDesc) {
		fields = append(fields, rule.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RuleMutation) ClearField(name string) error {
	switch name {
	case rule.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Rule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RuleMutation) ResetField(name string) error {
	switch name {
	case rule.FieldIndx:
		m.ResetIndx()
		return nil
	case rule.FieldName:
		m.ResetName()
		return nil
	case rule.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Rule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sections != nil {
		edges = append(edges, rule.EdgeSections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rule.EdgeSections:
		ids := make([]ent.Value, 0, len(m.sections))
		for id := range m.sections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsections != nil {
		edges = append(edges, rule.EdgeSections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rule.EdgeSections:
		ids := make([]ent.Value, 0, len(m.removedsections))
		for id := range m.removedsections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsections {
		edges = append(edges, rule.EdgeSections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RuleMutation) EdgeCleared(name string) bool {
	switch name {
	case rule.EdgeSections:
		return m.clearedsections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Rule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RuleMutation) ResetEdge(name string) error {
	switch name {
	case rule.EdgeSections:
		m.ResetSections()
		return nil
	}
	return fmt.Errorf("unknown Rule edge %s", name)
}

// RuleSectionMutation represents an operation that mutates the RuleSection nodes in the graph.
type RuleSectionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	clearedFields map[string]struct{}
	rule          *int
	clearedrule   bool
	done          bool
	oldValue      func(context.Context) (*RuleSection, error)
	predicates    []predicate.RuleSection
}

var _ ent.Mutation = (*RuleSectionMutation)(nil)

// rulesectionOption allows management of the mutation configuration using functional options.
type rulesectionOption func(*RuleSectionMutation)

// newRuleSectionMutation creates new mutation for the RuleSection entity.
func newRuleSectionMutation(c config, op Op, opts ...rulesectionOption) *RuleSectionMutation {
	m := &RuleSectionMutation{
		config:        c,
		op:            op,
		typ:           TypeRuleSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRuleSectionID sets the ID field of the mutation.
func withRuleSectionID(id int) rulesectionOption {
	return func(m *RuleSectionMutation) {
		var (
			err   error
			once  sync.Once
			value *RuleSection
		)
		m.oldValue = func(ctx context.Context) (*RuleSection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RuleSection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRuleSection sets the old RuleSection of the mutation.
func withRuleSection(node *RuleSection) rulesectionOption {
	return func(m *RuleSectionMutation) {
		m.oldValue = func(context.Context) (*RuleSection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RuleSectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RuleSectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RuleSectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RuleSectionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RuleSection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *RuleSectionMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *RuleSectionMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the RuleSection entity.
// If the RuleSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleSectionMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *RuleSectionMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *RuleSectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RuleSectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RuleSection entity.
// If the RuleSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleSectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RuleSectionMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *RuleSectionMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *RuleSectionMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the RuleSection entity.
// If the RuleSection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleSectionMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *RuleSectionMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *RuleSectionMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *RuleSectionMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[rulesection.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *RuleSectionMutation) DescCleared() bool {
	_, ok := m.clearedFields[rulesection.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *RuleSectionMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, rulesection.FieldDesc)
}

// SetRuleID sets the "rule" edge to the Rule entity by id.
func (m *RuleSectionMutation) SetRuleID(id int) {
	m.rule = &id
}

// ClearRule clears the "rule" edge to the Rule entity.
func (m *RuleSectionMutation) ClearRule() {
	m.clearedrule = true
}

// RuleCleared reports if the "rule" edge to the Rule entity was cleared.
func (m *RuleSectionMutation) RuleCleared() bool {
	return m.clearedrule
}

// RuleID returns the "rule" edge ID in the mutation.
func (m *RuleSectionMutation) RuleID() (id int, exists bool) {
	if m.rule != nil {
		return *m.rule, true
	}
	return
}

// RuleIDs returns the "rule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuleID instead. It exists only for internal usage by the builders.
func (m *RuleSectionMutation) RuleIDs() (ids []int) {
	if id := m.rule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRule resets all changes to the "rule" edge.
func (m *RuleSectionMutation) ResetRule() {
	m.rule = nil
	m.clearedrule = false
}

// Where appends a list predicates to the RuleSectionMutation builder.
func (m *RuleSectionMutation) Where(ps ...predicate.RuleSection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RuleSectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RuleSectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RuleSection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RuleSectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RuleSectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RuleSection).
func (m *RuleSectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RuleSectionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, rulesection.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, rulesection.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, rulesection.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RuleSectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rulesection.FieldIndx:
		return m.Indx()
	case rulesection.FieldName:
		return m.Name()
	case rulesection.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RuleSectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rulesection.FieldIndx:
		return m.OldIndx(ctx)
	case rulesection.FieldName:
		return m.OldName(ctx)
	case rulesection.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown RuleSection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleSectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rulesection.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case rulesection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rulesection.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown RuleSection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RuleSectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RuleSectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleSectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RuleSection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RuleSectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rulesection.FieldDesc) {
		fields = append(fields, rulesection.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RuleSectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RuleSectionMutation) ClearField(name string) error {
	switch name {
	case rulesection.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown RuleSection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RuleSectionMutation) ResetField(name string) error {
	switch name {
	case rulesection.FieldIndx:
		m.ResetIndx()
		return nil
	case rulesection.FieldName:
		m.ResetName()
		return nil
	case rulesection.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown RuleSection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RuleSectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rule != nil {
		edges = append(edges, rulesection.EdgeRule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RuleSectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rulesection.EdgeRule:
		if id := m.rule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RuleSectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RuleSectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RuleSectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrule {
		edges = append(edges, rulesection.EdgeRule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RuleSectionMutation) EdgeCleared(name string) bool {
	switch name {
	case rulesection.EdgeRule:
		return m.clearedrule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RuleSectionMutation) ClearEdge(name string) error {
	switch name {
	case rulesection.EdgeRule:
		m.ClearRule()
		return nil
	}
	return fmt.Errorf("unknown RuleSection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RuleSectionMutation) ResetEdge(name string) error {
	switch name {
	case rulesection.EdgeRule:
		m.ResetRule()
		return nil
	}
	return fmt.Errorf("unknown RuleSection edge %s", name)
}

// SkillMutation represents an operation that mutates the Skill nodes in the graph.
type SkillMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	indx                    *string
	name                    *string
	desc                    *[]string
	appenddesc              []string
	clearedFields           map[string]struct{}
	ability_score           *int
	clearedability_score    bool
	characters              map[int]struct{}
	removedcharacters       map[int]struct{}
	clearedcharacters       bool
	character_skills        map[int]struct{}
	removedcharacter_skills map[int]struct{}
	clearedcharacter_skills bool
	done                    bool
	oldValue                func(context.Context) (*Skill, error)
	predicates              []predicate.Skill
}

var _ ent.Mutation = (*SkillMutation)(nil)

// skillOption allows management of the mutation configuration using functional options.
type skillOption func(*SkillMutation)

// newSkillMutation creates new mutation for the Skill entity.
func newSkillMutation(c config, op Op, opts ...skillOption) *SkillMutation {
	m := &SkillMutation{
		config:        c,
		op:            op,
		typ:           TypeSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkillID sets the ID field of the mutation.
func withSkillID(id int) skillOption {
	return func(m *SkillMutation) {
		var (
			err   error
			once  sync.Once
			value *Skill
		)
		m.oldValue = func(ctx context.Context) (*Skill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Skill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkill sets the old Skill of the mutation.
func withSkill(node *Skill) skillOption {
	return func(m *SkillMutation) {
		m.oldValue = func(context.Context) (*Skill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkillMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Skill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *SkillMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *SkillMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *SkillMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *SkillMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SkillMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SkillMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *SkillMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *SkillMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *SkillMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *SkillMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *SkillMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[skill.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *SkillMutation) DescCleared() bool {
	_, ok := m.clearedFields[skill.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *SkillMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, skill.FieldDesc)
}

// SetAbilityScoreID sets the "ability_score" edge to the AbilityScore entity by id.
func (m *SkillMutation) SetAbilityScoreID(id int) {
	m.ability_score = &id
}

// ClearAbilityScore clears the "ability_score" edge to the AbilityScore entity.
func (m *SkillMutation) ClearAbilityScore() {
	m.clearedability_score = true
}

// AbilityScoreCleared reports if the "ability_score" edge to the AbilityScore entity was cleared.
func (m *SkillMutation) AbilityScoreCleared() bool {
	return m.clearedability_score
}

// AbilityScoreID returns the "ability_score" edge ID in the mutation.
func (m *SkillMutation) AbilityScoreID() (id int, exists bool) {
	if m.ability_score != nil {
		return *m.ability_score, true
	}
	return
}

// AbilityScoreIDs returns the "ability_score" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AbilityScoreID instead. It exists only for internal usage by the builders.
func (m *SkillMutation) AbilityScoreIDs() (ids []int) {
	if id := m.ability_score; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAbilityScore resets all changes to the "ability_score" edge.
func (m *SkillMutation) ResetAbilityScore() {
	m.ability_score = nil
	m.clearedability_score = false
}

// AddCharacterIDs adds the "characters" edge to the Character entity by ids.
func (m *SkillMutation) AddCharacterIDs(ids ...int) {
	if m.characters == nil {
		m.characters = make(map[int]struct{})
	}
	for i := range ids {
		m.characters[ids[i]] = struct{}{}
	}
}

// ClearCharacters clears the "characters" edge to the Character entity.
func (m *SkillMutation) ClearCharacters() {
	m.clearedcharacters = true
}

// CharactersCleared reports if the "characters" edge to the Character entity was cleared.
func (m *SkillMutation) CharactersCleared() bool {
	return m.clearedcharacters
}

// RemoveCharacterIDs removes the "characters" edge to the Character entity by IDs.
func (m *SkillMutation) RemoveCharacterIDs(ids ...int) {
	if m.removedcharacters == nil {
		m.removedcharacters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.characters, ids[i])
		m.removedcharacters[ids[i]] = struct{}{}
	}
}

// RemovedCharacters returns the removed IDs of the "characters" edge to the Character entity.
func (m *SkillMutation) RemovedCharactersIDs() (ids []int) {
	for id := range m.removedcharacters {
		ids = append(ids, id)
	}
	return
}

// CharactersIDs returns the "characters" edge IDs in the mutation.
func (m *SkillMutation) CharactersIDs() (ids []int) {
	for id := range m.characters {
		ids = append(ids, id)
	}
	return
}

// ResetCharacters resets all changes to the "characters" edge.
func (m *SkillMutation) ResetCharacters() {
	m.characters = nil
	m.clearedcharacters = false
	m.removedcharacters = nil
}

// AddCharacterSkillIDs adds the "character_skills" edge to the CharacterSkill entity by ids.
func (m *SkillMutation) AddCharacterSkillIDs(ids ...int) {
	if m.character_skills == nil {
		m.character_skills = make(map[int]struct{})
	}
	for i := range ids {
		m.character_skills[ids[i]] = struct{}{}
	}
}

// ClearCharacterSkills clears the "character_skills" edge to the CharacterSkill entity.
func (m *SkillMutation) ClearCharacterSkills() {
	m.clearedcharacter_skills = true
}

// CharacterSkillsCleared reports if the "character_skills" edge to the CharacterSkill entity was cleared.
func (m *SkillMutation) CharacterSkillsCleared() bool {
	return m.clearedcharacter_skills
}

// RemoveCharacterSkillIDs removes the "character_skills" edge to the CharacterSkill entity by IDs.
func (m *SkillMutation) RemoveCharacterSkillIDs(ids ...int) {
	if m.removedcharacter_skills == nil {
		m.removedcharacter_skills = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.character_skills, ids[i])
		m.removedcharacter_skills[ids[i]] = struct{}{}
	}
}

// RemovedCharacterSkills returns the removed IDs of the "character_skills" edge to the CharacterSkill entity.
func (m *SkillMutation) RemovedCharacterSkillsIDs() (ids []int) {
	for id := range m.removedcharacter_skills {
		ids = append(ids, id)
	}
	return
}

// CharacterSkillsIDs returns the "character_skills" edge IDs in the mutation.
func (m *SkillMutation) CharacterSkillsIDs() (ids []int) {
	for id := range m.character_skills {
		ids = append(ids, id)
	}
	return
}

// ResetCharacterSkills resets all changes to the "character_skills" edge.
func (m *SkillMutation) ResetCharacterSkills() {
	m.character_skills = nil
	m.clearedcharacter_skills = false
	m.removedcharacter_skills = nil
}

// Where appends a list predicates to the SkillMutation builder.
func (m *SkillMutation) Where(ps ...predicate.Skill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Skill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Skill).
func (m *SkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkillMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, skill.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, skill.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, skill.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skill.FieldIndx:
		return m.Indx()
	case skill.FieldName:
		return m.Name()
	case skill.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skill.FieldIndx:
		return m.OldIndx(ctx)
	case skill.FieldName:
		return m.OldName(ctx)
	case skill.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Skill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skill.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case skill.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case skill.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Skill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(skill.FieldDesc) {
		fields = append(fields, skill.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkillMutation) ClearField(name string) error {
	switch name {
	case skill.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Skill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkillMutation) ResetField(name string) error {
	switch name {
	case skill.FieldIndx:
		m.ResetIndx()
		return nil
	case skill.FieldName:
		m.ResetName()
		return nil
	case skill.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.ability_score != nil {
		edges = append(edges, skill.EdgeAbilityScore)
	}
	if m.characters != nil {
		edges = append(edges, skill.EdgeCharacters)
	}
	if m.character_skills != nil {
		edges = append(edges, skill.EdgeCharacterSkills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeAbilityScore:
		if id := m.ability_score; id != nil {
			return []ent.Value{*id}
		}
	case skill.EdgeCharacters:
		ids := make([]ent.Value, 0, len(m.characters))
		for id := range m.characters {
			ids = append(ids, id)
		}
		return ids
	case skill.EdgeCharacterSkills:
		ids := make([]ent.Value, 0, len(m.character_skills))
		for id := range m.character_skills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcharacters != nil {
		edges = append(edges, skill.EdgeCharacters)
	}
	if m.removedcharacter_skills != nil {
		edges = append(edges, skill.EdgeCharacterSkills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeCharacters:
		ids := make([]ent.Value, 0, len(m.removedcharacters))
		for id := range m.removedcharacters {
			ids = append(ids, id)
		}
		return ids
	case skill.EdgeCharacterSkills:
		ids := make([]ent.Value, 0, len(m.removedcharacter_skills))
		for id := range m.removedcharacter_skills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedability_score {
		edges = append(edges, skill.EdgeAbilityScore)
	}
	if m.clearedcharacters {
		edges = append(edges, skill.EdgeCharacters)
	}
	if m.clearedcharacter_skills {
		edges = append(edges, skill.EdgeCharacterSkills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkillMutation) EdgeCleared(name string) bool {
	switch name {
	case skill.EdgeAbilityScore:
		return m.clearedability_score
	case skill.EdgeCharacters:
		return m.clearedcharacters
	case skill.EdgeCharacterSkills:
		return m.clearedcharacter_skills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkillMutation) ClearEdge(name string) error {
	switch name {
	case skill.EdgeAbilityScore:
		m.ClearAbilityScore()
		return nil
	}
	return fmt.Errorf("unknown Skill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkillMutation) ResetEdge(name string) error {
	switch name {
	case skill.EdgeAbilityScore:
		m.ResetAbilityScore()
		return nil
	case skill.EdgeCharacters:
		m.ResetCharacters()
		return nil
	case skill.EdgeCharacterSkills:
		m.ResetCharacterSkills()
		return nil
	}
	return fmt.Errorf("unknown Skill edge %s", name)
}

// ToolMutation represents an operation that mutates the Tool nodes in the graph.
type ToolMutation struct {
	config
	op               Op
	typ              string
	id               *int
	tool_category    *string
	desc             *[]string
	appenddesc       []string
	clearedFields    map[string]struct{}
	equipment        *int
	clearedequipment bool
	done             bool
	oldValue         func(context.Context) (*Tool, error)
	predicates       []predicate.Tool
}

var _ ent.Mutation = (*ToolMutation)(nil)

// toolOption allows management of the mutation configuration using functional options.
type toolOption func(*ToolMutation)

// newToolMutation creates new mutation for the Tool entity.
func newToolMutation(c config, op Op, opts ...toolOption) *ToolMutation {
	m := &ToolMutation{
		config:        c,
		op:            op,
		typ:           TypeTool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolID sets the ID field of the mutation.
func withToolID(id int) toolOption {
	return func(m *ToolMutation) {
		var (
			err   error
			once  sync.Once
			value *Tool
		)
		m.oldValue = func(ctx context.Context) (*Tool, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTool sets the old Tool of the mutation.
func withTool(node *Tool) toolOption {
	return func(m *ToolMutation) {
		m.oldValue = func(context.Context) (*Tool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tool.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToolCategory sets the "tool_category" field.
func (m *ToolMutation) SetToolCategory(s string) {
	m.tool_category = &s
}

// ToolCategory returns the value of the "tool_category" field in the mutation.
func (m *ToolMutation) ToolCategory() (r string, exists bool) {
	v := m.tool_category
	if v == nil {
		return
	}
	return *v, true
}

// OldToolCategory returns the old "tool_category" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldToolCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolCategory: %w", err)
	}
	return oldValue.ToolCategory, nil
}

// ResetToolCategory resets all changes to the "tool_category" field.
func (m *ToolMutation) ResetToolCategory() {
	m.tool_category = nil
}

// SetDesc sets the "desc" field.
func (m *ToolMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *ToolMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Tool entity.
// If the Tool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *ToolMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *ToolMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *ToolMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[tool.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *ToolMutation) DescCleared() bool {
	_, ok := m.clearedFields[tool.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *ToolMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, tool.FieldDesc)
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *ToolMutation) SetEquipmentID(id int) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *ToolMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *ToolMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *ToolMutation) EquipmentID() (id int, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *ToolMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *ToolMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// Where appends a list predicates to the ToolMutation builder.
func (m *ToolMutation) Where(ps ...predicate.Tool) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tool, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tool).
func (m *ToolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tool_category != nil {
		fields = append(fields, tool.FieldToolCategory)
	}
	if m.desc != nil {
		fields = append(fields, tool.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tool.FieldToolCategory:
		return m.ToolCategory()
	case tool.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tool.FieldToolCategory:
		return m.OldToolCategory(ctx)
	case tool.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Tool field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tool.FieldToolCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolCategory(v)
		return nil
	case tool.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Tool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tool.FieldDesc) {
		fields = append(fields, tool.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolMutation) ClearField(name string) error {
	switch name {
	case tool.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Tool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolMutation) ResetField(name string) error {
	switch name {
	case tool.FieldToolCategory:
		m.ResetToolCategory()
		return nil
	case tool.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Tool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment != nil {
		edges = append(edges, tool.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tool.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedequipment {
		edges = append(edges, tool.EdgeEquipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolMutation) EdgeCleared(name string) bool {
	switch name {
	case tool.EdgeEquipment:
		return m.clearedequipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolMutation) ClearEdge(name string) error {
	switch name {
	case tool.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown Tool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolMutation) ResetEdge(name string) error {
	switch name {
	case tool.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown Tool edge %s", name)
}

// TraitMutation represents an operation that mutates the Trait nodes in the graph.
type TraitMutation struct {
	config
	op            Op
	typ           string
	id            *int
	indx          *string
	name          *string
	desc          *[]string
	appenddesc    []string
	clearedFields map[string]struct{}
	race          map[int]struct{}
	removedrace   map[int]struct{}
	clearedrace   bool
	done          bool
	oldValue      func(context.Context) (*Trait, error)
	predicates    []predicate.Trait
}

var _ ent.Mutation = (*TraitMutation)(nil)

// traitOption allows management of the mutation configuration using functional options.
type traitOption func(*TraitMutation)

// newTraitMutation creates new mutation for the Trait entity.
func newTraitMutation(c config, op Op, opts ...traitOption) *TraitMutation {
	m := &TraitMutation{
		config:        c,
		op:            op,
		typ:           TypeTrait,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTraitID sets the ID field of the mutation.
func withTraitID(id int) traitOption {
	return func(m *TraitMutation) {
		var (
			err   error
			once  sync.Once
			value *Trait
		)
		m.oldValue = func(ctx context.Context) (*Trait, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Trait.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrait sets the old Trait of the mutation.
func withTrait(node *Trait) traitOption {
	return func(m *TraitMutation) {
		m.oldValue = func(context.Context) (*Trait, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TraitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TraitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TraitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TraitMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Trait.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndx sets the "indx" field.
func (m *TraitMutation) SetIndx(s string) {
	m.indx = &s
}

// Indx returns the value of the "indx" field in the mutation.
func (m *TraitMutation) Indx() (r string, exists bool) {
	v := m.indx
	if v == nil {
		return
	}
	return *v, true
}

// OldIndx returns the old "indx" field's value of the Trait entity.
// If the Trait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraitMutation) OldIndx(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndx: %w", err)
	}
	return oldValue.Indx, nil
}

// ResetIndx resets all changes to the "indx" field.
func (m *TraitMutation) ResetIndx() {
	m.indx = nil
}

// SetName sets the "name" field.
func (m *TraitMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TraitMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Trait entity.
// If the Trait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraitMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TraitMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *TraitMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *TraitMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Trait entity.
// If the Trait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TraitMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *TraitMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *TraitMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *TraitMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[trait.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *TraitMutation) DescCleared() bool {
	_, ok := m.clearedFields[trait.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *TraitMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, trait.FieldDesc)
}

// AddRaceIDs adds the "race" edge to the Race entity by ids.
func (m *TraitMutation) AddRaceIDs(ids ...int) {
	if m.race == nil {
		m.race = make(map[int]struct{})
	}
	for i := range ids {
		m.race[ids[i]] = struct{}{}
	}
}

// ClearRace clears the "race" edge to the Race entity.
func (m *TraitMutation) ClearRace() {
	m.clearedrace = true
}

// RaceCleared reports if the "race" edge to the Race entity was cleared.
func (m *TraitMutation) RaceCleared() bool {
	return m.clearedrace
}

// RemoveRaceIDs removes the "race" edge to the Race entity by IDs.
func (m *TraitMutation) RemoveRaceIDs(ids ...int) {
	if m.removedrace == nil {
		m.removedrace = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.race, ids[i])
		m.removedrace[ids[i]] = struct{}{}
	}
}

// RemovedRace returns the removed IDs of the "race" edge to the Race entity.
func (m *TraitMutation) RemovedRaceIDs() (ids []int) {
	for id := range m.removedrace {
		ids = append(ids, id)
	}
	return
}

// RaceIDs returns the "race" edge IDs in the mutation.
func (m *TraitMutation) RaceIDs() (ids []int) {
	for id := range m.race {
		ids = append(ids, id)
	}
	return
}

// ResetRace resets all changes to the "race" edge.
func (m *TraitMutation) ResetRace() {
	m.race = nil
	m.clearedrace = false
	m.removedrace = nil
}

// Where appends a list predicates to the TraitMutation builder.
func (m *TraitMutation) Where(ps ...predicate.Trait) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TraitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TraitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Trait, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TraitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TraitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Trait).
func (m *TraitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TraitMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.indx != nil {
		fields = append(fields, trait.FieldIndx)
	}
	if m.name != nil {
		fields = append(fields, trait.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, trait.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TraitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trait.FieldIndx:
		return m.Indx()
	case trait.FieldName:
		return m.Name()
	case trait.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TraitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trait.FieldIndx:
		return m.OldIndx(ctx)
	case trait.FieldName:
		return m.OldName(ctx)
	case trait.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Trait field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TraitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trait.FieldIndx:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndx(v)
		return nil
	case trait.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case trait.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Trait field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TraitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TraitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TraitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Trait numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TraitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trait.FieldDesc) {
		fields = append(fields, trait.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TraitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TraitMutation) ClearField(name string) error {
	switch name {
	case trait.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Trait nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TraitMutation) ResetField(name string) error {
	switch name {
	case trait.FieldIndx:
		m.ResetIndx()
		return nil
	case trait.FieldName:
		m.ResetName()
		return nil
	case trait.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Trait field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TraitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.race != nil {
		edges = append(edges, trait.EdgeRace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TraitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trait.EdgeRace:
		ids := make([]ent.Value, 0, len(m.race))
		for id := range m.race {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TraitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrace != nil {
		edges = append(edges, trait.EdgeRace)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TraitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case trait.EdgeRace:
		ids := make([]ent.Value, 0, len(m.removedrace))
		for id := range m.removedrace {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TraitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrace {
		edges = append(edges, trait.EdgeRace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TraitMutation) EdgeCleared(name string) bool {
	switch name {
	case trait.EdgeRace:
		return m.clearedrace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TraitMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Trait unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TraitMutation) ResetEdge(name string) error {
	switch name {
	case trait.EdgeRace:
		m.ResetRace()
		return nil
	}
	return fmt.Errorf("unknown Trait edge %s", name)
}

// VehicleMutation represents an operation that mutates the Vehicle nodes in the graph.
type VehicleMutation struct {
	config
	op                Op
	typ               string
	id                *int
	vehicle_category  *vehicle.VehicleCategory
	capacity          *string
	desc              *[]string
	appenddesc        []string
	speed_quantity    *float64
	addspeed_quantity *float64
	speed_units       *vehicle.SpeedUnits
	clearedFields     map[string]struct{}
	equipment         *int
	clearedequipment  bool
	done              bool
	oldValue          func(context.Context) (*Vehicle, error)
	predicates        []predicate.Vehicle
}

var _ ent.Mutation = (*VehicleMutation)(nil)

// vehicleOption allows management of the mutation configuration using functional options.
type vehicleOption func(*VehicleMutation)

// newVehicleMutation creates new mutation for the Vehicle entity.
func newVehicleMutation(c config, op Op, opts ...vehicleOption) *VehicleMutation {
	m := &VehicleMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleID sets the ID field of the mutation.
func withVehicleID(id int) vehicleOption {
	return func(m *VehicleMutation) {
		var (
			err   error
			once  sync.Once
			value *Vehicle
		)
		m.oldValue = func(ctx context.Context) (*Vehicle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vehicle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicle sets the old Vehicle of the mutation.
func withVehicle(node *Vehicle) vehicleOption {
	return func(m *VehicleMutation) {
		m.oldValue = func(context.Context) (*Vehicle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VehicleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vehicle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVehicleCategory sets the "vehicle_category" field.
func (m *VehicleMutation) SetVehicleCategory(vc vehicle.VehicleCategory) {
	m.vehicle_category = &vc
}

// VehicleCategory returns the value of the "vehicle_category" field in the mutation.
func (m *VehicleMutation) VehicleCategory() (r vehicle.VehicleCategory, exists bool) {
	v := m.vehicle_category
	if v == nil {
		return
	}
	return *v, true
}

// OldVehicleCategory returns the old "vehicle_category" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldVehicleCategory(ctx context.Context) (v vehicle.VehicleCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVehicleCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVehicleCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVehicleCategory: %w", err)
	}
	return oldValue.VehicleCategory, nil
}

// ResetVehicleCategory resets all changes to the "vehicle_category" field.
func (m *VehicleMutation) ResetVehicleCategory() {
	m.vehicle_category = nil
}

// SetCapacity sets the "capacity" field.
func (m *VehicleMutation) SetCapacity(s string) {
	m.capacity = &s
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *VehicleMutation) Capacity() (r string, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCapacity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// ClearCapacity clears the value of the "capacity" field.
func (m *VehicleMutation) ClearCapacity() {
	m.capacity = nil
	m.clearedFields[vehicle.FieldCapacity] = struct{}{}
}

// CapacityCleared returns if the "capacity" field was cleared in this mutation.
func (m *VehicleMutation) CapacityCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldCapacity]
	return ok
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *VehicleMutation) ResetCapacity() {
	m.capacity = nil
	delete(m.clearedFields, vehicle.FieldCapacity)
}

// SetDesc sets the "desc" field.
func (m *VehicleMutation) SetDesc(s []string) {
	m.desc = &s
	m.appenddesc = nil
}

// Desc returns the value of the "desc" field in the mutation.
func (m *VehicleMutation) Desc() (r []string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldDesc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// AppendDesc adds s to the "desc" field.
func (m *VehicleMutation) AppendDesc(s []string) {
	m.appenddesc = append(m.appenddesc, s...)
}

// AppendedDesc returns the list of values that were appended to the "desc" field in this mutation.
func (m *VehicleMutation) AppendedDesc() ([]string, bool) {
	if len(m.appenddesc) == 0 {
		return nil, false
	}
	return m.appenddesc, true
}

// ClearDesc clears the value of the "desc" field.
func (m *VehicleMutation) ClearDesc() {
	m.desc = nil
	m.appenddesc = nil
	m.clearedFields[vehicle.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *VehicleMutation) DescCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *VehicleMutation) ResetDesc() {
	m.desc = nil
	m.appenddesc = nil
	delete(m.clearedFields, vehicle.FieldDesc)
}

// SetSpeedQuantity sets the "speed_quantity" field.
func (m *VehicleMutation) SetSpeedQuantity(f float64) {
	m.speed_quantity = &f
	m.addspeed_quantity = nil
}

// SpeedQuantity returns the value of the "speed_quantity" field in the mutation.
func (m *VehicleMutation) SpeedQuantity() (r float64, exists bool) {
	v := m.speed_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeedQuantity returns the old "speed_quantity" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldSpeedQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeedQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeedQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeedQuantity: %w", err)
	}
	return oldValue.SpeedQuantity, nil
}

// AddSpeedQuantity adds f to the "speed_quantity" field.
func (m *VehicleMutation) AddSpeedQuantity(f float64) {
	if m.addspeed_quantity != nil {
		*m.addspeed_quantity += f
	} else {
		m.addspeed_quantity = &f
	}
}

// AddedSpeedQuantity returns the value that was added to the "speed_quantity" field in this mutation.
func (m *VehicleMutation) AddedSpeedQuantity() (r float64, exists bool) {
	v := m.addspeed_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearSpeedQuantity clears the value of the "speed_quantity" field.
func (m *VehicleMutation) ClearSpeedQuantity() {
	m.speed_quantity = nil
	m.addspeed_quantity = nil
	m.clearedFields[vehicle.FieldSpeedQuantity] = struct{}{}
}

// SpeedQuantityCleared returns if the "speed_quantity" field was cleared in this mutation.
func (m *VehicleMutation) SpeedQuantityCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldSpeedQuantity]
	return ok
}

// ResetSpeedQuantity resets all changes to the "speed_quantity" field.
func (m *VehicleMutation) ResetSpeedQuantity() {
	m.speed_quantity = nil
	m.addspeed_quantity = nil
	delete(m.clearedFields, vehicle.FieldSpeedQuantity)
}

// SetSpeedUnits sets the "speed_units" field.
func (m *VehicleMutation) SetSpeedUnits(vu vehicle.SpeedUnits) {
	m.speed_units = &vu
}

// SpeedUnits returns the value of the "speed_units" field in the mutation.
func (m *VehicleMutation) SpeedUnits() (r vehicle.SpeedUnits, exists bool) {
	v := m.speed_units
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeedUnits returns the old "speed_units" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldSpeedUnits(ctx context.Context) (v vehicle.SpeedUnits, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeedUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeedUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeedUnits: %w", err)
	}
	return oldValue.SpeedUnits, nil
}

// ClearSpeedUnits clears the value of the "speed_units" field.
func (m *VehicleMutation) ClearSpeedUnits() {
	m.speed_units = nil
	m.clearedFields[vehicle.FieldSpeedUnits] = struct{}{}
}

// SpeedUnitsCleared returns if the "speed_units" field was cleared in this mutation.
func (m *VehicleMutation) SpeedUnitsCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldSpeedUnits]
	return ok
}

// ResetSpeedUnits resets all changes to the "speed_units" field.
func (m *VehicleMutation) ResetSpeedUnits() {
	m.speed_units = nil
	delete(m.clearedFields, vehicle.FieldSpeedUnits)
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *VehicleMutation) SetEquipmentID(id int) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *VehicleMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *VehicleMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *VehicleMutation) EquipmentID() (id int, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *VehicleMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *VehicleMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// Where appends a list predicates to the VehicleMutation builder.
func (m *VehicleMutation) Where(ps ...predicate.Vehicle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VehicleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VehicleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vehicle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VehicleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VehicleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vehicle).
func (m *VehicleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.vehicle_category != nil {
		fields = append(fields, vehicle.FieldVehicleCategory)
	}
	if m.capacity != nil {
		fields = append(fields, vehicle.FieldCapacity)
	}
	if m.desc != nil {
		fields = append(fields, vehicle.FieldDesc)
	}
	if m.speed_quantity != nil {
		fields = append(fields, vehicle.FieldSpeedQuantity)
	}
	if m.speed_units != nil {
		fields = append(fields, vehicle.FieldSpeedUnits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldVehicleCategory:
		return m.VehicleCategory()
	case vehicle.FieldCapacity:
		return m.Capacity()
	case vehicle.FieldDesc:
		return m.Desc()
	case vehicle.FieldSpeedQuantity:
		return m.SpeedQuantity()
	case vehicle.FieldSpeedUnits:
		return m.SpeedUnits()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehicle.FieldVehicleCategory:
		return m.OldVehicleCategory(ctx)
	case vehicle.FieldCapacity:
		return m.OldCapacity(ctx)
	case vehicle.FieldDesc:
		return m.OldDesc(ctx)
	case vehicle.FieldSpeedQuantity:
		return m.OldSpeedQuantity(ctx)
	case vehicle.FieldSpeedUnits:
		return m.OldSpeedUnits(ctx)
	}
	return nil, fmt.Errorf("unknown Vehicle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldVehicleCategory:
		v, ok := value.(vehicle.VehicleCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVehicleCategory(v)
		return nil
	case vehicle.FieldCapacity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case vehicle.FieldDesc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case vehicle.FieldSpeedQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeedQuantity(v)
		return nil
	case vehicle.FieldSpeedUnits:
		v, ok := value.(vehicle.SpeedUnits)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeedUnits(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleMutation) AddedFields() []string {
	var fields []string
	if m.addspeed_quantity != nil {
		fields = append(fields, vehicle.FieldSpeedQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldSpeedQuantity:
		return m.AddedSpeedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldSpeedQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpeedQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vehicle.FieldCapacity) {
		fields = append(fields, vehicle.FieldCapacity)
	}
	if m.FieldCleared(vehicle.FieldDesc) {
		fields = append(fields, vehicle.FieldDesc)
	}
	if m.FieldCleared(vehicle.FieldSpeedQuantity) {
		fields = append(fields, vehicle.FieldSpeedQuantity)
	}
	if m.FieldCleared(vehicle.FieldSpeedUnits) {
		fields = append(fields, vehicle.FieldSpeedUnits)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleMutation) ClearField(name string) error {
	switch name {
	case vehicle.FieldCapacity:
		m.ClearCapacity()
		return nil
	case vehicle.FieldDesc:
		m.ClearDesc()
		return nil
	case vehicle.FieldSpeedQuantity:
		m.ClearSpeedQuantity()
		return nil
	case vehicle.FieldSpeedUnits:
		m.ClearSpeedUnits()
		return nil
	}
	return fmt.Errorf("unknown Vehicle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleMutation) ResetField(name string) error {
	switch name {
	case vehicle.FieldVehicleCategory:
		m.ResetVehicleCategory()
		return nil
	case vehicle.FieldCapacity:
		m.ResetCapacity()
		return nil
	case vehicle.FieldDesc:
		m.ResetDesc()
		return nil
	case vehicle.FieldSpeedQuantity:
		m.ResetSpeedQuantity()
		return nil
	case vehicle.FieldSpeedUnits:
		m.ResetSpeedUnits()
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment != nil {
		edges = append(edges, vehicle.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehicle.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedequipment {
		edges = append(edges, vehicle.EdgeEquipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleMutation) EdgeCleared(name string) bool {
	switch name {
	case vehicle.EdgeEquipment:
		return m.clearedequipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleMutation) ClearEdge(name string) error {
	switch name {
	case vehicle.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown Vehicle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleMutation) ResetEdge(name string) error {
	switch name {
	case vehicle.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown Vehicle edge %s", name)
}

// WeaponMutation represents an operation that mutates the Weapon nodes in the graph.
type WeaponMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	weapon_category       *weapon.WeaponCategory
	weapon_subcategory    *weapon.WeaponSubcategory
	range_normal          *int
	addrange_normal       *int
	range_long            *int
	addrange_long         *int
	throw_range_normal    *int
	addthrow_range_normal *int
	throw_range_long      *int
	addthrow_range_long   *int
	damage_dice           *string
	clearedFields         map[string]struct{}
	properties            map[int]struct{}
	removedproperties     map[int]struct{}
	clearedproperties     bool
	damage_type           *int
	cleareddamage_type    bool
	equipment             *int
	clearedequipment      bool
	done                  bool
	oldValue              func(context.Context) (*Weapon, error)
	predicates            []predicate.Weapon
}

var _ ent.Mutation = (*WeaponMutation)(nil)

// weaponOption allows management of the mutation configuration using functional options.
type weaponOption func(*WeaponMutation)

// newWeaponMutation creates new mutation for the Weapon entity.
func newWeaponMutation(c config, op Op, opts ...weaponOption) *WeaponMutation {
	m := &WeaponMutation{
		config:        c,
		op:            op,
		typ:           TypeWeapon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWeaponID sets the ID field of the mutation.
func withWeaponID(id int) weaponOption {
	return func(m *WeaponMutation) {
		var (
			err   error
			once  sync.Once
			value *Weapon
		)
		m.oldValue = func(ctx context.Context) (*Weapon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Weapon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWeapon sets the old Weapon of the mutation.
func withWeapon(node *Weapon) weaponOption {
	return func(m *WeaponMutation) {
		m.oldValue = func(context.Context) (*Weapon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WeaponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WeaponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WeaponMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WeaponMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Weapon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWeaponCategory sets the "weapon_category" field.
func (m *WeaponMutation) SetWeaponCategory(wc weapon.WeaponCategory) {
	m.weapon_category = &wc
}

// WeaponCategory returns the value of the "weapon_category" field in the mutation.
func (m *WeaponMutation) WeaponCategory() (r weapon.WeaponCategory, exists bool) {
	v := m.weapon_category
	if v == nil {
		return
	}
	return *v, true
}

// OldWeaponCategory returns the old "weapon_category" field's value of the Weapon entity.
// If the Weapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeaponMutation) OldWeaponCategory(ctx context.Context) (v weapon.WeaponCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeaponCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeaponCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeaponCategory: %w", err)
	}
	return oldValue.WeaponCategory, nil
}

// ResetWeaponCategory resets all changes to the "weapon_category" field.
func (m *WeaponMutation) ResetWeaponCategory() {
	m.weapon_category = nil
}

// SetWeaponSubcategory sets the "weapon_subcategory" field.
func (m *WeaponMutation) SetWeaponSubcategory(ws weapon.WeaponSubcategory) {
	m.weapon_subcategory = &ws
}

// WeaponSubcategory returns the value of the "weapon_subcategory" field in the mutation.
func (m *WeaponMutation) WeaponSubcategory() (r weapon.WeaponSubcategory, exists bool) {
	v := m.weapon_subcategory
	if v == nil {
		return
	}
	return *v, true
}

// OldWeaponSubcategory returns the old "weapon_subcategory" field's value of the Weapon entity.
// If the Weapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeaponMutation) OldWeaponSubcategory(ctx context.Context) (v weapon.WeaponSubcategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeaponSubcategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeaponSubcategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeaponSubcategory: %w", err)
	}
	return oldValue.WeaponSubcategory, nil
}

// ResetWeaponSubcategory resets all changes to the "weapon_subcategory" field.
func (m *WeaponMutation) ResetWeaponSubcategory() {
	m.weapon_subcategory = nil
}

// SetRangeNormal sets the "range_normal" field.
func (m *WeaponMutation) SetRangeNormal(i int) {
	m.range_normal = &i
	m.addrange_normal = nil
}

// RangeNormal returns the value of the "range_normal" field in the mutation.
func (m *WeaponMutation) RangeNormal() (r int, exists bool) {
	v := m.range_normal
	if v == nil {
		return
	}
	return *v, true
}

// OldRangeNormal returns the old "range_normal" field's value of the Weapon entity.
// If the Weapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeaponMutation) OldRangeNormal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRangeNormal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRangeNormal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRangeNormal: %w", err)
	}
	return oldValue.RangeNormal, nil
}

// AddRangeNormal adds i to the "range_normal" field.
func (m *WeaponMutation) AddRangeNormal(i int) {
	if m.addrange_normal != nil {
		*m.addrange_normal += i
	} else {
		m.addrange_normal = &i
	}
}

// AddedRangeNormal returns the value that was added to the "range_normal" field in this mutation.
func (m *WeaponMutation) AddedRangeNormal() (r int, exists bool) {
	v := m.addrange_normal
	if v == nil {
		return
	}
	return *v, true
}

// ClearRangeNormal clears the value of the "range_normal" field.
func (m *WeaponMutation) ClearRangeNormal() {
	m.range_normal = nil
	m.addrange_normal = nil
	m.clearedFields[weapon.FieldRangeNormal] = struct{}{}
}

// RangeNormalCleared returns if the "range_normal" field was cleared in this mutation.
func (m *WeaponMutation) RangeNormalCleared() bool {
	_, ok := m.clearedFields[weapon.FieldRangeNormal]
	return ok
}

// ResetRangeNormal resets all changes to the "range_normal" field.
func (m *WeaponMutation) ResetRangeNormal() {
	m.range_normal = nil
	m.addrange_normal = nil
	delete(m.clearedFields, weapon.FieldRangeNormal)
}

// SetRangeLong sets the "range_long" field.
func (m *WeaponMutation) SetRangeLong(i int) {
	m.range_long = &i
	m.addrange_long = nil
}

// RangeLong returns the value of the "range_long" field in the mutation.
func (m *WeaponMutation) RangeLong() (r int, exists bool) {
	v := m.range_long
	if v == nil {
		return
	}
	return *v, true
}

// OldRangeLong returns the old "range_long" field's value of the Weapon entity.
// If the Weapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeaponMutation) OldRangeLong(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRangeLong is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRangeLong requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRangeLong: %w", err)
	}
	return oldValue.RangeLong, nil
}

// AddRangeLong adds i to the "range_long" field.
func (m *WeaponMutation) AddRangeLong(i int) {
	if m.addrange_long != nil {
		*m.addrange_long += i
	} else {
		m.addrange_long = &i
	}
}

// AddedRangeLong returns the value that was added to the "range_long" field in this mutation.
func (m *WeaponMutation) AddedRangeLong() (r int, exists bool) {
	v := m.addrange_long
	if v == nil {
		return
	}
	return *v, true
}

// ClearRangeLong clears the value of the "range_long" field.
func (m *WeaponMutation) ClearRangeLong() {
	m.range_long = nil
	m.addrange_long = nil
	m.clearedFields[weapon.FieldRangeLong] = struct{}{}
}

// RangeLongCleared returns if the "range_long" field was cleared in this mutation.
func (m *WeaponMutation) RangeLongCleared() bool {
	_, ok := m.clearedFields[weapon.FieldRangeLong]
	return ok
}

// ResetRangeLong resets all changes to the "range_long" field.
func (m *WeaponMutation) ResetRangeLong() {
	m.range_long = nil
	m.addrange_long = nil
	delete(m.clearedFields, weapon.FieldRangeLong)
}

// SetThrowRangeNormal sets the "throw_range_normal" field.
func (m *WeaponMutation) SetThrowRangeNormal(i int) {
	m.throw_range_normal = &i
	m.addthrow_range_normal = nil
}

// ThrowRangeNormal returns the value of the "throw_range_normal" field in the mutation.
func (m *WeaponMutation) ThrowRangeNormal() (r int, exists bool) {
	v := m.throw_range_normal
	if v == nil {
		return
	}
	return *v, true
}

// OldThrowRangeNormal returns the old "throw_range_normal" field's value of the Weapon entity.
// If the Weapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeaponMutation) OldThrowRangeNormal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThrowRangeNormal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThrowRangeNormal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThrowRangeNormal: %w", err)
	}
	return oldValue.ThrowRangeNormal, nil
}

// AddThrowRangeNormal adds i to the "throw_range_normal" field.
func (m *WeaponMutation) AddThrowRangeNormal(i int) {
	if m.addthrow_range_normal != nil {
		*m.addthrow_range_normal += i
	} else {
		m.addthrow_range_normal = &i
	}
}

// AddedThrowRangeNormal returns the value that was added to the "throw_range_normal" field in this mutation.
func (m *WeaponMutation) AddedThrowRangeNormal() (r int, exists bool) {
	v := m.addthrow_range_normal
	if v == nil {
		return
	}
	return *v, true
}

// ClearThrowRangeNormal clears the value of the "throw_range_normal" field.
func (m *WeaponMutation) ClearThrowRangeNormal() {
	m.throw_range_normal = nil
	m.addthrow_range_normal = nil
	m.clearedFields[weapon.FieldThrowRangeNormal] = struct{}{}
}

// ThrowRangeNormalCleared returns if the "throw_range_normal" field was cleared in this mutation.
func (m *WeaponMutation) ThrowRangeNormalCleared() bool {
	_, ok := m.clearedFields[weapon.FieldThrowRangeNormal]
	return ok
}

// ResetThrowRangeNormal resets all changes to the "throw_range_normal" field.
func (m *WeaponMutation) ResetThrowRangeNormal() {
	m.throw_range_normal = nil
	m.addthrow_range_normal = nil
	delete(m.clearedFields, weapon.FieldThrowRangeNormal)
}

// SetThrowRangeLong sets the "throw_range_long" field.
func (m *WeaponMutation) SetThrowRangeLong(i int) {
	m.throw_range_long = &i
	m.addthrow_range_long = nil
}

// ThrowRangeLong returns the value of the "throw_range_long" field in the mutation.
func (m *WeaponMutation) ThrowRangeLong() (r int, exists bool) {
	v := m.throw_range_long
	if v == nil {
		return
	}
	return *v, true
}

// OldThrowRangeLong returns the old "throw_range_long" field's value of the Weapon entity.
// If the Weapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeaponMutation) OldThrowRangeLong(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThrowRangeLong is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThrowRangeLong requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThrowRangeLong: %w", err)
	}
	return oldValue.ThrowRangeLong, nil
}

// AddThrowRangeLong adds i to the "throw_range_long" field.
func (m *WeaponMutation) AddThrowRangeLong(i int) {
	if m.addthrow_range_long != nil {
		*m.addthrow_range_long += i
	} else {
		m.addthrow_range_long = &i
	}
}

// AddedThrowRangeLong returns the value that was added to the "throw_range_long" field in this mutation.
func (m *WeaponMutation) AddedThrowRangeLong() (r int, exists bool) {
	v := m.addthrow_range_long
	if v == nil {
		return
	}
	return *v, true
}

// ClearThrowRangeLong clears the value of the "throw_range_long" field.
func (m *WeaponMutation) ClearThrowRangeLong() {
	m.throw_range_long = nil
	m.addthrow_range_long = nil
	m.clearedFields[weapon.FieldThrowRangeLong] = struct{}{}
}

// ThrowRangeLongCleared returns if the "throw_range_long" field was cleared in this mutation.
func (m *WeaponMutation) ThrowRangeLongCleared() bool {
	_, ok := m.clearedFields[weapon.FieldThrowRangeLong]
	return ok
}

// ResetThrowRangeLong resets all changes to the "throw_range_long" field.
func (m *WeaponMutation) ResetThrowRangeLong() {
	m.throw_range_long = nil
	m.addthrow_range_long = nil
	delete(m.clearedFields, weapon.FieldThrowRangeLong)
}

// SetDamageDice sets the "damage_dice" field.
func (m *WeaponMutation) SetDamageDice(s string) {
	m.damage_dice = &s
}

// DamageDice returns the value of the "damage_dice" field in the mutation.
func (m *WeaponMutation) DamageDice() (r string, exists bool) {
	v := m.damage_dice
	if v == nil {
		return
	}
	return *v, true
}

// OldDamageDice returns the old "damage_dice" field's value of the Weapon entity.
// If the Weapon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WeaponMutation) OldDamageDice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDamageDice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDamageDice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDamageDice: %w", err)
	}
	return oldValue.DamageDice, nil
}

// ClearDamageDice clears the value of the "damage_dice" field.
func (m *WeaponMutation) ClearDamageDice() {
	m.damage_dice = nil
	m.clearedFields[weapon.FieldDamageDice] = struct{}{}
}

// DamageDiceCleared returns if the "damage_dice" field was cleared in this mutation.
func (m *WeaponMutation) DamageDiceCleared() bool {
	_, ok := m.clearedFields[weapon.FieldDamageDice]
	return ok
}

// ResetDamageDice resets all changes to the "damage_dice" field.
func (m *WeaponMutation) ResetDamageDice() {
	m.damage_dice = nil
	delete(m.clearedFields, weapon.FieldDamageDice)
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *WeaponMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *WeaponMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *WeaponMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *WeaponMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *WeaponMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *WeaponMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *WeaponMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// SetDamageTypeID sets the "damage_type" edge to the DamageType entity by id.
func (m *WeaponMutation) SetDamageTypeID(id int) {
	m.damage_type = &id
}

// ClearDamageType clears the "damage_type" edge to the DamageType entity.
func (m *WeaponMutation) ClearDamageType() {
	m.cleareddamage_type = true
}

// DamageTypeCleared reports if the "damage_type" edge to the DamageType entity was cleared.
func (m *WeaponMutation) DamageTypeCleared() bool {
	return m.cleareddamage_type
}

// DamageTypeID returns the "damage_type" edge ID in the mutation.
func (m *WeaponMutation) DamageTypeID() (id int, exists bool) {
	if m.damage_type != nil {
		return *m.damage_type, true
	}
	return
}

// DamageTypeIDs returns the "damage_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DamageTypeID instead. It exists only for internal usage by the builders.
func (m *WeaponMutation) DamageTypeIDs() (ids []int) {
	if id := m.damage_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDamageType resets all changes to the "damage_type" edge.
func (m *WeaponMutation) ResetDamageType() {
	m.damage_type = nil
	m.cleareddamage_type = false
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *WeaponMutation) SetEquipmentID(id int) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *WeaponMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *WeaponMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *WeaponMutation) EquipmentID() (id int, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *WeaponMutation) EquipmentIDs() (ids []int) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *WeaponMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// Where appends a list predicates to the WeaponMutation builder.
func (m *WeaponMutation) Where(ps ...predicate.Weapon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WeaponMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WeaponMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Weapon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WeaponMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WeaponMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Weapon).
func (m *WeaponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WeaponMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.weapon_category != nil {
		fields = append(fields, weapon.FieldWeaponCategory)
	}
	if m.weapon_subcategory != nil {
		fields = append(fields, weapon.FieldWeaponSubcategory)
	}
	if m.range_normal != nil {
		fields = append(fields, weapon.FieldRangeNormal)
	}
	if m.range_long != nil {
		fields = append(fields, weapon.FieldRangeLong)
	}
	if m.throw_range_normal != nil {
		fields = append(fields, weapon.FieldThrowRangeNormal)
	}
	if m.throw_range_long != nil {
		fields = append(fields, weapon.FieldThrowRangeLong)
	}
	if m.damage_dice != nil {
		fields = append(fields, weapon.FieldDamageDice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WeaponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case weapon.FieldWeaponCategory:
		return m.WeaponCategory()
	case weapon.FieldWeaponSubcategory:
		return m.WeaponSubcategory()
	case weapon.FieldRangeNormal:
		return m.RangeNormal()
	case weapon.FieldRangeLong:
		return m.RangeLong()
	case weapon.FieldThrowRangeNormal:
		return m.ThrowRangeNormal()
	case weapon.FieldThrowRangeLong:
		return m.ThrowRangeLong()
	case weapon.FieldDamageDice:
		return m.DamageDice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WeaponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case weapon.FieldWeaponCategory:
		return m.OldWeaponCategory(ctx)
	case weapon.FieldWeaponSubcategory:
		return m.OldWeaponSubcategory(ctx)
	case weapon.FieldRangeNormal:
		return m.OldRangeNormal(ctx)
	case weapon.FieldRangeLong:
		return m.OldRangeLong(ctx)
	case weapon.FieldThrowRangeNormal:
		return m.OldThrowRangeNormal(ctx)
	case weapon.FieldThrowRangeLong:
		return m.OldThrowRangeLong(ctx)
	case weapon.FieldDamageDice:
		return m.OldDamageDice(ctx)
	}
	return nil, fmt.Errorf("unknown Weapon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WeaponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case weapon.FieldWeaponCategory:
		v, ok := value.(weapon.WeaponCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeaponCategory(v)
		return nil
	case weapon.FieldWeaponSubcategory:
		v, ok := value.(weapon.WeaponSubcategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeaponSubcategory(v)
		return nil
	case weapon.FieldRangeNormal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRangeNormal(v)
		return nil
	case weapon.FieldRangeLong:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRangeLong(v)
		return nil
	case weapon.FieldThrowRangeNormal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThrowRangeNormal(v)
		return nil
	case weapon.FieldThrowRangeLong:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThrowRangeLong(v)
		return nil
	case weapon.FieldDamageDice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDamageDice(v)
		return nil
	}
	return fmt.Errorf("unknown Weapon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WeaponMutation) AddedFields() []string {
	var fields []string
	if m.addrange_normal != nil {
		fields = append(fields, weapon.FieldRangeNormal)
	}
	if m.addrange_long != nil {
		fields = append(fields, weapon.FieldRangeLong)
	}
	if m.addthrow_range_normal != nil {
		fields = append(fields, weapon.FieldThrowRangeNormal)
	}
	if m.addthrow_range_long != nil {
		fields = append(fields, weapon.FieldThrowRangeLong)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WeaponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case weapon.FieldRangeNormal:
		return m.AddedRangeNormal()
	case weapon.FieldRangeLong:
		return m.AddedRangeLong()
	case weapon.FieldThrowRangeNormal:
		return m.AddedThrowRangeNormal()
	case weapon.FieldThrowRangeLong:
		return m.AddedThrowRangeLong()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WeaponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case weapon.FieldRangeNormal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRangeNormal(v)
		return nil
	case weapon.FieldRangeLong:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRangeLong(v)
		return nil
	case weapon.FieldThrowRangeNormal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThrowRangeNormal(v)
		return nil
	case weapon.FieldThrowRangeLong:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThrowRangeLong(v)
		return nil
	}
	return fmt.Errorf("unknown Weapon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WeaponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(weapon.FieldRangeNormal) {
		fields = append(fields, weapon.FieldRangeNormal)
	}
	if m.FieldCleared(weapon.FieldRangeLong) {
		fields = append(fields, weapon.FieldRangeLong)
	}
	if m.FieldCleared(weapon.FieldThrowRangeNormal) {
		fields = append(fields, weapon.FieldThrowRangeNormal)
	}
	if m.FieldCleared(weapon.FieldThrowRangeLong) {
		fields = append(fields, weapon.FieldThrowRangeLong)
	}
	if m.FieldCleared(weapon.FieldDamageDice) {
		fields = append(fields, weapon.FieldDamageDice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WeaponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WeaponMutation) ClearField(name string) error {
	switch name {
	case weapon.FieldRangeNormal:
		m.ClearRangeNormal()
		return nil
	case weapon.FieldRangeLong:
		m.ClearRangeLong()
		return nil
	case weapon.FieldThrowRangeNormal:
		m.ClearThrowRangeNormal()
		return nil
	case weapon.FieldThrowRangeLong:
		m.ClearThrowRangeLong()
		return nil
	case weapon.FieldDamageDice:
		m.ClearDamageDice()
		return nil
	}
	return fmt.Errorf("unknown Weapon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WeaponMutation) ResetField(name string) error {
	switch name {
	case weapon.FieldWeaponCategory:
		m.ResetWeaponCategory()
		return nil
	case weapon.FieldWeaponSubcategory:
		m.ResetWeaponSubcategory()
		return nil
	case weapon.FieldRangeNormal:
		m.ResetRangeNormal()
		return nil
	case weapon.FieldRangeLong:
		m.ResetRangeLong()
		return nil
	case weapon.FieldThrowRangeNormal:
		m.ResetThrowRangeNormal()
		return nil
	case weapon.FieldThrowRangeLong:
		m.ResetThrowRangeLong()
		return nil
	case weapon.FieldDamageDice:
		m.ResetDamageDice()
		return nil
	}
	return fmt.Errorf("unknown Weapon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WeaponMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.properties != nil {
		edges = append(edges, weapon.EdgeProperties)
	}
	if m.damage_type != nil {
		edges = append(edges, weapon.EdgeDamageType)
	}
	if m.equipment != nil {
		edges = append(edges, weapon.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WeaponMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case weapon.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case weapon.EdgeDamageType:
		if id := m.damage_type; id != nil {
			return []ent.Value{*id}
		}
	case weapon.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WeaponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproperties != nil {
		edges = append(edges, weapon.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WeaponMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case weapon.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WeaponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproperties {
		edges = append(edges, weapon.EdgeProperties)
	}
	if m.cleareddamage_type {
		edges = append(edges, weapon.EdgeDamageType)
	}
	if m.clearedequipment {
		edges = append(edges, weapon.EdgeEquipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WeaponMutation) EdgeCleared(name string) bool {
	switch name {
	case weapon.EdgeProperties:
		return m.clearedproperties
	case weapon.EdgeDamageType:
		return m.cleareddamage_type
	case weapon.EdgeEquipment:
		return m.clearedequipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WeaponMutation) ClearEdge(name string) error {
	switch name {
	case weapon.EdgeDamageType:
		m.ClearDamageType()
		return nil
	case weapon.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown Weapon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WeaponMutation) ResetEdge(name string) error {
	switch name {
	case weapon.EdgeProperties:
		m.ResetProperties()
		return nil
	case weapon.EdgeDamageType:
		m.ResetDamageType()
		return nil
	case weapon.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown Weapon edge %s", name)
}
