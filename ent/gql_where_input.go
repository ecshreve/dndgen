// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"github.com/ecshreve/dndgen/ent/abilitybonus"
	"github.com/ecshreve/dndgen/ent/abilityscore"
	"github.com/ecshreve/dndgen/ent/alignment"
	"github.com/ecshreve/dndgen/ent/armor"
	"github.com/ecshreve/dndgen/ent/armorclass"
	"github.com/ecshreve/dndgen/ent/class"
	"github.com/ecshreve/dndgen/ent/coin"
	"github.com/ecshreve/dndgen/ent/condition"
	"github.com/ecshreve/dndgen/ent/cost"
	"github.com/ecshreve/dndgen/ent/damage"
	"github.com/ecshreve/dndgen/ent/damagetype"
	"github.com/ecshreve/dndgen/ent/equipment"
	"github.com/ecshreve/dndgen/ent/feat"
	"github.com/ecshreve/dndgen/ent/gear"
	"github.com/ecshreve/dndgen/ent/language"
	"github.com/ecshreve/dndgen/ent/magicschool"
	"github.com/ecshreve/dndgen/ent/predicate"
	"github.com/ecshreve/dndgen/ent/property"
	"github.com/ecshreve/dndgen/ent/race"
	"github.com/ecshreve/dndgen/ent/rule"
	"github.com/ecshreve/dndgen/ent/rulesection"
	"github.com/ecshreve/dndgen/ent/skill"
	"github.com/ecshreve/dndgen/ent/tool"
	"github.com/ecshreve/dndgen/ent/vehicle"
	"github.com/ecshreve/dndgen/ent/weapon"
	"github.com/ecshreve/dndgen/ent/weaponrange"
)

// AbilityBonusWhereInput represents a where input for filtering AbilityBonus queries.
type AbilityBonusWhereInput struct {
	Predicates []predicate.AbilityBonus  `json:"-"`
	Not        *AbilityBonusWhereInput   `json:"not,omitempty"`
	Or         []*AbilityBonusWhereInput `json:"or,omitempty"`
	And        []*AbilityBonusWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "bonus" field predicates.
	Bonus      *int  `json:"bonus,omitempty"`
	BonusNEQ   *int  `json:"bonusNEQ,omitempty"`
	BonusIn    []int `json:"bonusIn,omitempty"`
	BonusNotIn []int `json:"bonusNotIn,omitempty"`
	BonusGT    *int  `json:"bonusGT,omitempty"`
	BonusGTE   *int  `json:"bonusGTE,omitempty"`
	BonusLT    *int  `json:"bonusLT,omitempty"`
	BonusLTE   *int  `json:"bonusLTE,omitempty"`

	// "ability_score" edge predicates.
	HasAbilityScore     *bool                     `json:"hasAbilityScore,omitempty"`
	HasAbilityScoreWith []*AbilityScoreWhereInput `json:"hasAbilityScoreWith,omitempty"`

	// "race" edge predicates.
	HasRace     *bool             `json:"hasRace,omitempty"`
	HasRaceWith []*RaceWhereInput `json:"hasRaceWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AbilityBonusWhereInput) AddPredicates(predicates ...predicate.AbilityBonus) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AbilityBonusWhereInput filter on the AbilityBonusQuery builder.
func (i *AbilityBonusWhereInput) Filter(q *AbilityBonusQuery) (*AbilityBonusQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAbilityBonusWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAbilityBonusWhereInput is returned in case the AbilityBonusWhereInput is empty.
var ErrEmptyAbilityBonusWhereInput = errors.New("ent: empty predicate AbilityBonusWhereInput")

// P returns a predicate for filtering abilitybonusslice.
// An error is returned if the input is empty or invalid.
func (i *AbilityBonusWhereInput) P() (predicate.AbilityBonus, error) {
	var predicates []predicate.AbilityBonus
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, abilitybonus.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AbilityBonus, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, abilitybonus.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AbilityBonus, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, abilitybonus.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, abilitybonus.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, abilitybonus.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, abilitybonus.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, abilitybonus.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, abilitybonus.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, abilitybonus.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, abilitybonus.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, abilitybonus.IDLTE(*i.IDLTE))
	}
	if i.Bonus != nil {
		predicates = append(predicates, abilitybonus.BonusEQ(*i.Bonus))
	}
	if i.BonusNEQ != nil {
		predicates = append(predicates, abilitybonus.BonusNEQ(*i.BonusNEQ))
	}
	if len(i.BonusIn) > 0 {
		predicates = append(predicates, abilitybonus.BonusIn(i.BonusIn...))
	}
	if len(i.BonusNotIn) > 0 {
		predicates = append(predicates, abilitybonus.BonusNotIn(i.BonusNotIn...))
	}
	if i.BonusGT != nil {
		predicates = append(predicates, abilitybonus.BonusGT(*i.BonusGT))
	}
	if i.BonusGTE != nil {
		predicates = append(predicates, abilitybonus.BonusGTE(*i.BonusGTE))
	}
	if i.BonusLT != nil {
		predicates = append(predicates, abilitybonus.BonusLT(*i.BonusLT))
	}
	if i.BonusLTE != nil {
		predicates = append(predicates, abilitybonus.BonusLTE(*i.BonusLTE))
	}

	if i.HasAbilityScore != nil {
		p := abilitybonus.HasAbilityScore()
		if !*i.HasAbilityScore {
			p = abilitybonus.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAbilityScoreWith) > 0 {
		with := make([]predicate.AbilityScore, 0, len(i.HasAbilityScoreWith))
		for _, w := range i.HasAbilityScoreWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAbilityScoreWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, abilitybonus.HasAbilityScoreWith(with...))
	}
	if i.HasRace != nil {
		p := abilitybonus.HasRace()
		if !*i.HasRace {
			p = abilitybonus.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRaceWith) > 0 {
		with := make([]predicate.Race, 0, len(i.HasRaceWith))
		for _, w := range i.HasRaceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRaceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, abilitybonus.HasRaceWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAbilityBonusWhereInput
	case 1:
		return predicates[0], nil
	default:
		return abilitybonus.And(predicates...), nil
	}
}

// AbilityScoreWhereInput represents a where input for filtering AbilityScore queries.
type AbilityScoreWhereInput struct {
	Predicates []predicate.AbilityScore  `json:"-"`
	Not        *AbilityScoreWhereInput   `json:"not,omitempty"`
	Or         []*AbilityScoreWhereInput `json:"or,omitempty"`
	And        []*AbilityScoreWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "full_name" field predicates.
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNEQ          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGT           *string  `json:"fullNameGT,omitempty"`
	FullNameGTE          *string  `json:"fullNameGTE,omitempty"`
	FullNameLT           *string  `json:"fullNameLT,omitempty"`
	FullNameLTE          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`

	// "skills" edge predicates.
	HasSkills     *bool              `json:"hasSkills,omitempty"`
	HasSkillsWith []*SkillWhereInput `json:"hasSkillsWith,omitempty"`

	// "ability_bonuses" edge predicates.
	HasAbilityBonuses     *bool                     `json:"hasAbilityBonuses,omitempty"`
	HasAbilityBonusesWith []*AbilityBonusWhereInput `json:"hasAbilityBonusesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AbilityScoreWhereInput) AddPredicates(predicates ...predicate.AbilityScore) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AbilityScoreWhereInput filter on the AbilityScoreQuery builder.
func (i *AbilityScoreWhereInput) Filter(q *AbilityScoreQuery) (*AbilityScoreQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAbilityScoreWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAbilityScoreWhereInput is returned in case the AbilityScoreWhereInput is empty.
var ErrEmptyAbilityScoreWhereInput = errors.New("ent: empty predicate AbilityScoreWhereInput")

// P returns a predicate for filtering abilityscores.
// An error is returned if the input is empty or invalid.
func (i *AbilityScoreWhereInput) P() (predicate.AbilityScore, error) {
	var predicates []predicate.AbilityScore
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, abilityscore.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AbilityScore, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, abilityscore.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AbilityScore, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, abilityscore.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, abilityscore.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, abilityscore.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, abilityscore.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, abilityscore.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, abilityscore.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, abilityscore.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, abilityscore.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, abilityscore.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, abilityscore.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, abilityscore.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, abilityscore.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, abilityscore.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, abilityscore.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, abilityscore.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, abilityscore.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, abilityscore.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, abilityscore.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, abilityscore.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, abilityscore.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, abilityscore.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, abilityscore.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, abilityscore.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, abilityscore.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, abilityscore.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, abilityscore.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, abilityscore.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, abilityscore.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, abilityscore.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, abilityscore.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, abilityscore.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, abilityscore.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, abilityscore.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, abilityscore.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, abilityscore.NameContainsFold(*i.NameContainsFold))
	}
	if i.FullName != nil {
		predicates = append(predicates, abilityscore.FullNameEQ(*i.FullName))
	}
	if i.FullNameNEQ != nil {
		predicates = append(predicates, abilityscore.FullNameNEQ(*i.FullNameNEQ))
	}
	if len(i.FullNameIn) > 0 {
		predicates = append(predicates, abilityscore.FullNameIn(i.FullNameIn...))
	}
	if len(i.FullNameNotIn) > 0 {
		predicates = append(predicates, abilityscore.FullNameNotIn(i.FullNameNotIn...))
	}
	if i.FullNameGT != nil {
		predicates = append(predicates, abilityscore.FullNameGT(*i.FullNameGT))
	}
	if i.FullNameGTE != nil {
		predicates = append(predicates, abilityscore.FullNameGTE(*i.FullNameGTE))
	}
	if i.FullNameLT != nil {
		predicates = append(predicates, abilityscore.FullNameLT(*i.FullNameLT))
	}
	if i.FullNameLTE != nil {
		predicates = append(predicates, abilityscore.FullNameLTE(*i.FullNameLTE))
	}
	if i.FullNameContains != nil {
		predicates = append(predicates, abilityscore.FullNameContains(*i.FullNameContains))
	}
	if i.FullNameHasPrefix != nil {
		predicates = append(predicates, abilityscore.FullNameHasPrefix(*i.FullNameHasPrefix))
	}
	if i.FullNameHasSuffix != nil {
		predicates = append(predicates, abilityscore.FullNameHasSuffix(*i.FullNameHasSuffix))
	}
	if i.FullNameEqualFold != nil {
		predicates = append(predicates, abilityscore.FullNameEqualFold(*i.FullNameEqualFold))
	}
	if i.FullNameContainsFold != nil {
		predicates = append(predicates, abilityscore.FullNameContainsFold(*i.FullNameContainsFold))
	}

	if i.HasSkills != nil {
		p := abilityscore.HasSkills()
		if !*i.HasSkills {
			p = abilityscore.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSkillsWith) > 0 {
		with := make([]predicate.Skill, 0, len(i.HasSkillsWith))
		for _, w := range i.HasSkillsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSkillsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, abilityscore.HasSkillsWith(with...))
	}
	if i.HasAbilityBonuses != nil {
		p := abilityscore.HasAbilityBonuses()
		if !*i.HasAbilityBonuses {
			p = abilityscore.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAbilityBonusesWith) > 0 {
		with := make([]predicate.AbilityBonus, 0, len(i.HasAbilityBonusesWith))
		for _, w := range i.HasAbilityBonusesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAbilityBonusesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, abilityscore.HasAbilityBonusesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAbilityScoreWhereInput
	case 1:
		return predicates[0], nil
	default:
		return abilityscore.And(predicates...), nil
	}
}

// AlignmentWhereInput represents a where input for filtering Alignment queries.
type AlignmentWhereInput struct {
	Predicates []predicate.Alignment  `json:"-"`
	Not        *AlignmentWhereInput   `json:"not,omitempty"`
	Or         []*AlignmentWhereInput `json:"or,omitempty"`
	And        []*AlignmentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "abbr" field predicates.
	Abbr             *string  `json:"abbr,omitempty"`
	AbbrNEQ          *string  `json:"abbrNEQ,omitempty"`
	AbbrIn           []string `json:"abbrIn,omitempty"`
	AbbrNotIn        []string `json:"abbrNotIn,omitempty"`
	AbbrGT           *string  `json:"abbrGT,omitempty"`
	AbbrGTE          *string  `json:"abbrGTE,omitempty"`
	AbbrLT           *string  `json:"abbrLT,omitempty"`
	AbbrLTE          *string  `json:"abbrLTE,omitempty"`
	AbbrContains     *string  `json:"abbrContains,omitempty"`
	AbbrHasPrefix    *string  `json:"abbrHasPrefix,omitempty"`
	AbbrHasSuffix    *string  `json:"abbrHasSuffix,omitempty"`
	AbbrEqualFold    *string  `json:"abbrEqualFold,omitempty"`
	AbbrContainsFold *string  `json:"abbrContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AlignmentWhereInput) AddPredicates(predicates ...predicate.Alignment) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AlignmentWhereInput filter on the AlignmentQuery builder.
func (i *AlignmentWhereInput) Filter(q *AlignmentQuery) (*AlignmentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAlignmentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAlignmentWhereInput is returned in case the AlignmentWhereInput is empty.
var ErrEmptyAlignmentWhereInput = errors.New("ent: empty predicate AlignmentWhereInput")

// P returns a predicate for filtering alignments.
// An error is returned if the input is empty or invalid.
func (i *AlignmentWhereInput) P() (predicate.Alignment, error) {
	var predicates []predicate.Alignment
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, alignment.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Alignment, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, alignment.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Alignment, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, alignment.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, alignment.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, alignment.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, alignment.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, alignment.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, alignment.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, alignment.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, alignment.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, alignment.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, alignment.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, alignment.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, alignment.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, alignment.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, alignment.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, alignment.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, alignment.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, alignment.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, alignment.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, alignment.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, alignment.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, alignment.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, alignment.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, alignment.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, alignment.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, alignment.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, alignment.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, alignment.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, alignment.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, alignment.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, alignment.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, alignment.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, alignment.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, alignment.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, alignment.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, alignment.NameContainsFold(*i.NameContainsFold))
	}
	if i.Abbr != nil {
		predicates = append(predicates, alignment.AbbrEQ(*i.Abbr))
	}
	if i.AbbrNEQ != nil {
		predicates = append(predicates, alignment.AbbrNEQ(*i.AbbrNEQ))
	}
	if len(i.AbbrIn) > 0 {
		predicates = append(predicates, alignment.AbbrIn(i.AbbrIn...))
	}
	if len(i.AbbrNotIn) > 0 {
		predicates = append(predicates, alignment.AbbrNotIn(i.AbbrNotIn...))
	}
	if i.AbbrGT != nil {
		predicates = append(predicates, alignment.AbbrGT(*i.AbbrGT))
	}
	if i.AbbrGTE != nil {
		predicates = append(predicates, alignment.AbbrGTE(*i.AbbrGTE))
	}
	if i.AbbrLT != nil {
		predicates = append(predicates, alignment.AbbrLT(*i.AbbrLT))
	}
	if i.AbbrLTE != nil {
		predicates = append(predicates, alignment.AbbrLTE(*i.AbbrLTE))
	}
	if i.AbbrContains != nil {
		predicates = append(predicates, alignment.AbbrContains(*i.AbbrContains))
	}
	if i.AbbrHasPrefix != nil {
		predicates = append(predicates, alignment.AbbrHasPrefix(*i.AbbrHasPrefix))
	}
	if i.AbbrHasSuffix != nil {
		predicates = append(predicates, alignment.AbbrHasSuffix(*i.AbbrHasSuffix))
	}
	if i.AbbrEqualFold != nil {
		predicates = append(predicates, alignment.AbbrEqualFold(*i.AbbrEqualFold))
	}
	if i.AbbrContainsFold != nil {
		predicates = append(predicates, alignment.AbbrContainsFold(*i.AbbrContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAlignmentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return alignment.And(predicates...), nil
	}
}

// ArmorWhereInput represents a where input for filtering Armor queries.
type ArmorWhereInput struct {
	Predicates []predicate.Armor  `json:"-"`
	Not        *ArmorWhereInput   `json:"not,omitempty"`
	Or         []*ArmorWhereInput `json:"or,omitempty"`
	And        []*ArmorWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "armor_category" field predicates.
	ArmorCategory      *armor.ArmorCategory  `json:"armorCategory,omitempty"`
	ArmorCategoryNEQ   *armor.ArmorCategory  `json:"armorCategoryNEQ,omitempty"`
	ArmorCategoryIn    []armor.ArmorCategory `json:"armorCategoryIn,omitempty"`
	ArmorCategoryNotIn []armor.ArmorCategory `json:"armorCategoryNotIn,omitempty"`

	// "str_minimum" field predicates.
	StrMinimum      *int  `json:"strMinimum,omitempty"`
	StrMinimumNEQ   *int  `json:"strMinimumNEQ,omitempty"`
	StrMinimumIn    []int `json:"strMinimumIn,omitempty"`
	StrMinimumNotIn []int `json:"strMinimumNotIn,omitempty"`
	StrMinimumGT    *int  `json:"strMinimumGT,omitempty"`
	StrMinimumGTE   *int  `json:"strMinimumGTE,omitempty"`
	StrMinimumLT    *int  `json:"strMinimumLT,omitempty"`
	StrMinimumLTE   *int  `json:"strMinimumLTE,omitempty"`

	// "stealth_disadvantage" field predicates.
	StealthDisadvantage    *bool `json:"stealthDisadvantage,omitempty"`
	StealthDisadvantageNEQ *bool `json:"stealthDisadvantageNEQ,omitempty"`

	// "armor_class" edge predicates.
	HasArmorClass     *bool                   `json:"hasArmorClass,omitempty"`
	HasArmorClassWith []*ArmorClassWhereInput `json:"hasArmorClassWith,omitempty"`

	// "equipment" edge predicates.
	HasEquipment     *bool                  `json:"hasEquipment,omitempty"`
	HasEquipmentWith []*EquipmentWhereInput `json:"hasEquipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArmorWhereInput) AddPredicates(predicates ...predicate.Armor) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArmorWhereInput filter on the ArmorQuery builder.
func (i *ArmorWhereInput) Filter(q *ArmorQuery) (*ArmorQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArmorWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArmorWhereInput is returned in case the ArmorWhereInput is empty.
var ErrEmptyArmorWhereInput = errors.New("ent: empty predicate ArmorWhereInput")

// P returns a predicate for filtering armors.
// An error is returned if the input is empty or invalid.
func (i *ArmorWhereInput) P() (predicate.Armor, error) {
	var predicates []predicate.Armor
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, armor.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Armor, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, armor.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Armor, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, armor.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, armor.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, armor.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, armor.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, armor.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, armor.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, armor.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, armor.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, armor.IDLTE(*i.IDLTE))
	}
	if i.ArmorCategory != nil {
		predicates = append(predicates, armor.ArmorCategoryEQ(*i.ArmorCategory))
	}
	if i.ArmorCategoryNEQ != nil {
		predicates = append(predicates, armor.ArmorCategoryNEQ(*i.ArmorCategoryNEQ))
	}
	if len(i.ArmorCategoryIn) > 0 {
		predicates = append(predicates, armor.ArmorCategoryIn(i.ArmorCategoryIn...))
	}
	if len(i.ArmorCategoryNotIn) > 0 {
		predicates = append(predicates, armor.ArmorCategoryNotIn(i.ArmorCategoryNotIn...))
	}
	if i.StrMinimum != nil {
		predicates = append(predicates, armor.StrMinimumEQ(*i.StrMinimum))
	}
	if i.StrMinimumNEQ != nil {
		predicates = append(predicates, armor.StrMinimumNEQ(*i.StrMinimumNEQ))
	}
	if len(i.StrMinimumIn) > 0 {
		predicates = append(predicates, armor.StrMinimumIn(i.StrMinimumIn...))
	}
	if len(i.StrMinimumNotIn) > 0 {
		predicates = append(predicates, armor.StrMinimumNotIn(i.StrMinimumNotIn...))
	}
	if i.StrMinimumGT != nil {
		predicates = append(predicates, armor.StrMinimumGT(*i.StrMinimumGT))
	}
	if i.StrMinimumGTE != nil {
		predicates = append(predicates, armor.StrMinimumGTE(*i.StrMinimumGTE))
	}
	if i.StrMinimumLT != nil {
		predicates = append(predicates, armor.StrMinimumLT(*i.StrMinimumLT))
	}
	if i.StrMinimumLTE != nil {
		predicates = append(predicates, armor.StrMinimumLTE(*i.StrMinimumLTE))
	}
	if i.StealthDisadvantage != nil {
		predicates = append(predicates, armor.StealthDisadvantageEQ(*i.StealthDisadvantage))
	}
	if i.StealthDisadvantageNEQ != nil {
		predicates = append(predicates, armor.StealthDisadvantageNEQ(*i.StealthDisadvantageNEQ))
	}

	if i.HasArmorClass != nil {
		p := armor.HasArmorClass()
		if !*i.HasArmorClass {
			p = armor.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArmorClassWith) > 0 {
		with := make([]predicate.ArmorClass, 0, len(i.HasArmorClassWith))
		for _, w := range i.HasArmorClassWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArmorClassWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, armor.HasArmorClassWith(with...))
	}
	if i.HasEquipment != nil {
		p := armor.HasEquipment()
		if !*i.HasEquipment {
			p = armor.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentWith))
		for _, w := range i.HasEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, armor.HasEquipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArmorWhereInput
	case 1:
		return predicates[0], nil
	default:
		return armor.And(predicates...), nil
	}
}

// ArmorClassWhereInput represents a where input for filtering ArmorClass queries.
type ArmorClassWhereInput struct {
	Predicates []predicate.ArmorClass  `json:"-"`
	Not        *ArmorClassWhereInput   `json:"not,omitempty"`
	Or         []*ArmorClassWhereInput `json:"or,omitempty"`
	And        []*ArmorClassWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "base" field predicates.
	Base      *int  `json:"base,omitempty"`
	BaseNEQ   *int  `json:"baseNEQ,omitempty"`
	BaseIn    []int `json:"baseIn,omitempty"`
	BaseNotIn []int `json:"baseNotIn,omitempty"`
	BaseGT    *int  `json:"baseGT,omitempty"`
	BaseGTE   *int  `json:"baseGTE,omitempty"`
	BaseLT    *int  `json:"baseLT,omitempty"`
	BaseLTE   *int  `json:"baseLTE,omitempty"`

	// "dex_bonus" field predicates.
	DexBonus    *bool `json:"dexBonus,omitempty"`
	DexBonusNEQ *bool `json:"dexBonusNEQ,omitempty"`

	// "armor" edge predicates.
	HasArmor     *bool              `json:"hasArmor,omitempty"`
	HasArmorWith []*ArmorWhereInput `json:"hasArmorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArmorClassWhereInput) AddPredicates(predicates ...predicate.ArmorClass) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArmorClassWhereInput filter on the ArmorClassQuery builder.
func (i *ArmorClassWhereInput) Filter(q *ArmorClassQuery) (*ArmorClassQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArmorClassWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArmorClassWhereInput is returned in case the ArmorClassWhereInput is empty.
var ErrEmptyArmorClassWhereInput = errors.New("ent: empty predicate ArmorClassWhereInput")

// P returns a predicate for filtering armorclasses.
// An error is returned if the input is empty or invalid.
func (i *ArmorClassWhereInput) P() (predicate.ArmorClass, error) {
	var predicates []predicate.ArmorClass
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, armorclass.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ArmorClass, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, armorclass.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ArmorClass, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, armorclass.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, armorclass.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, armorclass.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, armorclass.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, armorclass.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, armorclass.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, armorclass.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, armorclass.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, armorclass.IDLTE(*i.IDLTE))
	}
	if i.Base != nil {
		predicates = append(predicates, armorclass.BaseEQ(*i.Base))
	}
	if i.BaseNEQ != nil {
		predicates = append(predicates, armorclass.BaseNEQ(*i.BaseNEQ))
	}
	if len(i.BaseIn) > 0 {
		predicates = append(predicates, armorclass.BaseIn(i.BaseIn...))
	}
	if len(i.BaseNotIn) > 0 {
		predicates = append(predicates, armorclass.BaseNotIn(i.BaseNotIn...))
	}
	if i.BaseGT != nil {
		predicates = append(predicates, armorclass.BaseGT(*i.BaseGT))
	}
	if i.BaseGTE != nil {
		predicates = append(predicates, armorclass.BaseGTE(*i.BaseGTE))
	}
	if i.BaseLT != nil {
		predicates = append(predicates, armorclass.BaseLT(*i.BaseLT))
	}
	if i.BaseLTE != nil {
		predicates = append(predicates, armorclass.BaseLTE(*i.BaseLTE))
	}
	if i.DexBonus != nil {
		predicates = append(predicates, armorclass.DexBonusEQ(*i.DexBonus))
	}
	if i.DexBonusNEQ != nil {
		predicates = append(predicates, armorclass.DexBonusNEQ(*i.DexBonusNEQ))
	}

	if i.HasArmor != nil {
		p := armorclass.HasArmor()
		if !*i.HasArmor {
			p = armorclass.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArmorWith) > 0 {
		with := make([]predicate.Armor, 0, len(i.HasArmorWith))
		for _, w := range i.HasArmorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArmorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, armorclass.HasArmorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArmorClassWhereInput
	case 1:
		return predicates[0], nil
	default:
		return armorclass.And(predicates...), nil
	}
}

// ClassWhereInput represents a where input for filtering Class queries.
type ClassWhereInput struct {
	Predicates []predicate.Class  `json:"-"`
	Not        *ClassWhereInput   `json:"not,omitempty"`
	Or         []*ClassWhereInput `json:"or,omitempty"`
	And        []*ClassWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "hit_die" field predicates.
	HitDie      *int  `json:"hitDie,omitempty"`
	HitDieNEQ   *int  `json:"hitDieNEQ,omitempty"`
	HitDieIn    []int `json:"hitDieIn,omitempty"`
	HitDieNotIn []int `json:"hitDieNotIn,omitempty"`
	HitDieGT    *int  `json:"hitDieGT,omitempty"`
	HitDieGTE   *int  `json:"hitDieGTE,omitempty"`
	HitDieLT    *int  `json:"hitDieLT,omitempty"`
	HitDieLTE   *int  `json:"hitDieLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ClassWhereInput) AddPredicates(predicates ...predicate.Class) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ClassWhereInput filter on the ClassQuery builder.
func (i *ClassWhereInput) Filter(q *ClassQuery) (*ClassQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyClassWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyClassWhereInput is returned in case the ClassWhereInput is empty.
var ErrEmptyClassWhereInput = errors.New("ent: empty predicate ClassWhereInput")

// P returns a predicate for filtering classes.
// An error is returned if the input is empty or invalid.
func (i *ClassWhereInput) P() (predicate.Class, error) {
	var predicates []predicate.Class
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, class.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Class, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, class.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Class, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, class.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, class.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, class.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, class.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, class.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, class.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, class.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, class.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, class.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, class.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, class.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, class.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, class.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, class.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, class.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, class.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, class.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, class.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, class.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, class.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, class.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, class.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, class.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, class.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, class.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, class.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, class.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, class.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, class.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, class.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, class.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, class.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, class.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, class.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, class.NameContainsFold(*i.NameContainsFold))
	}
	if i.HitDie != nil {
		predicates = append(predicates, class.HitDieEQ(*i.HitDie))
	}
	if i.HitDieNEQ != nil {
		predicates = append(predicates, class.HitDieNEQ(*i.HitDieNEQ))
	}
	if len(i.HitDieIn) > 0 {
		predicates = append(predicates, class.HitDieIn(i.HitDieIn...))
	}
	if len(i.HitDieNotIn) > 0 {
		predicates = append(predicates, class.HitDieNotIn(i.HitDieNotIn...))
	}
	if i.HitDieGT != nil {
		predicates = append(predicates, class.HitDieGT(*i.HitDieGT))
	}
	if i.HitDieGTE != nil {
		predicates = append(predicates, class.HitDieGTE(*i.HitDieGTE))
	}
	if i.HitDieLT != nil {
		predicates = append(predicates, class.HitDieLT(*i.HitDieLT))
	}
	if i.HitDieLTE != nil {
		predicates = append(predicates, class.HitDieLTE(*i.HitDieLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyClassWhereInput
	case 1:
		return predicates[0], nil
	default:
		return class.And(predicates...), nil
	}
}

// CoinWhereInput represents a where input for filtering Coin queries.
type CoinWhereInput struct {
	Predicates []predicate.Coin  `json:"-"`
	Not        *CoinWhereInput   `json:"not,omitempty"`
	Or         []*CoinWhereInput `json:"or,omitempty"`
	And        []*CoinWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "gold_conversion_rate" field predicates.
	GoldConversionRate      *float64  `json:"goldConversionRate,omitempty"`
	GoldConversionRateNEQ   *float64  `json:"goldConversionRateNEQ,omitempty"`
	GoldConversionRateIn    []float64 `json:"goldConversionRateIn,omitempty"`
	GoldConversionRateNotIn []float64 `json:"goldConversionRateNotIn,omitempty"`
	GoldConversionRateGT    *float64  `json:"goldConversionRateGT,omitempty"`
	GoldConversionRateGTE   *float64  `json:"goldConversionRateGTE,omitempty"`
	GoldConversionRateLT    *float64  `json:"goldConversionRateLT,omitempty"`
	GoldConversionRateLTE   *float64  `json:"goldConversionRateLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CoinWhereInput) AddPredicates(predicates ...predicate.Coin) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CoinWhereInput filter on the CoinQuery builder.
func (i *CoinWhereInput) Filter(q *CoinQuery) (*CoinQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCoinWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCoinWhereInput is returned in case the CoinWhereInput is empty.
var ErrEmptyCoinWhereInput = errors.New("ent: empty predicate CoinWhereInput")

// P returns a predicate for filtering coins.
// An error is returned if the input is empty or invalid.
func (i *CoinWhereInput) P() (predicate.Coin, error) {
	var predicates []predicate.Coin
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, coin.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Coin, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, coin.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Coin, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, coin.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, coin.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, coin.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, coin.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, coin.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, coin.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, coin.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, coin.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, coin.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, coin.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, coin.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, coin.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, coin.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, coin.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, coin.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, coin.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, coin.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, coin.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, coin.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, coin.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, coin.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, coin.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, coin.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, coin.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, coin.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, coin.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, coin.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, coin.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, coin.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, coin.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, coin.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, coin.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, coin.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, coin.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, coin.NameContainsFold(*i.NameContainsFold))
	}
	if i.GoldConversionRate != nil {
		predicates = append(predicates, coin.GoldConversionRateEQ(*i.GoldConversionRate))
	}
	if i.GoldConversionRateNEQ != nil {
		predicates = append(predicates, coin.GoldConversionRateNEQ(*i.GoldConversionRateNEQ))
	}
	if len(i.GoldConversionRateIn) > 0 {
		predicates = append(predicates, coin.GoldConversionRateIn(i.GoldConversionRateIn...))
	}
	if len(i.GoldConversionRateNotIn) > 0 {
		predicates = append(predicates, coin.GoldConversionRateNotIn(i.GoldConversionRateNotIn...))
	}
	if i.GoldConversionRateGT != nil {
		predicates = append(predicates, coin.GoldConversionRateGT(*i.GoldConversionRateGT))
	}
	if i.GoldConversionRateGTE != nil {
		predicates = append(predicates, coin.GoldConversionRateGTE(*i.GoldConversionRateGTE))
	}
	if i.GoldConversionRateLT != nil {
		predicates = append(predicates, coin.GoldConversionRateLT(*i.GoldConversionRateLT))
	}
	if i.GoldConversionRateLTE != nil {
		predicates = append(predicates, coin.GoldConversionRateLTE(*i.GoldConversionRateLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCoinWhereInput
	case 1:
		return predicates[0], nil
	default:
		return coin.And(predicates...), nil
	}
}

// ConditionWhereInput represents a where input for filtering Condition queries.
type ConditionWhereInput struct {
	Predicates []predicate.Condition  `json:"-"`
	Not        *ConditionWhereInput   `json:"not,omitempty"`
	Or         []*ConditionWhereInput `json:"or,omitempty"`
	And        []*ConditionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ConditionWhereInput) AddPredicates(predicates ...predicate.Condition) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ConditionWhereInput filter on the ConditionQuery builder.
func (i *ConditionWhereInput) Filter(q *ConditionQuery) (*ConditionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyConditionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyConditionWhereInput is returned in case the ConditionWhereInput is empty.
var ErrEmptyConditionWhereInput = errors.New("ent: empty predicate ConditionWhereInput")

// P returns a predicate for filtering conditions.
// An error is returned if the input is empty or invalid.
func (i *ConditionWhereInput) P() (predicate.Condition, error) {
	var predicates []predicate.Condition
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, condition.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Condition, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, condition.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Condition, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, condition.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, condition.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, condition.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, condition.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, condition.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, condition.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, condition.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, condition.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, condition.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, condition.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, condition.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, condition.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, condition.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, condition.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, condition.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, condition.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, condition.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, condition.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, condition.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, condition.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, condition.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, condition.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, condition.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, condition.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, condition.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, condition.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, condition.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, condition.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, condition.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, condition.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, condition.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, condition.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, condition.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, condition.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, condition.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyConditionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return condition.And(predicates...), nil
	}
}

// CostWhereInput represents a where input for filtering Cost queries.
type CostWhereInput struct {
	Predicates []predicate.Cost  `json:"-"`
	Not        *CostWhereInput   `json:"not,omitempty"`
	Or         []*CostWhereInput `json:"or,omitempty"`
	And        []*CostWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "quantity" field predicates.
	Quantity      *int  `json:"quantity,omitempty"`
	QuantityNEQ   *int  `json:"quantityNEQ,omitempty"`
	QuantityIn    []int `json:"quantityIn,omitempty"`
	QuantityNotIn []int `json:"quantityNotIn,omitempty"`
	QuantityGT    *int  `json:"quantityGT,omitempty"`
	QuantityGTE   *int  `json:"quantityGTE,omitempty"`
	QuantityLT    *int  `json:"quantityLT,omitempty"`
	QuantityLTE   *int  `json:"quantityLTE,omitempty"`

	// "coin" edge predicates.
	HasCoin     *bool             `json:"hasCoin,omitempty"`
	HasCoinWith []*CoinWhereInput `json:"hasCoinWith,omitempty"`

	// "equipment" edge predicates.
	HasEquipment     *bool                  `json:"hasEquipment,omitempty"`
	HasEquipmentWith []*EquipmentWhereInput `json:"hasEquipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CostWhereInput) AddPredicates(predicates ...predicate.Cost) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CostWhereInput filter on the CostQuery builder.
func (i *CostWhereInput) Filter(q *CostQuery) (*CostQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCostWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCostWhereInput is returned in case the CostWhereInput is empty.
var ErrEmptyCostWhereInput = errors.New("ent: empty predicate CostWhereInput")

// P returns a predicate for filtering costs.
// An error is returned if the input is empty or invalid.
func (i *CostWhereInput) P() (predicate.Cost, error) {
	var predicates []predicate.Cost
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, cost.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Cost, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, cost.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Cost, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, cost.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, cost.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, cost.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, cost.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, cost.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, cost.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, cost.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, cost.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, cost.IDLTE(*i.IDLTE))
	}
	if i.Quantity != nil {
		predicates = append(predicates, cost.QuantityEQ(*i.Quantity))
	}
	if i.QuantityNEQ != nil {
		predicates = append(predicates, cost.QuantityNEQ(*i.QuantityNEQ))
	}
	if len(i.QuantityIn) > 0 {
		predicates = append(predicates, cost.QuantityIn(i.QuantityIn...))
	}
	if len(i.QuantityNotIn) > 0 {
		predicates = append(predicates, cost.QuantityNotIn(i.QuantityNotIn...))
	}
	if i.QuantityGT != nil {
		predicates = append(predicates, cost.QuantityGT(*i.QuantityGT))
	}
	if i.QuantityGTE != nil {
		predicates = append(predicates, cost.QuantityGTE(*i.QuantityGTE))
	}
	if i.QuantityLT != nil {
		predicates = append(predicates, cost.QuantityLT(*i.QuantityLT))
	}
	if i.QuantityLTE != nil {
		predicates = append(predicates, cost.QuantityLTE(*i.QuantityLTE))
	}

	if i.HasCoin != nil {
		p := cost.HasCoin()
		if !*i.HasCoin {
			p = cost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCoinWith) > 0 {
		with := make([]predicate.Coin, 0, len(i.HasCoinWith))
		for _, w := range i.HasCoinWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCoinWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, cost.HasCoinWith(with...))
	}
	if i.HasEquipment != nil {
		p := cost.HasEquipment()
		if !*i.HasEquipment {
			p = cost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentWith))
		for _, w := range i.HasEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, cost.HasEquipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCostWhereInput
	case 1:
		return predicates[0], nil
	default:
		return cost.And(predicates...), nil
	}
}

// DamageWhereInput represents a where input for filtering Damage queries.
type DamageWhereInput struct {
	Predicates []predicate.Damage  `json:"-"`
	Not        *DamageWhereInput   `json:"not,omitempty"`
	Or         []*DamageWhereInput `json:"or,omitempty"`
	And        []*DamageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "damage_dice" field predicates.
	DamageDice             *string  `json:"damageDice,omitempty"`
	DamageDiceNEQ          *string  `json:"damageDiceNEQ,omitempty"`
	DamageDiceIn           []string `json:"damageDiceIn,omitempty"`
	DamageDiceNotIn        []string `json:"damageDiceNotIn,omitempty"`
	DamageDiceGT           *string  `json:"damageDiceGT,omitempty"`
	DamageDiceGTE          *string  `json:"damageDiceGTE,omitempty"`
	DamageDiceLT           *string  `json:"damageDiceLT,omitempty"`
	DamageDiceLTE          *string  `json:"damageDiceLTE,omitempty"`
	DamageDiceContains     *string  `json:"damageDiceContains,omitempty"`
	DamageDiceHasPrefix    *string  `json:"damageDiceHasPrefix,omitempty"`
	DamageDiceHasSuffix    *string  `json:"damageDiceHasSuffix,omitempty"`
	DamageDiceEqualFold    *string  `json:"damageDiceEqualFold,omitempty"`
	DamageDiceContainsFold *string  `json:"damageDiceContainsFold,omitempty"`

	// "damage_type" edge predicates.
	HasDamageType     *bool                   `json:"hasDamageType,omitempty"`
	HasDamageTypeWith []*DamageTypeWhereInput `json:"hasDamageTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DamageWhereInput) AddPredicates(predicates ...predicate.Damage) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DamageWhereInput filter on the DamageQuery builder.
func (i *DamageWhereInput) Filter(q *DamageQuery) (*DamageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDamageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDamageWhereInput is returned in case the DamageWhereInput is empty.
var ErrEmptyDamageWhereInput = errors.New("ent: empty predicate DamageWhereInput")

// P returns a predicate for filtering damages.
// An error is returned if the input is empty or invalid.
func (i *DamageWhereInput) P() (predicate.Damage, error) {
	var predicates []predicate.Damage
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, damage.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Damage, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, damage.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Damage, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, damage.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, damage.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, damage.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, damage.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, damage.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, damage.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, damage.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, damage.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, damage.IDLTE(*i.IDLTE))
	}
	if i.DamageDice != nil {
		predicates = append(predicates, damage.DamageDiceEQ(*i.DamageDice))
	}
	if i.DamageDiceNEQ != nil {
		predicates = append(predicates, damage.DamageDiceNEQ(*i.DamageDiceNEQ))
	}
	if len(i.DamageDiceIn) > 0 {
		predicates = append(predicates, damage.DamageDiceIn(i.DamageDiceIn...))
	}
	if len(i.DamageDiceNotIn) > 0 {
		predicates = append(predicates, damage.DamageDiceNotIn(i.DamageDiceNotIn...))
	}
	if i.DamageDiceGT != nil {
		predicates = append(predicates, damage.DamageDiceGT(*i.DamageDiceGT))
	}
	if i.DamageDiceGTE != nil {
		predicates = append(predicates, damage.DamageDiceGTE(*i.DamageDiceGTE))
	}
	if i.DamageDiceLT != nil {
		predicates = append(predicates, damage.DamageDiceLT(*i.DamageDiceLT))
	}
	if i.DamageDiceLTE != nil {
		predicates = append(predicates, damage.DamageDiceLTE(*i.DamageDiceLTE))
	}
	if i.DamageDiceContains != nil {
		predicates = append(predicates, damage.DamageDiceContains(*i.DamageDiceContains))
	}
	if i.DamageDiceHasPrefix != nil {
		predicates = append(predicates, damage.DamageDiceHasPrefix(*i.DamageDiceHasPrefix))
	}
	if i.DamageDiceHasSuffix != nil {
		predicates = append(predicates, damage.DamageDiceHasSuffix(*i.DamageDiceHasSuffix))
	}
	if i.DamageDiceEqualFold != nil {
		predicates = append(predicates, damage.DamageDiceEqualFold(*i.DamageDiceEqualFold))
	}
	if i.DamageDiceContainsFold != nil {
		predicates = append(predicates, damage.DamageDiceContainsFold(*i.DamageDiceContainsFold))
	}

	if i.HasDamageType != nil {
		p := damage.HasDamageType()
		if !*i.HasDamageType {
			p = damage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDamageTypeWith) > 0 {
		with := make([]predicate.DamageType, 0, len(i.HasDamageTypeWith))
		for _, w := range i.HasDamageTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDamageTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, damage.HasDamageTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDamageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return damage.And(predicates...), nil
	}
}

// DamageTypeWhereInput represents a where input for filtering DamageType queries.
type DamageTypeWhereInput struct {
	Predicates []predicate.DamageType  `json:"-"`
	Not        *DamageTypeWhereInput   `json:"not,omitempty"`
	Or         []*DamageTypeWhereInput `json:"or,omitempty"`
	And        []*DamageTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DamageTypeWhereInput) AddPredicates(predicates ...predicate.DamageType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DamageTypeWhereInput filter on the DamageTypeQuery builder.
func (i *DamageTypeWhereInput) Filter(q *DamageTypeQuery) (*DamageTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDamageTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDamageTypeWhereInput is returned in case the DamageTypeWhereInput is empty.
var ErrEmptyDamageTypeWhereInput = errors.New("ent: empty predicate DamageTypeWhereInput")

// P returns a predicate for filtering damagetypes.
// An error is returned if the input is empty or invalid.
func (i *DamageTypeWhereInput) P() (predicate.DamageType, error) {
	var predicates []predicate.DamageType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, damagetype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DamageType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, damagetype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DamageType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, damagetype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, damagetype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, damagetype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, damagetype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, damagetype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, damagetype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, damagetype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, damagetype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, damagetype.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, damagetype.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, damagetype.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, damagetype.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, damagetype.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, damagetype.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, damagetype.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, damagetype.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, damagetype.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, damagetype.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, damagetype.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, damagetype.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, damagetype.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, damagetype.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, damagetype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, damagetype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, damagetype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, damagetype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, damagetype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, damagetype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, damagetype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, damagetype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, damagetype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, damagetype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, damagetype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, damagetype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, damagetype.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDamageTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return damagetype.And(predicates...), nil
	}
}

// EquipmentWhereInput represents a where input for filtering Equipment queries.
type EquipmentWhereInput struct {
	Predicates []predicate.Equipment  `json:"-"`
	Not        *EquipmentWhereInput   `json:"not,omitempty"`
	Or         []*EquipmentWhereInput `json:"or,omitempty"`
	And        []*EquipmentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "equipment_category" field predicates.
	EquipmentCategory      *equipment.EquipmentCategory  `json:"equipmentCategory,omitempty"`
	EquipmentCategoryNEQ   *equipment.EquipmentCategory  `json:"equipmentCategoryNEQ,omitempty"`
	EquipmentCategoryIn    []equipment.EquipmentCategory `json:"equipmentCategoryIn,omitempty"`
	EquipmentCategoryNotIn []equipment.EquipmentCategory `json:"equipmentCategoryNotIn,omitempty"`

	// "weight" field predicates.
	Weight       *float64  `json:"weight,omitempty"`
	WeightNEQ    *float64  `json:"weightNEQ,omitempty"`
	WeightIn     []float64 `json:"weightIn,omitempty"`
	WeightNotIn  []float64 `json:"weightNotIn,omitempty"`
	WeightGT     *float64  `json:"weightGT,omitempty"`
	WeightGTE    *float64  `json:"weightGTE,omitempty"`
	WeightLT     *float64  `json:"weightLT,omitempty"`
	WeightLTE    *float64  `json:"weightLTE,omitempty"`
	WeightIsNil  bool      `json:"weightIsNil,omitempty"`
	WeightNotNil bool      `json:"weightNotNil,omitempty"`

	// "cost" edge predicates.
	HasCost     *bool             `json:"hasCost,omitempty"`
	HasCostWith []*CostWhereInput `json:"hasCostWith,omitempty"`

	// "gear" edge predicates.
	HasGear     *bool             `json:"hasGear,omitempty"`
	HasGearWith []*GearWhereInput `json:"hasGearWith,omitempty"`

	// "tool" edge predicates.
	HasTool     *bool             `json:"hasTool,omitempty"`
	HasToolWith []*ToolWhereInput `json:"hasToolWith,omitempty"`

	// "weapon" edge predicates.
	HasWeapon     *bool               `json:"hasWeapon,omitempty"`
	HasWeaponWith []*WeaponWhereInput `json:"hasWeaponWith,omitempty"`

	// "vehicle" edge predicates.
	HasVehicle     *bool                `json:"hasVehicle,omitempty"`
	HasVehicleWith []*VehicleWhereInput `json:"hasVehicleWith,omitempty"`

	// "armor" edge predicates.
	HasArmor     *bool              `json:"hasArmor,omitempty"`
	HasArmorWith []*ArmorWhereInput `json:"hasArmorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EquipmentWhereInput) AddPredicates(predicates ...predicate.Equipment) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EquipmentWhereInput filter on the EquipmentQuery builder.
func (i *EquipmentWhereInput) Filter(q *EquipmentQuery) (*EquipmentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEquipmentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEquipmentWhereInput is returned in case the EquipmentWhereInput is empty.
var ErrEmptyEquipmentWhereInput = errors.New("ent: empty predicate EquipmentWhereInput")

// P returns a predicate for filtering equipmentslice.
// An error is returned if the input is empty or invalid.
func (i *EquipmentWhereInput) P() (predicate.Equipment, error) {
	var predicates []predicate.Equipment
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, equipment.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Equipment, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, equipment.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Equipment, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, equipment.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, equipment.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, equipment.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, equipment.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, equipment.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, equipment.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, equipment.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, equipment.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, equipment.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, equipment.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, equipment.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, equipment.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, equipment.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, equipment.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, equipment.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, equipment.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, equipment.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, equipment.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, equipment.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, equipment.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, equipment.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, equipment.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, equipment.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, equipment.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, equipment.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, equipment.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, equipment.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, equipment.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, equipment.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, equipment.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, equipment.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, equipment.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, equipment.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, equipment.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, equipment.NameContainsFold(*i.NameContainsFold))
	}
	if i.EquipmentCategory != nil {
		predicates = append(predicates, equipment.EquipmentCategoryEQ(*i.EquipmentCategory))
	}
	if i.EquipmentCategoryNEQ != nil {
		predicates = append(predicates, equipment.EquipmentCategoryNEQ(*i.EquipmentCategoryNEQ))
	}
	if len(i.EquipmentCategoryIn) > 0 {
		predicates = append(predicates, equipment.EquipmentCategoryIn(i.EquipmentCategoryIn...))
	}
	if len(i.EquipmentCategoryNotIn) > 0 {
		predicates = append(predicates, equipment.EquipmentCategoryNotIn(i.EquipmentCategoryNotIn...))
	}
	if i.Weight != nil {
		predicates = append(predicates, equipment.WeightEQ(*i.Weight))
	}
	if i.WeightNEQ != nil {
		predicates = append(predicates, equipment.WeightNEQ(*i.WeightNEQ))
	}
	if len(i.WeightIn) > 0 {
		predicates = append(predicates, equipment.WeightIn(i.WeightIn...))
	}
	if len(i.WeightNotIn) > 0 {
		predicates = append(predicates, equipment.WeightNotIn(i.WeightNotIn...))
	}
	if i.WeightGT != nil {
		predicates = append(predicates, equipment.WeightGT(*i.WeightGT))
	}
	if i.WeightGTE != nil {
		predicates = append(predicates, equipment.WeightGTE(*i.WeightGTE))
	}
	if i.WeightLT != nil {
		predicates = append(predicates, equipment.WeightLT(*i.WeightLT))
	}
	if i.WeightLTE != nil {
		predicates = append(predicates, equipment.WeightLTE(*i.WeightLTE))
	}
	if i.WeightIsNil {
		predicates = append(predicates, equipment.WeightIsNil())
	}
	if i.WeightNotNil {
		predicates = append(predicates, equipment.WeightNotNil())
	}

	if i.HasCost != nil {
		p := equipment.HasCost()
		if !*i.HasCost {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCostWith) > 0 {
		with := make([]predicate.Cost, 0, len(i.HasCostWith))
		for _, w := range i.HasCostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasCostWith(with...))
	}
	if i.HasGear != nil {
		p := equipment.HasGear()
		if !*i.HasGear {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGearWith) > 0 {
		with := make([]predicate.Gear, 0, len(i.HasGearWith))
		for _, w := range i.HasGearWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGearWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasGearWith(with...))
	}
	if i.HasTool != nil {
		p := equipment.HasTool()
		if !*i.HasTool {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasToolWith) > 0 {
		with := make([]predicate.Tool, 0, len(i.HasToolWith))
		for _, w := range i.HasToolWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasToolWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasToolWith(with...))
	}
	if i.HasWeapon != nil {
		p := equipment.HasWeapon()
		if !*i.HasWeapon {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWeaponWith) > 0 {
		with := make([]predicate.Weapon, 0, len(i.HasWeaponWith))
		for _, w := range i.HasWeaponWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWeaponWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasWeaponWith(with...))
	}
	if i.HasVehicle != nil {
		p := equipment.HasVehicle()
		if !*i.HasVehicle {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehicleWith) > 0 {
		with := make([]predicate.Vehicle, 0, len(i.HasVehicleWith))
		for _, w := range i.HasVehicleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVehicleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasVehicleWith(with...))
	}
	if i.HasArmor != nil {
		p := equipment.HasArmor()
		if !*i.HasArmor {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArmorWith) > 0 {
		with := make([]predicate.Armor, 0, len(i.HasArmorWith))
		for _, w := range i.HasArmorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArmorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasArmorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEquipmentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return equipment.And(predicates...), nil
	}
}

// FeatWhereInput represents a where input for filtering Feat queries.
type FeatWhereInput struct {
	Predicates []predicate.Feat  `json:"-"`
	Not        *FeatWhereInput   `json:"not,omitempty"`
	Or         []*FeatWhereInput `json:"or,omitempty"`
	And        []*FeatWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FeatWhereInput) AddPredicates(predicates ...predicate.Feat) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FeatWhereInput filter on the FeatQuery builder.
func (i *FeatWhereInput) Filter(q *FeatQuery) (*FeatQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFeatWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFeatWhereInput is returned in case the FeatWhereInput is empty.
var ErrEmptyFeatWhereInput = errors.New("ent: empty predicate FeatWhereInput")

// P returns a predicate for filtering feats.
// An error is returned if the input is empty or invalid.
func (i *FeatWhereInput) P() (predicate.Feat, error) {
	var predicates []predicate.Feat
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, feat.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Feat, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, feat.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Feat, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, feat.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, feat.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, feat.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, feat.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, feat.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, feat.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, feat.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, feat.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, feat.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, feat.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, feat.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, feat.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, feat.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, feat.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, feat.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, feat.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, feat.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, feat.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, feat.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, feat.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, feat.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, feat.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, feat.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, feat.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, feat.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, feat.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, feat.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, feat.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, feat.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, feat.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, feat.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, feat.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, feat.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, feat.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, feat.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFeatWhereInput
	case 1:
		return predicates[0], nil
	default:
		return feat.And(predicates...), nil
	}
}

// GearWhereInput represents a where input for filtering Gear queries.
type GearWhereInput struct {
	Predicates []predicate.Gear  `json:"-"`
	Not        *GearWhereInput   `json:"not,omitempty"`
	Or         []*GearWhereInput `json:"or,omitempty"`
	And        []*GearWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "gear_category" field predicates.
	GearCategory             *string  `json:"gearCategory,omitempty"`
	GearCategoryNEQ          *string  `json:"gearCategoryNEQ,omitempty"`
	GearCategoryIn           []string `json:"gearCategoryIn,omitempty"`
	GearCategoryNotIn        []string `json:"gearCategoryNotIn,omitempty"`
	GearCategoryGT           *string  `json:"gearCategoryGT,omitempty"`
	GearCategoryGTE          *string  `json:"gearCategoryGTE,omitempty"`
	GearCategoryLT           *string  `json:"gearCategoryLT,omitempty"`
	GearCategoryLTE          *string  `json:"gearCategoryLTE,omitempty"`
	GearCategoryContains     *string  `json:"gearCategoryContains,omitempty"`
	GearCategoryHasPrefix    *string  `json:"gearCategoryHasPrefix,omitempty"`
	GearCategoryHasSuffix    *string  `json:"gearCategoryHasSuffix,omitempty"`
	GearCategoryEqualFold    *string  `json:"gearCategoryEqualFold,omitempty"`
	GearCategoryContainsFold *string  `json:"gearCategoryContainsFold,omitempty"`

	// "equipment" edge predicates.
	HasEquipment     *bool                  `json:"hasEquipment,omitempty"`
	HasEquipmentWith []*EquipmentWhereInput `json:"hasEquipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GearWhereInput) AddPredicates(predicates ...predicate.Gear) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GearWhereInput filter on the GearQuery builder.
func (i *GearWhereInput) Filter(q *GearQuery) (*GearQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGearWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGearWhereInput is returned in case the GearWhereInput is empty.
var ErrEmptyGearWhereInput = errors.New("ent: empty predicate GearWhereInput")

// P returns a predicate for filtering gears.
// An error is returned if the input is empty or invalid.
func (i *GearWhereInput) P() (predicate.Gear, error) {
	var predicates []predicate.Gear
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, gear.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Gear, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, gear.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Gear, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, gear.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, gear.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, gear.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, gear.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, gear.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, gear.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, gear.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, gear.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, gear.IDLTE(*i.IDLTE))
	}
	if i.GearCategory != nil {
		predicates = append(predicates, gear.GearCategoryEQ(*i.GearCategory))
	}
	if i.GearCategoryNEQ != nil {
		predicates = append(predicates, gear.GearCategoryNEQ(*i.GearCategoryNEQ))
	}
	if len(i.GearCategoryIn) > 0 {
		predicates = append(predicates, gear.GearCategoryIn(i.GearCategoryIn...))
	}
	if len(i.GearCategoryNotIn) > 0 {
		predicates = append(predicates, gear.GearCategoryNotIn(i.GearCategoryNotIn...))
	}
	if i.GearCategoryGT != nil {
		predicates = append(predicates, gear.GearCategoryGT(*i.GearCategoryGT))
	}
	if i.GearCategoryGTE != nil {
		predicates = append(predicates, gear.GearCategoryGTE(*i.GearCategoryGTE))
	}
	if i.GearCategoryLT != nil {
		predicates = append(predicates, gear.GearCategoryLT(*i.GearCategoryLT))
	}
	if i.GearCategoryLTE != nil {
		predicates = append(predicates, gear.GearCategoryLTE(*i.GearCategoryLTE))
	}
	if i.GearCategoryContains != nil {
		predicates = append(predicates, gear.GearCategoryContains(*i.GearCategoryContains))
	}
	if i.GearCategoryHasPrefix != nil {
		predicates = append(predicates, gear.GearCategoryHasPrefix(*i.GearCategoryHasPrefix))
	}
	if i.GearCategoryHasSuffix != nil {
		predicates = append(predicates, gear.GearCategoryHasSuffix(*i.GearCategoryHasSuffix))
	}
	if i.GearCategoryEqualFold != nil {
		predicates = append(predicates, gear.GearCategoryEqualFold(*i.GearCategoryEqualFold))
	}
	if i.GearCategoryContainsFold != nil {
		predicates = append(predicates, gear.GearCategoryContainsFold(*i.GearCategoryContainsFold))
	}

	if i.HasEquipment != nil {
		p := gear.HasEquipment()
		if !*i.HasEquipment {
			p = gear.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentWith))
		for _, w := range i.HasEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, gear.HasEquipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGearWhereInput
	case 1:
		return predicates[0], nil
	default:
		return gear.And(predicates...), nil
	}
}

// LanguageWhereInput represents a where input for filtering Language queries.
type LanguageWhereInput struct {
	Predicates []predicate.Language  `json:"-"`
	Not        *LanguageWhereInput   `json:"not,omitempty"`
	Or         []*LanguageWhereInput `json:"or,omitempty"`
	And        []*LanguageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "language_type" field predicates.
	LanguageType      *language.LanguageType  `json:"languageType,omitempty"`
	LanguageTypeNEQ   *language.LanguageType  `json:"languageTypeNEQ,omitempty"`
	LanguageTypeIn    []language.LanguageType `json:"languageTypeIn,omitempty"`
	LanguageTypeNotIn []language.LanguageType `json:"languageTypeNotIn,omitempty"`

	// "script" field predicates.
	Script      *language.Script  `json:"script,omitempty"`
	ScriptNEQ   *language.Script  `json:"scriptNEQ,omitempty"`
	ScriptIn    []language.Script `json:"scriptIn,omitempty"`
	ScriptNotIn []language.Script `json:"scriptNotIn,omitempty"`

	// "races" edge predicates.
	HasRaces     *bool             `json:"hasRaces,omitempty"`
	HasRacesWith []*RaceWhereInput `json:"hasRacesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LanguageWhereInput) AddPredicates(predicates ...predicate.Language) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LanguageWhereInput filter on the LanguageQuery builder.
func (i *LanguageWhereInput) Filter(q *LanguageQuery) (*LanguageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLanguageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLanguageWhereInput is returned in case the LanguageWhereInput is empty.
var ErrEmptyLanguageWhereInput = errors.New("ent: empty predicate LanguageWhereInput")

// P returns a predicate for filtering languages.
// An error is returned if the input is empty or invalid.
func (i *LanguageWhereInput) P() (predicate.Language, error) {
	var predicates []predicate.Language
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, language.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Language, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, language.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Language, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, language.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, language.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, language.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, language.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, language.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, language.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, language.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, language.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, language.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, language.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, language.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, language.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, language.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, language.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, language.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, language.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, language.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, language.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, language.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, language.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, language.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, language.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, language.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, language.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, language.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, language.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, language.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, language.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, language.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, language.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, language.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, language.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, language.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, language.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, language.NameContainsFold(*i.NameContainsFold))
	}
	if i.LanguageType != nil {
		predicates = append(predicates, language.LanguageTypeEQ(*i.LanguageType))
	}
	if i.LanguageTypeNEQ != nil {
		predicates = append(predicates, language.LanguageTypeNEQ(*i.LanguageTypeNEQ))
	}
	if len(i.LanguageTypeIn) > 0 {
		predicates = append(predicates, language.LanguageTypeIn(i.LanguageTypeIn...))
	}
	if len(i.LanguageTypeNotIn) > 0 {
		predicates = append(predicates, language.LanguageTypeNotIn(i.LanguageTypeNotIn...))
	}
	if i.Script != nil {
		predicates = append(predicates, language.ScriptEQ(*i.Script))
	}
	if i.ScriptNEQ != nil {
		predicates = append(predicates, language.ScriptNEQ(*i.ScriptNEQ))
	}
	if len(i.ScriptIn) > 0 {
		predicates = append(predicates, language.ScriptIn(i.ScriptIn...))
	}
	if len(i.ScriptNotIn) > 0 {
		predicates = append(predicates, language.ScriptNotIn(i.ScriptNotIn...))
	}

	if i.HasRaces != nil {
		p := language.HasRaces()
		if !*i.HasRaces {
			p = language.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRacesWith) > 0 {
		with := make([]predicate.Race, 0, len(i.HasRacesWith))
		for _, w := range i.HasRacesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRacesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, language.HasRacesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLanguageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return language.And(predicates...), nil
	}
}

// MagicSchoolWhereInput represents a where input for filtering MagicSchool queries.
type MagicSchoolWhereInput struct {
	Predicates []predicate.MagicSchool  `json:"-"`
	Not        *MagicSchoolWhereInput   `json:"not,omitempty"`
	Or         []*MagicSchoolWhereInput `json:"or,omitempty"`
	And        []*MagicSchoolWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MagicSchoolWhereInput) AddPredicates(predicates ...predicate.MagicSchool) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MagicSchoolWhereInput filter on the MagicSchoolQuery builder.
func (i *MagicSchoolWhereInput) Filter(q *MagicSchoolQuery) (*MagicSchoolQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMagicSchoolWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMagicSchoolWhereInput is returned in case the MagicSchoolWhereInput is empty.
var ErrEmptyMagicSchoolWhereInput = errors.New("ent: empty predicate MagicSchoolWhereInput")

// P returns a predicate for filtering magicschools.
// An error is returned if the input is empty or invalid.
func (i *MagicSchoolWhereInput) P() (predicate.MagicSchool, error) {
	var predicates []predicate.MagicSchool
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, magicschool.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MagicSchool, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, magicschool.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MagicSchool, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, magicschool.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, magicschool.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, magicschool.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, magicschool.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, magicschool.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, magicschool.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, magicschool.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, magicschool.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, magicschool.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, magicschool.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, magicschool.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, magicschool.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, magicschool.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, magicschool.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, magicschool.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, magicschool.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, magicschool.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, magicschool.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, magicschool.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, magicschool.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, magicschool.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, magicschool.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, magicschool.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, magicschool.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, magicschool.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, magicschool.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, magicschool.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, magicschool.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, magicschool.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, magicschool.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, magicschool.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, magicschool.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, magicschool.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, magicschool.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, magicschool.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMagicSchoolWhereInput
	case 1:
		return predicates[0], nil
	default:
		return magicschool.And(predicates...), nil
	}
}

// PropertyWhereInput represents a where input for filtering Property queries.
type PropertyWhereInput struct {
	Predicates []predicate.Property  `json:"-"`
	Not        *PropertyWhereInput   `json:"not,omitempty"`
	Or         []*PropertyWhereInput `json:"or,omitempty"`
	And        []*PropertyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "weapons" edge predicates.
	HasWeapons     *bool               `json:"hasWeapons,omitempty"`
	HasWeaponsWith []*WeaponWhereInput `json:"hasWeaponsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PropertyWhereInput) AddPredicates(predicates ...predicate.Property) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PropertyWhereInput filter on the PropertyQuery builder.
func (i *PropertyWhereInput) Filter(q *PropertyQuery) (*PropertyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPropertyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPropertyWhereInput is returned in case the PropertyWhereInput is empty.
var ErrEmptyPropertyWhereInput = errors.New("ent: empty predicate PropertyWhereInput")

// P returns a predicate for filtering properties.
// An error is returned if the input is empty or invalid.
func (i *PropertyWhereInput) P() (predicate.Property, error) {
	var predicates []predicate.Property
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, property.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Property, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, property.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Property, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, property.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, property.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, property.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, property.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, property.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, property.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, property.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, property.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, property.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, property.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, property.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, property.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, property.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, property.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, property.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, property.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, property.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, property.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, property.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, property.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, property.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, property.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, property.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, property.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, property.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, property.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, property.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, property.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, property.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, property.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, property.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, property.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, property.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, property.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, property.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasWeapons != nil {
		p := property.HasWeapons()
		if !*i.HasWeapons {
			p = property.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWeaponsWith) > 0 {
		with := make([]predicate.Weapon, 0, len(i.HasWeaponsWith))
		for _, w := range i.HasWeaponsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWeaponsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, property.HasWeaponsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPropertyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return property.And(predicates...), nil
	}
}

// RaceWhereInput represents a where input for filtering Race queries.
type RaceWhereInput struct {
	Predicates []predicate.Race  `json:"-"`
	Not        *RaceWhereInput   `json:"not,omitempty"`
	Or         []*RaceWhereInput `json:"or,omitempty"`
	And        []*RaceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "speed" field predicates.
	Speed      *int  `json:"speed,omitempty"`
	SpeedNEQ   *int  `json:"speedNEQ,omitempty"`
	SpeedIn    []int `json:"speedIn,omitempty"`
	SpeedNotIn []int `json:"speedNotIn,omitempty"`
	SpeedGT    *int  `json:"speedGT,omitempty"`
	SpeedGTE   *int  `json:"speedGTE,omitempty"`
	SpeedLT    *int  `json:"speedLT,omitempty"`
	SpeedLTE   *int  `json:"speedLTE,omitempty"`

	// "size" field predicates.
	Size      *race.Size  `json:"size,omitempty"`
	SizeNEQ   *race.Size  `json:"sizeNEQ,omitempty"`
	SizeIn    []race.Size `json:"sizeIn,omitempty"`
	SizeNotIn []race.Size `json:"sizeNotIn,omitempty"`

	// "size_desc" field predicates.
	SizeDesc             *string  `json:"sizeDesc,omitempty"`
	SizeDescNEQ          *string  `json:"sizeDescNEQ,omitempty"`
	SizeDescIn           []string `json:"sizeDescIn,omitempty"`
	SizeDescNotIn        []string `json:"sizeDescNotIn,omitempty"`
	SizeDescGT           *string  `json:"sizeDescGT,omitempty"`
	SizeDescGTE          *string  `json:"sizeDescGTE,omitempty"`
	SizeDescLT           *string  `json:"sizeDescLT,omitempty"`
	SizeDescLTE          *string  `json:"sizeDescLTE,omitempty"`
	SizeDescContains     *string  `json:"sizeDescContains,omitempty"`
	SizeDescHasPrefix    *string  `json:"sizeDescHasPrefix,omitempty"`
	SizeDescHasSuffix    *string  `json:"sizeDescHasSuffix,omitempty"`
	SizeDescEqualFold    *string  `json:"sizeDescEqualFold,omitempty"`
	SizeDescContainsFold *string  `json:"sizeDescContainsFold,omitempty"`

	// "alignment_desc" field predicates.
	AlignmentDesc             *string  `json:"alignmentDesc,omitempty"`
	AlignmentDescNEQ          *string  `json:"alignmentDescNEQ,omitempty"`
	AlignmentDescIn           []string `json:"alignmentDescIn,omitempty"`
	AlignmentDescNotIn        []string `json:"alignmentDescNotIn,omitempty"`
	AlignmentDescGT           *string  `json:"alignmentDescGT,omitempty"`
	AlignmentDescGTE          *string  `json:"alignmentDescGTE,omitempty"`
	AlignmentDescLT           *string  `json:"alignmentDescLT,omitempty"`
	AlignmentDescLTE          *string  `json:"alignmentDescLTE,omitempty"`
	AlignmentDescContains     *string  `json:"alignmentDescContains,omitempty"`
	AlignmentDescHasPrefix    *string  `json:"alignmentDescHasPrefix,omitempty"`
	AlignmentDescHasSuffix    *string  `json:"alignmentDescHasSuffix,omitempty"`
	AlignmentDescEqualFold    *string  `json:"alignmentDescEqualFold,omitempty"`
	AlignmentDescContainsFold *string  `json:"alignmentDescContainsFold,omitempty"`

	// "age_desc" field predicates.
	AgeDesc             *string  `json:"ageDesc,omitempty"`
	AgeDescNEQ          *string  `json:"ageDescNEQ,omitempty"`
	AgeDescIn           []string `json:"ageDescIn,omitempty"`
	AgeDescNotIn        []string `json:"ageDescNotIn,omitempty"`
	AgeDescGT           *string  `json:"ageDescGT,omitempty"`
	AgeDescGTE          *string  `json:"ageDescGTE,omitempty"`
	AgeDescLT           *string  `json:"ageDescLT,omitempty"`
	AgeDescLTE          *string  `json:"ageDescLTE,omitempty"`
	AgeDescContains     *string  `json:"ageDescContains,omitempty"`
	AgeDescHasPrefix    *string  `json:"ageDescHasPrefix,omitempty"`
	AgeDescHasSuffix    *string  `json:"ageDescHasSuffix,omitempty"`
	AgeDescEqualFold    *string  `json:"ageDescEqualFold,omitempty"`
	AgeDescContainsFold *string  `json:"ageDescContainsFold,omitempty"`

	// "language_desc" field predicates.
	LanguageDesc             *string  `json:"languageDesc,omitempty"`
	LanguageDescNEQ          *string  `json:"languageDescNEQ,omitempty"`
	LanguageDescIn           []string `json:"languageDescIn,omitempty"`
	LanguageDescNotIn        []string `json:"languageDescNotIn,omitempty"`
	LanguageDescGT           *string  `json:"languageDescGT,omitempty"`
	LanguageDescGTE          *string  `json:"languageDescGTE,omitempty"`
	LanguageDescLT           *string  `json:"languageDescLT,omitempty"`
	LanguageDescLTE          *string  `json:"languageDescLTE,omitempty"`
	LanguageDescContains     *string  `json:"languageDescContains,omitempty"`
	LanguageDescHasPrefix    *string  `json:"languageDescHasPrefix,omitempty"`
	LanguageDescHasSuffix    *string  `json:"languageDescHasSuffix,omitempty"`
	LanguageDescEqualFold    *string  `json:"languageDescEqualFold,omitempty"`
	LanguageDescContainsFold *string  `json:"languageDescContainsFold,omitempty"`

	// "ability_bonuses" edge predicates.
	HasAbilityBonuses     *bool                     `json:"hasAbilityBonuses,omitempty"`
	HasAbilityBonusesWith []*AbilityBonusWhereInput `json:"hasAbilityBonusesWith,omitempty"`

	// "languages" edge predicates.
	HasLanguages     *bool                 `json:"hasLanguages,omitempty"`
	HasLanguagesWith []*LanguageWhereInput `json:"hasLanguagesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RaceWhereInput) AddPredicates(predicates ...predicate.Race) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RaceWhereInput filter on the RaceQuery builder.
func (i *RaceWhereInput) Filter(q *RaceQuery) (*RaceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRaceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRaceWhereInput is returned in case the RaceWhereInput is empty.
var ErrEmptyRaceWhereInput = errors.New("ent: empty predicate RaceWhereInput")

// P returns a predicate for filtering races.
// An error is returned if the input is empty or invalid.
func (i *RaceWhereInput) P() (predicate.Race, error) {
	var predicates []predicate.Race
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, race.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Race, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, race.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Race, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, race.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, race.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, race.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, race.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, race.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, race.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, race.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, race.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, race.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, race.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, race.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, race.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, race.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, race.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, race.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, race.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, race.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, race.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, race.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, race.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, race.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, race.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, race.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, race.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, race.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, race.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, race.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, race.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, race.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, race.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, race.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, race.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, race.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, race.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, race.NameContainsFold(*i.NameContainsFold))
	}
	if i.Speed != nil {
		predicates = append(predicates, race.SpeedEQ(*i.Speed))
	}
	if i.SpeedNEQ != nil {
		predicates = append(predicates, race.SpeedNEQ(*i.SpeedNEQ))
	}
	if len(i.SpeedIn) > 0 {
		predicates = append(predicates, race.SpeedIn(i.SpeedIn...))
	}
	if len(i.SpeedNotIn) > 0 {
		predicates = append(predicates, race.SpeedNotIn(i.SpeedNotIn...))
	}
	if i.SpeedGT != nil {
		predicates = append(predicates, race.SpeedGT(*i.SpeedGT))
	}
	if i.SpeedGTE != nil {
		predicates = append(predicates, race.SpeedGTE(*i.SpeedGTE))
	}
	if i.SpeedLT != nil {
		predicates = append(predicates, race.SpeedLT(*i.SpeedLT))
	}
	if i.SpeedLTE != nil {
		predicates = append(predicates, race.SpeedLTE(*i.SpeedLTE))
	}
	if i.Size != nil {
		predicates = append(predicates, race.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, race.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, race.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, race.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeDesc != nil {
		predicates = append(predicates, race.SizeDescEQ(*i.SizeDesc))
	}
	if i.SizeDescNEQ != nil {
		predicates = append(predicates, race.SizeDescNEQ(*i.SizeDescNEQ))
	}
	if len(i.SizeDescIn) > 0 {
		predicates = append(predicates, race.SizeDescIn(i.SizeDescIn...))
	}
	if len(i.SizeDescNotIn) > 0 {
		predicates = append(predicates, race.SizeDescNotIn(i.SizeDescNotIn...))
	}
	if i.SizeDescGT != nil {
		predicates = append(predicates, race.SizeDescGT(*i.SizeDescGT))
	}
	if i.SizeDescGTE != nil {
		predicates = append(predicates, race.SizeDescGTE(*i.SizeDescGTE))
	}
	if i.SizeDescLT != nil {
		predicates = append(predicates, race.SizeDescLT(*i.SizeDescLT))
	}
	if i.SizeDescLTE != nil {
		predicates = append(predicates, race.SizeDescLTE(*i.SizeDescLTE))
	}
	if i.SizeDescContains != nil {
		predicates = append(predicates, race.SizeDescContains(*i.SizeDescContains))
	}
	if i.SizeDescHasPrefix != nil {
		predicates = append(predicates, race.SizeDescHasPrefix(*i.SizeDescHasPrefix))
	}
	if i.SizeDescHasSuffix != nil {
		predicates = append(predicates, race.SizeDescHasSuffix(*i.SizeDescHasSuffix))
	}
	if i.SizeDescEqualFold != nil {
		predicates = append(predicates, race.SizeDescEqualFold(*i.SizeDescEqualFold))
	}
	if i.SizeDescContainsFold != nil {
		predicates = append(predicates, race.SizeDescContainsFold(*i.SizeDescContainsFold))
	}
	if i.AlignmentDesc != nil {
		predicates = append(predicates, race.AlignmentDescEQ(*i.AlignmentDesc))
	}
	if i.AlignmentDescNEQ != nil {
		predicates = append(predicates, race.AlignmentDescNEQ(*i.AlignmentDescNEQ))
	}
	if len(i.AlignmentDescIn) > 0 {
		predicates = append(predicates, race.AlignmentDescIn(i.AlignmentDescIn...))
	}
	if len(i.AlignmentDescNotIn) > 0 {
		predicates = append(predicates, race.AlignmentDescNotIn(i.AlignmentDescNotIn...))
	}
	if i.AlignmentDescGT != nil {
		predicates = append(predicates, race.AlignmentDescGT(*i.AlignmentDescGT))
	}
	if i.AlignmentDescGTE != nil {
		predicates = append(predicates, race.AlignmentDescGTE(*i.AlignmentDescGTE))
	}
	if i.AlignmentDescLT != nil {
		predicates = append(predicates, race.AlignmentDescLT(*i.AlignmentDescLT))
	}
	if i.AlignmentDescLTE != nil {
		predicates = append(predicates, race.AlignmentDescLTE(*i.AlignmentDescLTE))
	}
	if i.AlignmentDescContains != nil {
		predicates = append(predicates, race.AlignmentDescContains(*i.AlignmentDescContains))
	}
	if i.AlignmentDescHasPrefix != nil {
		predicates = append(predicates, race.AlignmentDescHasPrefix(*i.AlignmentDescHasPrefix))
	}
	if i.AlignmentDescHasSuffix != nil {
		predicates = append(predicates, race.AlignmentDescHasSuffix(*i.AlignmentDescHasSuffix))
	}
	if i.AlignmentDescEqualFold != nil {
		predicates = append(predicates, race.AlignmentDescEqualFold(*i.AlignmentDescEqualFold))
	}
	if i.AlignmentDescContainsFold != nil {
		predicates = append(predicates, race.AlignmentDescContainsFold(*i.AlignmentDescContainsFold))
	}
	if i.AgeDesc != nil {
		predicates = append(predicates, race.AgeDescEQ(*i.AgeDesc))
	}
	if i.AgeDescNEQ != nil {
		predicates = append(predicates, race.AgeDescNEQ(*i.AgeDescNEQ))
	}
	if len(i.AgeDescIn) > 0 {
		predicates = append(predicates, race.AgeDescIn(i.AgeDescIn...))
	}
	if len(i.AgeDescNotIn) > 0 {
		predicates = append(predicates, race.AgeDescNotIn(i.AgeDescNotIn...))
	}
	if i.AgeDescGT != nil {
		predicates = append(predicates, race.AgeDescGT(*i.AgeDescGT))
	}
	if i.AgeDescGTE != nil {
		predicates = append(predicates, race.AgeDescGTE(*i.AgeDescGTE))
	}
	if i.AgeDescLT != nil {
		predicates = append(predicates, race.AgeDescLT(*i.AgeDescLT))
	}
	if i.AgeDescLTE != nil {
		predicates = append(predicates, race.AgeDescLTE(*i.AgeDescLTE))
	}
	if i.AgeDescContains != nil {
		predicates = append(predicates, race.AgeDescContains(*i.AgeDescContains))
	}
	if i.AgeDescHasPrefix != nil {
		predicates = append(predicates, race.AgeDescHasPrefix(*i.AgeDescHasPrefix))
	}
	if i.AgeDescHasSuffix != nil {
		predicates = append(predicates, race.AgeDescHasSuffix(*i.AgeDescHasSuffix))
	}
	if i.AgeDescEqualFold != nil {
		predicates = append(predicates, race.AgeDescEqualFold(*i.AgeDescEqualFold))
	}
	if i.AgeDescContainsFold != nil {
		predicates = append(predicates, race.AgeDescContainsFold(*i.AgeDescContainsFold))
	}
	if i.LanguageDesc != nil {
		predicates = append(predicates, race.LanguageDescEQ(*i.LanguageDesc))
	}
	if i.LanguageDescNEQ != nil {
		predicates = append(predicates, race.LanguageDescNEQ(*i.LanguageDescNEQ))
	}
	if len(i.LanguageDescIn) > 0 {
		predicates = append(predicates, race.LanguageDescIn(i.LanguageDescIn...))
	}
	if len(i.LanguageDescNotIn) > 0 {
		predicates = append(predicates, race.LanguageDescNotIn(i.LanguageDescNotIn...))
	}
	if i.LanguageDescGT != nil {
		predicates = append(predicates, race.LanguageDescGT(*i.LanguageDescGT))
	}
	if i.LanguageDescGTE != nil {
		predicates = append(predicates, race.LanguageDescGTE(*i.LanguageDescGTE))
	}
	if i.LanguageDescLT != nil {
		predicates = append(predicates, race.LanguageDescLT(*i.LanguageDescLT))
	}
	if i.LanguageDescLTE != nil {
		predicates = append(predicates, race.LanguageDescLTE(*i.LanguageDescLTE))
	}
	if i.LanguageDescContains != nil {
		predicates = append(predicates, race.LanguageDescContains(*i.LanguageDescContains))
	}
	if i.LanguageDescHasPrefix != nil {
		predicates = append(predicates, race.LanguageDescHasPrefix(*i.LanguageDescHasPrefix))
	}
	if i.LanguageDescHasSuffix != nil {
		predicates = append(predicates, race.LanguageDescHasSuffix(*i.LanguageDescHasSuffix))
	}
	if i.LanguageDescEqualFold != nil {
		predicates = append(predicates, race.LanguageDescEqualFold(*i.LanguageDescEqualFold))
	}
	if i.LanguageDescContainsFold != nil {
		predicates = append(predicates, race.LanguageDescContainsFold(*i.LanguageDescContainsFold))
	}

	if i.HasAbilityBonuses != nil {
		p := race.HasAbilityBonuses()
		if !*i.HasAbilityBonuses {
			p = race.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAbilityBonusesWith) > 0 {
		with := make([]predicate.AbilityBonus, 0, len(i.HasAbilityBonusesWith))
		for _, w := range i.HasAbilityBonusesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAbilityBonusesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, race.HasAbilityBonusesWith(with...))
	}
	if i.HasLanguages != nil {
		p := race.HasLanguages()
		if !*i.HasLanguages {
			p = race.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLanguagesWith) > 0 {
		with := make([]predicate.Language, 0, len(i.HasLanguagesWith))
		for _, w := range i.HasLanguagesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLanguagesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, race.HasLanguagesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRaceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return race.And(predicates...), nil
	}
}

// RuleWhereInput represents a where input for filtering Rule queries.
type RuleWhereInput struct {
	Predicates []predicate.Rule  `json:"-"`
	Not        *RuleWhereInput   `json:"not,omitempty"`
	Or         []*RuleWhereInput `json:"or,omitempty"`
	And        []*RuleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "sections" edge predicates.
	HasSections     *bool                    `json:"hasSections,omitempty"`
	HasSectionsWith []*RuleSectionWhereInput `json:"hasSectionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RuleWhereInput) AddPredicates(predicates ...predicate.Rule) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RuleWhereInput filter on the RuleQuery builder.
func (i *RuleWhereInput) Filter(q *RuleQuery) (*RuleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRuleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRuleWhereInput is returned in case the RuleWhereInput is empty.
var ErrEmptyRuleWhereInput = errors.New("ent: empty predicate RuleWhereInput")

// P returns a predicate for filtering rules.
// An error is returned if the input is empty or invalid.
func (i *RuleWhereInput) P() (predicate.Rule, error) {
	var predicates []predicate.Rule
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, rule.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Rule, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, rule.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Rule, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, rule.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, rule.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, rule.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, rule.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, rule.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, rule.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, rule.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, rule.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, rule.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, rule.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, rule.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, rule.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, rule.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, rule.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, rule.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, rule.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, rule.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, rule.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, rule.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, rule.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, rule.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, rule.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, rule.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, rule.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, rule.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, rule.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, rule.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, rule.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, rule.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, rule.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, rule.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, rule.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, rule.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, rule.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, rule.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasSections != nil {
		p := rule.HasSections()
		if !*i.HasSections {
			p = rule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSectionsWith) > 0 {
		with := make([]predicate.RuleSection, 0, len(i.HasSectionsWith))
		for _, w := range i.HasSectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSectionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, rule.HasSectionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRuleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return rule.And(predicates...), nil
	}
}

// RuleSectionWhereInput represents a where input for filtering RuleSection queries.
type RuleSectionWhereInput struct {
	Predicates []predicate.RuleSection  `json:"-"`
	Not        *RuleSectionWhereInput   `json:"not,omitempty"`
	Or         []*RuleSectionWhereInput `json:"or,omitempty"`
	And        []*RuleSectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "rule" edge predicates.
	HasRule     *bool             `json:"hasRule,omitempty"`
	HasRuleWith []*RuleWhereInput `json:"hasRuleWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RuleSectionWhereInput) AddPredicates(predicates ...predicate.RuleSection) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RuleSectionWhereInput filter on the RuleSectionQuery builder.
func (i *RuleSectionWhereInput) Filter(q *RuleSectionQuery) (*RuleSectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRuleSectionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRuleSectionWhereInput is returned in case the RuleSectionWhereInput is empty.
var ErrEmptyRuleSectionWhereInput = errors.New("ent: empty predicate RuleSectionWhereInput")

// P returns a predicate for filtering rulesections.
// An error is returned if the input is empty or invalid.
func (i *RuleSectionWhereInput) P() (predicate.RuleSection, error) {
	var predicates []predicate.RuleSection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, rulesection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RuleSection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, rulesection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RuleSection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, rulesection.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, rulesection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, rulesection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, rulesection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, rulesection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, rulesection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, rulesection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, rulesection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, rulesection.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, rulesection.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, rulesection.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, rulesection.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, rulesection.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, rulesection.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, rulesection.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, rulesection.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, rulesection.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, rulesection.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, rulesection.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, rulesection.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, rulesection.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, rulesection.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, rulesection.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, rulesection.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, rulesection.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, rulesection.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, rulesection.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, rulesection.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, rulesection.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, rulesection.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, rulesection.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, rulesection.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, rulesection.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, rulesection.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, rulesection.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasRule != nil {
		p := rulesection.HasRule()
		if !*i.HasRule {
			p = rulesection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRuleWith) > 0 {
		with := make([]predicate.Rule, 0, len(i.HasRuleWith))
		for _, w := range i.HasRuleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRuleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, rulesection.HasRuleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRuleSectionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return rulesection.And(predicates...), nil
	}
}

// SkillWhereInput represents a where input for filtering Skill queries.
type SkillWhereInput struct {
	Predicates []predicate.Skill  `json:"-"`
	Not        *SkillWhereInput   `json:"not,omitempty"`
	Or         []*SkillWhereInput `json:"or,omitempty"`
	And        []*SkillWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "ability_score" edge predicates.
	HasAbilityScore     *bool                     `json:"hasAbilityScore,omitempty"`
	HasAbilityScoreWith []*AbilityScoreWhereInput `json:"hasAbilityScoreWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SkillWhereInput) AddPredicates(predicates ...predicate.Skill) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SkillWhereInput filter on the SkillQuery builder.
func (i *SkillWhereInput) Filter(q *SkillQuery) (*SkillQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySkillWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySkillWhereInput is returned in case the SkillWhereInput is empty.
var ErrEmptySkillWhereInput = errors.New("ent: empty predicate SkillWhereInput")

// P returns a predicate for filtering skills.
// An error is returned if the input is empty or invalid.
func (i *SkillWhereInput) P() (predicate.Skill, error) {
	var predicates []predicate.Skill
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, skill.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Skill, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, skill.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Skill, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, skill.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, skill.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, skill.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, skill.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, skill.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, skill.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, skill.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, skill.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, skill.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, skill.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, skill.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, skill.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, skill.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, skill.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, skill.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, skill.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, skill.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, skill.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, skill.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, skill.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, skill.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, skill.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, skill.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, skill.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, skill.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, skill.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, skill.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, skill.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, skill.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, skill.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, skill.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, skill.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, skill.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, skill.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, skill.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasAbilityScore != nil {
		p := skill.HasAbilityScore()
		if !*i.HasAbilityScore {
			p = skill.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAbilityScoreWith) > 0 {
		with := make([]predicate.AbilityScore, 0, len(i.HasAbilityScoreWith))
		for _, w := range i.HasAbilityScoreWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAbilityScoreWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, skill.HasAbilityScoreWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySkillWhereInput
	case 1:
		return predicates[0], nil
	default:
		return skill.And(predicates...), nil
	}
}

// ToolWhereInput represents a where input for filtering Tool queries.
type ToolWhereInput struct {
	Predicates []predicate.Tool  `json:"-"`
	Not        *ToolWhereInput   `json:"not,omitempty"`
	Or         []*ToolWhereInput `json:"or,omitempty"`
	And        []*ToolWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "tool_category" field predicates.
	ToolCategory             *string  `json:"toolCategory,omitempty"`
	ToolCategoryNEQ          *string  `json:"toolCategoryNEQ,omitempty"`
	ToolCategoryIn           []string `json:"toolCategoryIn,omitempty"`
	ToolCategoryNotIn        []string `json:"toolCategoryNotIn,omitempty"`
	ToolCategoryGT           *string  `json:"toolCategoryGT,omitempty"`
	ToolCategoryGTE          *string  `json:"toolCategoryGTE,omitempty"`
	ToolCategoryLT           *string  `json:"toolCategoryLT,omitempty"`
	ToolCategoryLTE          *string  `json:"toolCategoryLTE,omitempty"`
	ToolCategoryContains     *string  `json:"toolCategoryContains,omitempty"`
	ToolCategoryHasPrefix    *string  `json:"toolCategoryHasPrefix,omitempty"`
	ToolCategoryHasSuffix    *string  `json:"toolCategoryHasSuffix,omitempty"`
	ToolCategoryEqualFold    *string  `json:"toolCategoryEqualFold,omitempty"`
	ToolCategoryContainsFold *string  `json:"toolCategoryContainsFold,omitempty"`

	// "equipment" edge predicates.
	HasEquipment     *bool                  `json:"hasEquipment,omitempty"`
	HasEquipmentWith []*EquipmentWhereInput `json:"hasEquipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ToolWhereInput) AddPredicates(predicates ...predicate.Tool) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ToolWhereInput filter on the ToolQuery builder.
func (i *ToolWhereInput) Filter(q *ToolQuery) (*ToolQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyToolWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyToolWhereInput is returned in case the ToolWhereInput is empty.
var ErrEmptyToolWhereInput = errors.New("ent: empty predicate ToolWhereInput")

// P returns a predicate for filtering tools.
// An error is returned if the input is empty or invalid.
func (i *ToolWhereInput) P() (predicate.Tool, error) {
	var predicates []predicate.Tool
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tool.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tool, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tool.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tool, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tool.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tool.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tool.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tool.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tool.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tool.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tool.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tool.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tool.IDLTE(*i.IDLTE))
	}
	if i.ToolCategory != nil {
		predicates = append(predicates, tool.ToolCategoryEQ(*i.ToolCategory))
	}
	if i.ToolCategoryNEQ != nil {
		predicates = append(predicates, tool.ToolCategoryNEQ(*i.ToolCategoryNEQ))
	}
	if len(i.ToolCategoryIn) > 0 {
		predicates = append(predicates, tool.ToolCategoryIn(i.ToolCategoryIn...))
	}
	if len(i.ToolCategoryNotIn) > 0 {
		predicates = append(predicates, tool.ToolCategoryNotIn(i.ToolCategoryNotIn...))
	}
	if i.ToolCategoryGT != nil {
		predicates = append(predicates, tool.ToolCategoryGT(*i.ToolCategoryGT))
	}
	if i.ToolCategoryGTE != nil {
		predicates = append(predicates, tool.ToolCategoryGTE(*i.ToolCategoryGTE))
	}
	if i.ToolCategoryLT != nil {
		predicates = append(predicates, tool.ToolCategoryLT(*i.ToolCategoryLT))
	}
	if i.ToolCategoryLTE != nil {
		predicates = append(predicates, tool.ToolCategoryLTE(*i.ToolCategoryLTE))
	}
	if i.ToolCategoryContains != nil {
		predicates = append(predicates, tool.ToolCategoryContains(*i.ToolCategoryContains))
	}
	if i.ToolCategoryHasPrefix != nil {
		predicates = append(predicates, tool.ToolCategoryHasPrefix(*i.ToolCategoryHasPrefix))
	}
	if i.ToolCategoryHasSuffix != nil {
		predicates = append(predicates, tool.ToolCategoryHasSuffix(*i.ToolCategoryHasSuffix))
	}
	if i.ToolCategoryEqualFold != nil {
		predicates = append(predicates, tool.ToolCategoryEqualFold(*i.ToolCategoryEqualFold))
	}
	if i.ToolCategoryContainsFold != nil {
		predicates = append(predicates, tool.ToolCategoryContainsFold(*i.ToolCategoryContainsFold))
	}

	if i.HasEquipment != nil {
		p := tool.HasEquipment()
		if !*i.HasEquipment {
			p = tool.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentWith))
		for _, w := range i.HasEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tool.HasEquipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyToolWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tool.And(predicates...), nil
	}
}

// VehicleWhereInput represents a where input for filtering Vehicle queries.
type VehicleWhereInput struct {
	Predicates []predicate.Vehicle  `json:"-"`
	Not        *VehicleWhereInput   `json:"not,omitempty"`
	Or         []*VehicleWhereInput `json:"or,omitempty"`
	And        []*VehicleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "vehicle_category" field predicates.
	VehicleCategory      *vehicle.VehicleCategory  `json:"vehicleCategory,omitempty"`
	VehicleCategoryNEQ   *vehicle.VehicleCategory  `json:"vehicleCategoryNEQ,omitempty"`
	VehicleCategoryIn    []vehicle.VehicleCategory `json:"vehicleCategoryIn,omitempty"`
	VehicleCategoryNotIn []vehicle.VehicleCategory `json:"vehicleCategoryNotIn,omitempty"`

	// "capacity" field predicates.
	Capacity             *string  `json:"capacity,omitempty"`
	CapacityNEQ          *string  `json:"capacityNEQ,omitempty"`
	CapacityIn           []string `json:"capacityIn,omitempty"`
	CapacityNotIn        []string `json:"capacityNotIn,omitempty"`
	CapacityGT           *string  `json:"capacityGT,omitempty"`
	CapacityGTE          *string  `json:"capacityGTE,omitempty"`
	CapacityLT           *string  `json:"capacityLT,omitempty"`
	CapacityLTE          *string  `json:"capacityLTE,omitempty"`
	CapacityContains     *string  `json:"capacityContains,omitempty"`
	CapacityHasPrefix    *string  `json:"capacityHasPrefix,omitempty"`
	CapacityHasSuffix    *string  `json:"capacityHasSuffix,omitempty"`
	CapacityIsNil        bool     `json:"capacityIsNil,omitempty"`
	CapacityNotNil       bool     `json:"capacityNotNil,omitempty"`
	CapacityEqualFold    *string  `json:"capacityEqualFold,omitempty"`
	CapacityContainsFold *string  `json:"capacityContainsFold,omitempty"`

	// "speed_quantity" field predicates.
	SpeedQuantity       *float64  `json:"speedQuantity,omitempty"`
	SpeedQuantityNEQ    *float64  `json:"speedQuantityNEQ,omitempty"`
	SpeedQuantityIn     []float64 `json:"speedQuantityIn,omitempty"`
	SpeedQuantityNotIn  []float64 `json:"speedQuantityNotIn,omitempty"`
	SpeedQuantityGT     *float64  `json:"speedQuantityGT,omitempty"`
	SpeedQuantityGTE    *float64  `json:"speedQuantityGTE,omitempty"`
	SpeedQuantityLT     *float64  `json:"speedQuantityLT,omitempty"`
	SpeedQuantityLTE    *float64  `json:"speedQuantityLTE,omitempty"`
	SpeedQuantityIsNil  bool      `json:"speedQuantityIsNil,omitempty"`
	SpeedQuantityNotNil bool      `json:"speedQuantityNotNil,omitempty"`

	// "speed_units" field predicates.
	SpeedUnits       *vehicle.SpeedUnits  `json:"speedUnits,omitempty"`
	SpeedUnitsNEQ    *vehicle.SpeedUnits  `json:"speedUnitsNEQ,omitempty"`
	SpeedUnitsIn     []vehicle.SpeedUnits `json:"speedUnitsIn,omitempty"`
	SpeedUnitsNotIn  []vehicle.SpeedUnits `json:"speedUnitsNotIn,omitempty"`
	SpeedUnitsIsNil  bool                 `json:"speedUnitsIsNil,omitempty"`
	SpeedUnitsNotNil bool                 `json:"speedUnitsNotNil,omitempty"`

	// "equipment" edge predicates.
	HasEquipment     *bool                  `json:"hasEquipment,omitempty"`
	HasEquipmentWith []*EquipmentWhereInput `json:"hasEquipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *VehicleWhereInput) AddPredicates(predicates ...predicate.Vehicle) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the VehicleWhereInput filter on the VehicleQuery builder.
func (i *VehicleWhereInput) Filter(q *VehicleQuery) (*VehicleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyVehicleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyVehicleWhereInput is returned in case the VehicleWhereInput is empty.
var ErrEmptyVehicleWhereInput = errors.New("ent: empty predicate VehicleWhereInput")

// P returns a predicate for filtering vehicles.
// An error is returned if the input is empty or invalid.
func (i *VehicleWhereInput) P() (predicate.Vehicle, error) {
	var predicates []predicate.Vehicle
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, vehicle.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Vehicle, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, vehicle.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Vehicle, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, vehicle.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, vehicle.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vehicle.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vehicle.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vehicle.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vehicle.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vehicle.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vehicle.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vehicle.IDLTE(*i.IDLTE))
	}
	if i.VehicleCategory != nil {
		predicates = append(predicates, vehicle.VehicleCategoryEQ(*i.VehicleCategory))
	}
	if i.VehicleCategoryNEQ != nil {
		predicates = append(predicates, vehicle.VehicleCategoryNEQ(*i.VehicleCategoryNEQ))
	}
	if len(i.VehicleCategoryIn) > 0 {
		predicates = append(predicates, vehicle.VehicleCategoryIn(i.VehicleCategoryIn...))
	}
	if len(i.VehicleCategoryNotIn) > 0 {
		predicates = append(predicates, vehicle.VehicleCategoryNotIn(i.VehicleCategoryNotIn...))
	}
	if i.Capacity != nil {
		predicates = append(predicates, vehicle.CapacityEQ(*i.Capacity))
	}
	if i.CapacityNEQ != nil {
		predicates = append(predicates, vehicle.CapacityNEQ(*i.CapacityNEQ))
	}
	if len(i.CapacityIn) > 0 {
		predicates = append(predicates, vehicle.CapacityIn(i.CapacityIn...))
	}
	if len(i.CapacityNotIn) > 0 {
		predicates = append(predicates, vehicle.CapacityNotIn(i.CapacityNotIn...))
	}
	if i.CapacityGT != nil {
		predicates = append(predicates, vehicle.CapacityGT(*i.CapacityGT))
	}
	if i.CapacityGTE != nil {
		predicates = append(predicates, vehicle.CapacityGTE(*i.CapacityGTE))
	}
	if i.CapacityLT != nil {
		predicates = append(predicates, vehicle.CapacityLT(*i.CapacityLT))
	}
	if i.CapacityLTE != nil {
		predicates = append(predicates, vehicle.CapacityLTE(*i.CapacityLTE))
	}
	if i.CapacityContains != nil {
		predicates = append(predicates, vehicle.CapacityContains(*i.CapacityContains))
	}
	if i.CapacityHasPrefix != nil {
		predicates = append(predicates, vehicle.CapacityHasPrefix(*i.CapacityHasPrefix))
	}
	if i.CapacityHasSuffix != nil {
		predicates = append(predicates, vehicle.CapacityHasSuffix(*i.CapacityHasSuffix))
	}
	if i.CapacityIsNil {
		predicates = append(predicates, vehicle.CapacityIsNil())
	}
	if i.CapacityNotNil {
		predicates = append(predicates, vehicle.CapacityNotNil())
	}
	if i.CapacityEqualFold != nil {
		predicates = append(predicates, vehicle.CapacityEqualFold(*i.CapacityEqualFold))
	}
	if i.CapacityContainsFold != nil {
		predicates = append(predicates, vehicle.CapacityContainsFold(*i.CapacityContainsFold))
	}
	if i.SpeedQuantity != nil {
		predicates = append(predicates, vehicle.SpeedQuantityEQ(*i.SpeedQuantity))
	}
	if i.SpeedQuantityNEQ != nil {
		predicates = append(predicates, vehicle.SpeedQuantityNEQ(*i.SpeedQuantityNEQ))
	}
	if len(i.SpeedQuantityIn) > 0 {
		predicates = append(predicates, vehicle.SpeedQuantityIn(i.SpeedQuantityIn...))
	}
	if len(i.SpeedQuantityNotIn) > 0 {
		predicates = append(predicates, vehicle.SpeedQuantityNotIn(i.SpeedQuantityNotIn...))
	}
	if i.SpeedQuantityGT != nil {
		predicates = append(predicates, vehicle.SpeedQuantityGT(*i.SpeedQuantityGT))
	}
	if i.SpeedQuantityGTE != nil {
		predicates = append(predicates, vehicle.SpeedQuantityGTE(*i.SpeedQuantityGTE))
	}
	if i.SpeedQuantityLT != nil {
		predicates = append(predicates, vehicle.SpeedQuantityLT(*i.SpeedQuantityLT))
	}
	if i.SpeedQuantityLTE != nil {
		predicates = append(predicates, vehicle.SpeedQuantityLTE(*i.SpeedQuantityLTE))
	}
	if i.SpeedQuantityIsNil {
		predicates = append(predicates, vehicle.SpeedQuantityIsNil())
	}
	if i.SpeedQuantityNotNil {
		predicates = append(predicates, vehicle.SpeedQuantityNotNil())
	}
	if i.SpeedUnits != nil {
		predicates = append(predicates, vehicle.SpeedUnitsEQ(*i.SpeedUnits))
	}
	if i.SpeedUnitsNEQ != nil {
		predicates = append(predicates, vehicle.SpeedUnitsNEQ(*i.SpeedUnitsNEQ))
	}
	if len(i.SpeedUnitsIn) > 0 {
		predicates = append(predicates, vehicle.SpeedUnitsIn(i.SpeedUnitsIn...))
	}
	if len(i.SpeedUnitsNotIn) > 0 {
		predicates = append(predicates, vehicle.SpeedUnitsNotIn(i.SpeedUnitsNotIn...))
	}
	if i.SpeedUnitsIsNil {
		predicates = append(predicates, vehicle.SpeedUnitsIsNil())
	}
	if i.SpeedUnitsNotNil {
		predicates = append(predicates, vehicle.SpeedUnitsNotNil())
	}

	if i.HasEquipment != nil {
		p := vehicle.HasEquipment()
		if !*i.HasEquipment {
			p = vehicle.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentWith))
		for _, w := range i.HasEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicle.HasEquipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyVehicleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return vehicle.And(predicates...), nil
	}
}

// WeaponWhereInput represents a where input for filtering Weapon queries.
type WeaponWhereInput struct {
	Predicates []predicate.Weapon  `json:"-"`
	Not        *WeaponWhereInput   `json:"not,omitempty"`
	Or         []*WeaponWhereInput `json:"or,omitempty"`
	And        []*WeaponWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "weapon_category" field predicates.
	WeaponCategory      *weapon.WeaponCategory  `json:"weaponCategory,omitempty"`
	WeaponCategoryNEQ   *weapon.WeaponCategory  `json:"weaponCategoryNEQ,omitempty"`
	WeaponCategoryIn    []weapon.WeaponCategory `json:"weaponCategoryIn,omitempty"`
	WeaponCategoryNotIn []weapon.WeaponCategory `json:"weaponCategoryNotIn,omitempty"`

	// "weapon_subcategory" field predicates.
	WeaponSubcategory      *weapon.WeaponSubcategory  `json:"weaponSubcategory,omitempty"`
	WeaponSubcategoryNEQ   *weapon.WeaponSubcategory  `json:"weaponSubcategoryNEQ,omitempty"`
	WeaponSubcategoryIn    []weapon.WeaponSubcategory `json:"weaponSubcategoryIn,omitempty"`
	WeaponSubcategoryNotIn []weapon.WeaponSubcategory `json:"weaponSubcategoryNotIn,omitempty"`

	// "damage" edge predicates.
	HasDamage     *bool               `json:"hasDamage,omitempty"`
	HasDamageWith []*DamageWhereInput `json:"hasDamageWith,omitempty"`

	// "properties" edge predicates.
	HasProperties     *bool                 `json:"hasProperties,omitempty"`
	HasPropertiesWith []*PropertyWhereInput `json:"hasPropertiesWith,omitempty"`

	// "equipment" edge predicates.
	HasEquipment     *bool                  `json:"hasEquipment,omitempty"`
	HasEquipmentWith []*EquipmentWhereInput `json:"hasEquipmentWith,omitempty"`

	// "weapon_range" edge predicates.
	HasWeaponRange     *bool                    `json:"hasWeaponRange,omitempty"`
	HasWeaponRangeWith []*WeaponRangeWhereInput `json:"hasWeaponRangeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WeaponWhereInput) AddPredicates(predicates ...predicate.Weapon) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WeaponWhereInput filter on the WeaponQuery builder.
func (i *WeaponWhereInput) Filter(q *WeaponQuery) (*WeaponQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWeaponWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWeaponWhereInput is returned in case the WeaponWhereInput is empty.
var ErrEmptyWeaponWhereInput = errors.New("ent: empty predicate WeaponWhereInput")

// P returns a predicate for filtering weapons.
// An error is returned if the input is empty or invalid.
func (i *WeaponWhereInput) P() (predicate.Weapon, error) {
	var predicates []predicate.Weapon
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, weapon.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Weapon, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, weapon.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Weapon, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, weapon.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, weapon.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, weapon.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, weapon.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, weapon.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, weapon.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, weapon.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, weapon.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, weapon.IDLTE(*i.IDLTE))
	}
	if i.WeaponCategory != nil {
		predicates = append(predicates, weapon.WeaponCategoryEQ(*i.WeaponCategory))
	}
	if i.WeaponCategoryNEQ != nil {
		predicates = append(predicates, weapon.WeaponCategoryNEQ(*i.WeaponCategoryNEQ))
	}
	if len(i.WeaponCategoryIn) > 0 {
		predicates = append(predicates, weapon.WeaponCategoryIn(i.WeaponCategoryIn...))
	}
	if len(i.WeaponCategoryNotIn) > 0 {
		predicates = append(predicates, weapon.WeaponCategoryNotIn(i.WeaponCategoryNotIn...))
	}
	if i.WeaponSubcategory != nil {
		predicates = append(predicates, weapon.WeaponSubcategoryEQ(*i.WeaponSubcategory))
	}
	if i.WeaponSubcategoryNEQ != nil {
		predicates = append(predicates, weapon.WeaponSubcategoryNEQ(*i.WeaponSubcategoryNEQ))
	}
	if len(i.WeaponSubcategoryIn) > 0 {
		predicates = append(predicates, weapon.WeaponSubcategoryIn(i.WeaponSubcategoryIn...))
	}
	if len(i.WeaponSubcategoryNotIn) > 0 {
		predicates = append(predicates, weapon.WeaponSubcategoryNotIn(i.WeaponSubcategoryNotIn...))
	}

	if i.HasDamage != nil {
		p := weapon.HasDamage()
		if !*i.HasDamage {
			p = weapon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDamageWith) > 0 {
		with := make([]predicate.Damage, 0, len(i.HasDamageWith))
		for _, w := range i.HasDamageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDamageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weapon.HasDamageWith(with...))
	}
	if i.HasProperties != nil {
		p := weapon.HasProperties()
		if !*i.HasProperties {
			p = weapon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPropertiesWith) > 0 {
		with := make([]predicate.Property, 0, len(i.HasPropertiesWith))
		for _, w := range i.HasPropertiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPropertiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weapon.HasPropertiesWith(with...))
	}
	if i.HasEquipment != nil {
		p := weapon.HasEquipment()
		if !*i.HasEquipment {
			p = weapon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentWith))
		for _, w := range i.HasEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weapon.HasEquipmentWith(with...))
	}
	if i.HasWeaponRange != nil {
		p := weapon.HasWeaponRange()
		if !*i.HasWeaponRange {
			p = weapon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWeaponRangeWith) > 0 {
		with := make([]predicate.WeaponRange, 0, len(i.HasWeaponRangeWith))
		for _, w := range i.HasWeaponRangeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWeaponRangeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weapon.HasWeaponRangeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWeaponWhereInput
	case 1:
		return predicates[0], nil
	default:
		return weapon.And(predicates...), nil
	}
}

// WeaponRangeWhereInput represents a where input for filtering WeaponRange queries.
type WeaponRangeWhereInput struct {
	Predicates []predicate.WeaponRange  `json:"-"`
	Not        *WeaponRangeWhereInput   `json:"not,omitempty"`
	Or         []*WeaponRangeWhereInput `json:"or,omitempty"`
	And        []*WeaponRangeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "range_normal" field predicates.
	RangeNormal       *int  `json:"rangeNormal,omitempty"`
	RangeNormalNEQ    *int  `json:"rangeNormalNEQ,omitempty"`
	RangeNormalIn     []int `json:"rangeNormalIn,omitempty"`
	RangeNormalNotIn  []int `json:"rangeNormalNotIn,omitempty"`
	RangeNormalGT     *int  `json:"rangeNormalGT,omitempty"`
	RangeNormalGTE    *int  `json:"rangeNormalGTE,omitempty"`
	RangeNormalLT     *int  `json:"rangeNormalLT,omitempty"`
	RangeNormalLTE    *int  `json:"rangeNormalLTE,omitempty"`
	RangeNormalIsNil  bool  `json:"rangeNormalIsNil,omitempty"`
	RangeNormalNotNil bool  `json:"rangeNormalNotNil,omitempty"`

	// "range_long" field predicates.
	RangeLong       *int  `json:"rangeLong,omitempty"`
	RangeLongNEQ    *int  `json:"rangeLongNEQ,omitempty"`
	RangeLongIn     []int `json:"rangeLongIn,omitempty"`
	RangeLongNotIn  []int `json:"rangeLongNotIn,omitempty"`
	RangeLongGT     *int  `json:"rangeLongGT,omitempty"`
	RangeLongGTE    *int  `json:"rangeLongGTE,omitempty"`
	RangeLongLT     *int  `json:"rangeLongLT,omitempty"`
	RangeLongLTE    *int  `json:"rangeLongLTE,omitempty"`
	RangeLongIsNil  bool  `json:"rangeLongIsNil,omitempty"`
	RangeLongNotNil bool  `json:"rangeLongNotNil,omitempty"`

	// "throw_range_normal" field predicates.
	ThrowRangeNormal       *int  `json:"throwRangeNormal,omitempty"`
	ThrowRangeNormalNEQ    *int  `json:"throwRangeNormalNEQ,omitempty"`
	ThrowRangeNormalIn     []int `json:"throwRangeNormalIn,omitempty"`
	ThrowRangeNormalNotIn  []int `json:"throwRangeNormalNotIn,omitempty"`
	ThrowRangeNormalGT     *int  `json:"throwRangeNormalGT,omitempty"`
	ThrowRangeNormalGTE    *int  `json:"throwRangeNormalGTE,omitempty"`
	ThrowRangeNormalLT     *int  `json:"throwRangeNormalLT,omitempty"`
	ThrowRangeNormalLTE    *int  `json:"throwRangeNormalLTE,omitempty"`
	ThrowRangeNormalIsNil  bool  `json:"throwRangeNormalIsNil,omitempty"`
	ThrowRangeNormalNotNil bool  `json:"throwRangeNormalNotNil,omitempty"`

	// "throw_range_long" field predicates.
	ThrowRangeLong       *int  `json:"throwRangeLong,omitempty"`
	ThrowRangeLongNEQ    *int  `json:"throwRangeLongNEQ,omitempty"`
	ThrowRangeLongIn     []int `json:"throwRangeLongIn,omitempty"`
	ThrowRangeLongNotIn  []int `json:"throwRangeLongNotIn,omitempty"`
	ThrowRangeLongGT     *int  `json:"throwRangeLongGT,omitempty"`
	ThrowRangeLongGTE    *int  `json:"throwRangeLongGTE,omitempty"`
	ThrowRangeLongLT     *int  `json:"throwRangeLongLT,omitempty"`
	ThrowRangeLongLTE    *int  `json:"throwRangeLongLTE,omitempty"`
	ThrowRangeLongIsNil  bool  `json:"throwRangeLongIsNil,omitempty"`
	ThrowRangeLongNotNil bool  `json:"throwRangeLongNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WeaponRangeWhereInput) AddPredicates(predicates ...predicate.WeaponRange) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WeaponRangeWhereInput filter on the WeaponRangeQuery builder.
func (i *WeaponRangeWhereInput) Filter(q *WeaponRangeQuery) (*WeaponRangeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWeaponRangeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWeaponRangeWhereInput is returned in case the WeaponRangeWhereInput is empty.
var ErrEmptyWeaponRangeWhereInput = errors.New("ent: empty predicate WeaponRangeWhereInput")

// P returns a predicate for filtering weaponranges.
// An error is returned if the input is empty or invalid.
func (i *WeaponRangeWhereInput) P() (predicate.WeaponRange, error) {
	var predicates []predicate.WeaponRange
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, weaponrange.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WeaponRange, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, weaponrange.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WeaponRange, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, weaponrange.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, weaponrange.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, weaponrange.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, weaponrange.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, weaponrange.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, weaponrange.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, weaponrange.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, weaponrange.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, weaponrange.IDLTE(*i.IDLTE))
	}
	if i.RangeNormal != nil {
		predicates = append(predicates, weaponrange.RangeNormalEQ(*i.RangeNormal))
	}
	if i.RangeNormalNEQ != nil {
		predicates = append(predicates, weaponrange.RangeNormalNEQ(*i.RangeNormalNEQ))
	}
	if len(i.RangeNormalIn) > 0 {
		predicates = append(predicates, weaponrange.RangeNormalIn(i.RangeNormalIn...))
	}
	if len(i.RangeNormalNotIn) > 0 {
		predicates = append(predicates, weaponrange.RangeNormalNotIn(i.RangeNormalNotIn...))
	}
	if i.RangeNormalGT != nil {
		predicates = append(predicates, weaponrange.RangeNormalGT(*i.RangeNormalGT))
	}
	if i.RangeNormalGTE != nil {
		predicates = append(predicates, weaponrange.RangeNormalGTE(*i.RangeNormalGTE))
	}
	if i.RangeNormalLT != nil {
		predicates = append(predicates, weaponrange.RangeNormalLT(*i.RangeNormalLT))
	}
	if i.RangeNormalLTE != nil {
		predicates = append(predicates, weaponrange.RangeNormalLTE(*i.RangeNormalLTE))
	}
	if i.RangeNormalIsNil {
		predicates = append(predicates, weaponrange.RangeNormalIsNil())
	}
	if i.RangeNormalNotNil {
		predicates = append(predicates, weaponrange.RangeNormalNotNil())
	}
	if i.RangeLong != nil {
		predicates = append(predicates, weaponrange.RangeLongEQ(*i.RangeLong))
	}
	if i.RangeLongNEQ != nil {
		predicates = append(predicates, weaponrange.RangeLongNEQ(*i.RangeLongNEQ))
	}
	if len(i.RangeLongIn) > 0 {
		predicates = append(predicates, weaponrange.RangeLongIn(i.RangeLongIn...))
	}
	if len(i.RangeLongNotIn) > 0 {
		predicates = append(predicates, weaponrange.RangeLongNotIn(i.RangeLongNotIn...))
	}
	if i.RangeLongGT != nil {
		predicates = append(predicates, weaponrange.RangeLongGT(*i.RangeLongGT))
	}
	if i.RangeLongGTE != nil {
		predicates = append(predicates, weaponrange.RangeLongGTE(*i.RangeLongGTE))
	}
	if i.RangeLongLT != nil {
		predicates = append(predicates, weaponrange.RangeLongLT(*i.RangeLongLT))
	}
	if i.RangeLongLTE != nil {
		predicates = append(predicates, weaponrange.RangeLongLTE(*i.RangeLongLTE))
	}
	if i.RangeLongIsNil {
		predicates = append(predicates, weaponrange.RangeLongIsNil())
	}
	if i.RangeLongNotNil {
		predicates = append(predicates, weaponrange.RangeLongNotNil())
	}
	if i.ThrowRangeNormal != nil {
		predicates = append(predicates, weaponrange.ThrowRangeNormalEQ(*i.ThrowRangeNormal))
	}
	if i.ThrowRangeNormalNEQ != nil {
		predicates = append(predicates, weaponrange.ThrowRangeNormalNEQ(*i.ThrowRangeNormalNEQ))
	}
	if len(i.ThrowRangeNormalIn) > 0 {
		predicates = append(predicates, weaponrange.ThrowRangeNormalIn(i.ThrowRangeNormalIn...))
	}
	if len(i.ThrowRangeNormalNotIn) > 0 {
		predicates = append(predicates, weaponrange.ThrowRangeNormalNotIn(i.ThrowRangeNormalNotIn...))
	}
	if i.ThrowRangeNormalGT != nil {
		predicates = append(predicates, weaponrange.ThrowRangeNormalGT(*i.ThrowRangeNormalGT))
	}
	if i.ThrowRangeNormalGTE != nil {
		predicates = append(predicates, weaponrange.ThrowRangeNormalGTE(*i.ThrowRangeNormalGTE))
	}
	if i.ThrowRangeNormalLT != nil {
		predicates = append(predicates, weaponrange.ThrowRangeNormalLT(*i.ThrowRangeNormalLT))
	}
	if i.ThrowRangeNormalLTE != nil {
		predicates = append(predicates, weaponrange.ThrowRangeNormalLTE(*i.ThrowRangeNormalLTE))
	}
	if i.ThrowRangeNormalIsNil {
		predicates = append(predicates, weaponrange.ThrowRangeNormalIsNil())
	}
	if i.ThrowRangeNormalNotNil {
		predicates = append(predicates, weaponrange.ThrowRangeNormalNotNil())
	}
	if i.ThrowRangeLong != nil {
		predicates = append(predicates, weaponrange.ThrowRangeLongEQ(*i.ThrowRangeLong))
	}
	if i.ThrowRangeLongNEQ != nil {
		predicates = append(predicates, weaponrange.ThrowRangeLongNEQ(*i.ThrowRangeLongNEQ))
	}
	if len(i.ThrowRangeLongIn) > 0 {
		predicates = append(predicates, weaponrange.ThrowRangeLongIn(i.ThrowRangeLongIn...))
	}
	if len(i.ThrowRangeLongNotIn) > 0 {
		predicates = append(predicates, weaponrange.ThrowRangeLongNotIn(i.ThrowRangeLongNotIn...))
	}
	if i.ThrowRangeLongGT != nil {
		predicates = append(predicates, weaponrange.ThrowRangeLongGT(*i.ThrowRangeLongGT))
	}
	if i.ThrowRangeLongGTE != nil {
		predicates = append(predicates, weaponrange.ThrowRangeLongGTE(*i.ThrowRangeLongGTE))
	}
	if i.ThrowRangeLongLT != nil {
		predicates = append(predicates, weaponrange.ThrowRangeLongLT(*i.ThrowRangeLongLT))
	}
	if i.ThrowRangeLongLTE != nil {
		predicates = append(predicates, weaponrange.ThrowRangeLongLTE(*i.ThrowRangeLongLTE))
	}
	if i.ThrowRangeLongIsNil {
		predicates = append(predicates, weaponrange.ThrowRangeLongIsNil())
	}
	if i.ThrowRangeLongNotNil {
		predicates = append(predicates, weaponrange.ThrowRangeLongNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWeaponRangeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return weaponrange.And(predicates...), nil
	}
}
