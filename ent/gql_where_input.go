// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"github.com/ecshreve/dndgen/ent/abilityscore"
	"github.com/ecshreve/dndgen/ent/armor"
	"github.com/ecshreve/dndgen/ent/class"
	"github.com/ecshreve/dndgen/ent/damagetype"
	"github.com/ecshreve/dndgen/ent/predicate"
	"github.com/ecshreve/dndgen/ent/race"
	"github.com/ecshreve/dndgen/ent/skill"
	"github.com/ecshreve/dndgen/ent/unitvalue"
	"github.com/ecshreve/dndgen/ent/weapon"
	"github.com/ecshreve/dndgen/ent/weapondamage"
	"github.com/ecshreve/dndgen/ent/weaponrange"
)

// AbilityScoreWhereInput represents a where input for filtering AbilityScore queries.
type AbilityScoreWhereInput struct {
	Predicates []predicate.AbilityScore  `json:"-"`
	Not        *AbilityScoreWhereInput   `json:"not,omitempty"`
	Or         []*AbilityScoreWhereInput `json:"or,omitempty"`
	And        []*AbilityScoreWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "full_name" field predicates.
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNEQ          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGT           *string  `json:"fullNameGT,omitempty"`
	FullNameGTE          *string  `json:"fullNameGTE,omitempty"`
	FullNameLT           *string  `json:"fullNameLT,omitempty"`
	FullNameLTE          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`

	// "skills" edge predicates.
	HasSkills     *bool              `json:"hasSkills,omitempty"`
	HasSkillsWith []*SkillWhereInput `json:"hasSkillsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AbilityScoreWhereInput) AddPredicates(predicates ...predicate.AbilityScore) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AbilityScoreWhereInput filter on the AbilityScoreQuery builder.
func (i *AbilityScoreWhereInput) Filter(q *AbilityScoreQuery) (*AbilityScoreQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAbilityScoreWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAbilityScoreWhereInput is returned in case the AbilityScoreWhereInput is empty.
var ErrEmptyAbilityScoreWhereInput = errors.New("ent: empty predicate AbilityScoreWhereInput")

// P returns a predicate for filtering abilityscores.
// An error is returned if the input is empty or invalid.
func (i *AbilityScoreWhereInput) P() (predicate.AbilityScore, error) {
	var predicates []predicate.AbilityScore
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, abilityscore.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AbilityScore, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, abilityscore.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AbilityScore, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, abilityscore.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, abilityscore.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, abilityscore.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, abilityscore.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, abilityscore.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, abilityscore.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, abilityscore.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, abilityscore.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, abilityscore.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, abilityscore.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, abilityscore.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, abilityscore.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, abilityscore.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, abilityscore.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, abilityscore.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, abilityscore.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, abilityscore.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, abilityscore.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, abilityscore.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, abilityscore.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, abilityscore.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, abilityscore.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, abilityscore.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, abilityscore.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, abilityscore.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, abilityscore.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, abilityscore.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, abilityscore.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, abilityscore.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, abilityscore.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, abilityscore.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, abilityscore.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, abilityscore.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, abilityscore.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, abilityscore.NameContainsFold(*i.NameContainsFold))
	}
	if i.FullName != nil {
		predicates = append(predicates, abilityscore.FullNameEQ(*i.FullName))
	}
	if i.FullNameNEQ != nil {
		predicates = append(predicates, abilityscore.FullNameNEQ(*i.FullNameNEQ))
	}
	if len(i.FullNameIn) > 0 {
		predicates = append(predicates, abilityscore.FullNameIn(i.FullNameIn...))
	}
	if len(i.FullNameNotIn) > 0 {
		predicates = append(predicates, abilityscore.FullNameNotIn(i.FullNameNotIn...))
	}
	if i.FullNameGT != nil {
		predicates = append(predicates, abilityscore.FullNameGT(*i.FullNameGT))
	}
	if i.FullNameGTE != nil {
		predicates = append(predicates, abilityscore.FullNameGTE(*i.FullNameGTE))
	}
	if i.FullNameLT != nil {
		predicates = append(predicates, abilityscore.FullNameLT(*i.FullNameLT))
	}
	if i.FullNameLTE != nil {
		predicates = append(predicates, abilityscore.FullNameLTE(*i.FullNameLTE))
	}
	if i.FullNameContains != nil {
		predicates = append(predicates, abilityscore.FullNameContains(*i.FullNameContains))
	}
	if i.FullNameHasPrefix != nil {
		predicates = append(predicates, abilityscore.FullNameHasPrefix(*i.FullNameHasPrefix))
	}
	if i.FullNameHasSuffix != nil {
		predicates = append(predicates, abilityscore.FullNameHasSuffix(*i.FullNameHasSuffix))
	}
	if i.FullNameEqualFold != nil {
		predicates = append(predicates, abilityscore.FullNameEqualFold(*i.FullNameEqualFold))
	}
	if i.FullNameContainsFold != nil {
		predicates = append(predicates, abilityscore.FullNameContainsFold(*i.FullNameContainsFold))
	}

	if i.HasSkills != nil {
		p := abilityscore.HasSkills()
		if !*i.HasSkills {
			p = abilityscore.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSkillsWith) > 0 {
		with := make([]predicate.Skill, 0, len(i.HasSkillsWith))
		for _, w := range i.HasSkillsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSkillsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, abilityscore.HasSkillsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAbilityScoreWhereInput
	case 1:
		return predicates[0], nil
	default:
		return abilityscore.And(predicates...), nil
	}
}

// ArmorWhereInput represents a where input for filtering Armor queries.
type ArmorWhereInput struct {
	Predicates []predicate.Armor  `json:"-"`
	Not        *ArmorWhereInput   `json:"not,omitempty"`
	Or         []*ArmorWhereInput `json:"or,omitempty"`
	And        []*ArmorWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "weight" field predicates.
	Weight      *float64  `json:"weight,omitempty"`
	WeightNEQ   *float64  `json:"weightNEQ,omitempty"`
	WeightIn    []float64 `json:"weightIn,omitempty"`
	WeightNotIn []float64 `json:"weightNotIn,omitempty"`
	WeightGT    *float64  `json:"weightGT,omitempty"`
	WeightGTE   *float64  `json:"weightGTE,omitempty"`
	WeightLT    *float64  `json:"weightLT,omitempty"`
	WeightLTE   *float64  `json:"weightLTE,omitempty"`

	// "stealth_disadvantage" field predicates.
	StealthDisadvantage    *bool `json:"stealthDisadvantage,omitempty"`
	StealthDisadvantageNEQ *bool `json:"stealthDisadvantageNEQ,omitempty"`

	// "armor_class" field predicates.
	ArmorClass             *string  `json:"armorClass,omitempty"`
	ArmorClassNEQ          *string  `json:"armorClassNEQ,omitempty"`
	ArmorClassIn           []string `json:"armorClassIn,omitempty"`
	ArmorClassNotIn        []string `json:"armorClassNotIn,omitempty"`
	ArmorClassGT           *string  `json:"armorClassGT,omitempty"`
	ArmorClassGTE          *string  `json:"armorClassGTE,omitempty"`
	ArmorClassLT           *string  `json:"armorClassLT,omitempty"`
	ArmorClassLTE          *string  `json:"armorClassLTE,omitempty"`
	ArmorClassContains     *string  `json:"armorClassContains,omitempty"`
	ArmorClassHasPrefix    *string  `json:"armorClassHasPrefix,omitempty"`
	ArmorClassHasSuffix    *string  `json:"armorClassHasSuffix,omitempty"`
	ArmorClassEqualFold    *string  `json:"armorClassEqualFold,omitempty"`
	ArmorClassContainsFold *string  `json:"armorClassContainsFold,omitempty"`

	// "min_strength" field predicates.
	MinStrength      *int  `json:"minStrength,omitempty"`
	MinStrengthNEQ   *int  `json:"minStrengthNEQ,omitempty"`
	MinStrengthIn    []int `json:"minStrengthIn,omitempty"`
	MinStrengthNotIn []int `json:"minStrengthNotIn,omitempty"`
	MinStrengthGT    *int  `json:"minStrengthGT,omitempty"`
	MinStrengthGTE   *int  `json:"minStrengthGTE,omitempty"`
	MinStrengthLT    *int  `json:"minStrengthLT,omitempty"`
	MinStrengthLTE   *int  `json:"minStrengthLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArmorWhereInput) AddPredicates(predicates ...predicate.Armor) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArmorWhereInput filter on the ArmorQuery builder.
func (i *ArmorWhereInput) Filter(q *ArmorQuery) (*ArmorQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArmorWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArmorWhereInput is returned in case the ArmorWhereInput is empty.
var ErrEmptyArmorWhereInput = errors.New("ent: empty predicate ArmorWhereInput")

// P returns a predicate for filtering armors.
// An error is returned if the input is empty or invalid.
func (i *ArmorWhereInput) P() (predicate.Armor, error) {
	var predicates []predicate.Armor
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, armor.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Armor, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, armor.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Armor, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, armor.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, armor.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, armor.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, armor.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, armor.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, armor.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, armor.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, armor.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, armor.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, armor.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, armor.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, armor.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, armor.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, armor.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, armor.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, armor.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, armor.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, armor.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, armor.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, armor.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, armor.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, armor.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, armor.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, armor.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, armor.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, armor.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, armor.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, armor.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, armor.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, armor.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, armor.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, armor.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, armor.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, armor.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, armor.NameContainsFold(*i.NameContainsFold))
	}
	if i.Weight != nil {
		predicates = append(predicates, armor.WeightEQ(*i.Weight))
	}
	if i.WeightNEQ != nil {
		predicates = append(predicates, armor.WeightNEQ(*i.WeightNEQ))
	}
	if len(i.WeightIn) > 0 {
		predicates = append(predicates, armor.WeightIn(i.WeightIn...))
	}
	if len(i.WeightNotIn) > 0 {
		predicates = append(predicates, armor.WeightNotIn(i.WeightNotIn...))
	}
	if i.WeightGT != nil {
		predicates = append(predicates, armor.WeightGT(*i.WeightGT))
	}
	if i.WeightGTE != nil {
		predicates = append(predicates, armor.WeightGTE(*i.WeightGTE))
	}
	if i.WeightLT != nil {
		predicates = append(predicates, armor.WeightLT(*i.WeightLT))
	}
	if i.WeightLTE != nil {
		predicates = append(predicates, armor.WeightLTE(*i.WeightLTE))
	}
	if i.StealthDisadvantage != nil {
		predicates = append(predicates, armor.StealthDisadvantageEQ(*i.StealthDisadvantage))
	}
	if i.StealthDisadvantageNEQ != nil {
		predicates = append(predicates, armor.StealthDisadvantageNEQ(*i.StealthDisadvantageNEQ))
	}
	if i.ArmorClass != nil {
		predicates = append(predicates, armor.ArmorClassEQ(*i.ArmorClass))
	}
	if i.ArmorClassNEQ != nil {
		predicates = append(predicates, armor.ArmorClassNEQ(*i.ArmorClassNEQ))
	}
	if len(i.ArmorClassIn) > 0 {
		predicates = append(predicates, armor.ArmorClassIn(i.ArmorClassIn...))
	}
	if len(i.ArmorClassNotIn) > 0 {
		predicates = append(predicates, armor.ArmorClassNotIn(i.ArmorClassNotIn...))
	}
	if i.ArmorClassGT != nil {
		predicates = append(predicates, armor.ArmorClassGT(*i.ArmorClassGT))
	}
	if i.ArmorClassGTE != nil {
		predicates = append(predicates, armor.ArmorClassGTE(*i.ArmorClassGTE))
	}
	if i.ArmorClassLT != nil {
		predicates = append(predicates, armor.ArmorClassLT(*i.ArmorClassLT))
	}
	if i.ArmorClassLTE != nil {
		predicates = append(predicates, armor.ArmorClassLTE(*i.ArmorClassLTE))
	}
	if i.ArmorClassContains != nil {
		predicates = append(predicates, armor.ArmorClassContains(*i.ArmorClassContains))
	}
	if i.ArmorClassHasPrefix != nil {
		predicates = append(predicates, armor.ArmorClassHasPrefix(*i.ArmorClassHasPrefix))
	}
	if i.ArmorClassHasSuffix != nil {
		predicates = append(predicates, armor.ArmorClassHasSuffix(*i.ArmorClassHasSuffix))
	}
	if i.ArmorClassEqualFold != nil {
		predicates = append(predicates, armor.ArmorClassEqualFold(*i.ArmorClassEqualFold))
	}
	if i.ArmorClassContainsFold != nil {
		predicates = append(predicates, armor.ArmorClassContainsFold(*i.ArmorClassContainsFold))
	}
	if i.MinStrength != nil {
		predicates = append(predicates, armor.MinStrengthEQ(*i.MinStrength))
	}
	if i.MinStrengthNEQ != nil {
		predicates = append(predicates, armor.MinStrengthNEQ(*i.MinStrengthNEQ))
	}
	if len(i.MinStrengthIn) > 0 {
		predicates = append(predicates, armor.MinStrengthIn(i.MinStrengthIn...))
	}
	if len(i.MinStrengthNotIn) > 0 {
		predicates = append(predicates, armor.MinStrengthNotIn(i.MinStrengthNotIn...))
	}
	if i.MinStrengthGT != nil {
		predicates = append(predicates, armor.MinStrengthGT(*i.MinStrengthGT))
	}
	if i.MinStrengthGTE != nil {
		predicates = append(predicates, armor.MinStrengthGTE(*i.MinStrengthGTE))
	}
	if i.MinStrengthLT != nil {
		predicates = append(predicates, armor.MinStrengthLT(*i.MinStrengthLT))
	}
	if i.MinStrengthLTE != nil {
		predicates = append(predicates, armor.MinStrengthLTE(*i.MinStrengthLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArmorWhereInput
	case 1:
		return predicates[0], nil
	default:
		return armor.And(predicates...), nil
	}
}

// ClassWhereInput represents a where input for filtering Class queries.
type ClassWhereInput struct {
	Predicates []predicate.Class  `json:"-"`
	Not        *ClassWhereInput   `json:"not,omitempty"`
	Or         []*ClassWhereInput `json:"or,omitempty"`
	And        []*ClassWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "hit_die" field predicates.
	HitDie      *int  `json:"hitDie,omitempty"`
	HitDieNEQ   *int  `json:"hitDieNEQ,omitempty"`
	HitDieIn    []int `json:"hitDieIn,omitempty"`
	HitDieNotIn []int `json:"hitDieNotIn,omitempty"`
	HitDieGT    *int  `json:"hitDieGT,omitempty"`
	HitDieGTE   *int  `json:"hitDieGTE,omitempty"`
	HitDieLT    *int  `json:"hitDieLT,omitempty"`
	HitDieLTE   *int  `json:"hitDieLTE,omitempty"`

	// "saving_throws" edge predicates.
	HasSavingThrows     *bool                     `json:"hasSavingThrows,omitempty"`
	HasSavingThrowsWith []*AbilityScoreWhereInput `json:"hasSavingThrowsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ClassWhereInput) AddPredicates(predicates ...predicate.Class) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ClassWhereInput filter on the ClassQuery builder.
func (i *ClassWhereInput) Filter(q *ClassQuery) (*ClassQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyClassWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyClassWhereInput is returned in case the ClassWhereInput is empty.
var ErrEmptyClassWhereInput = errors.New("ent: empty predicate ClassWhereInput")

// P returns a predicate for filtering classes.
// An error is returned if the input is empty or invalid.
func (i *ClassWhereInput) P() (predicate.Class, error) {
	var predicates []predicate.Class
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, class.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Class, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, class.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Class, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, class.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, class.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, class.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, class.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, class.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, class.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, class.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, class.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, class.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, class.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, class.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, class.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, class.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, class.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, class.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, class.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, class.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, class.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, class.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, class.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, class.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, class.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, class.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, class.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, class.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, class.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, class.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, class.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, class.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, class.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, class.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, class.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, class.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, class.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, class.NameContainsFold(*i.NameContainsFold))
	}
	if i.HitDie != nil {
		predicates = append(predicates, class.HitDieEQ(*i.HitDie))
	}
	if i.HitDieNEQ != nil {
		predicates = append(predicates, class.HitDieNEQ(*i.HitDieNEQ))
	}
	if len(i.HitDieIn) > 0 {
		predicates = append(predicates, class.HitDieIn(i.HitDieIn...))
	}
	if len(i.HitDieNotIn) > 0 {
		predicates = append(predicates, class.HitDieNotIn(i.HitDieNotIn...))
	}
	if i.HitDieGT != nil {
		predicates = append(predicates, class.HitDieGT(*i.HitDieGT))
	}
	if i.HitDieGTE != nil {
		predicates = append(predicates, class.HitDieGTE(*i.HitDieGTE))
	}
	if i.HitDieLT != nil {
		predicates = append(predicates, class.HitDieLT(*i.HitDieLT))
	}
	if i.HitDieLTE != nil {
		predicates = append(predicates, class.HitDieLTE(*i.HitDieLTE))
	}

	if i.HasSavingThrows != nil {
		p := class.HasSavingThrows()
		if !*i.HasSavingThrows {
			p = class.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSavingThrowsWith) > 0 {
		with := make([]predicate.AbilityScore, 0, len(i.HasSavingThrowsWith))
		for _, w := range i.HasSavingThrowsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSavingThrowsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, class.HasSavingThrowsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyClassWhereInput
	case 1:
		return predicates[0], nil
	default:
		return class.And(predicates...), nil
	}
}

// DamageTypeWhereInput represents a where input for filtering DamageType queries.
type DamageTypeWhereInput struct {
	Predicates []predicate.DamageType  `json:"-"`
	Not        *DamageTypeWhereInput   `json:"not,omitempty"`
	Or         []*DamageTypeWhereInput `json:"or,omitempty"`
	And        []*DamageTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DamageTypeWhereInput) AddPredicates(predicates ...predicate.DamageType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DamageTypeWhereInput filter on the DamageTypeQuery builder.
func (i *DamageTypeWhereInput) Filter(q *DamageTypeQuery) (*DamageTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDamageTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDamageTypeWhereInput is returned in case the DamageTypeWhereInput is empty.
var ErrEmptyDamageTypeWhereInput = errors.New("ent: empty predicate DamageTypeWhereInput")

// P returns a predicate for filtering damagetypes.
// An error is returned if the input is empty or invalid.
func (i *DamageTypeWhereInput) P() (predicate.DamageType, error) {
	var predicates []predicate.DamageType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, damagetype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DamageType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, damagetype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DamageType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, damagetype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, damagetype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, damagetype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, damagetype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, damagetype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, damagetype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, damagetype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, damagetype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, damagetype.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, damagetype.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, damagetype.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, damagetype.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, damagetype.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, damagetype.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, damagetype.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, damagetype.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, damagetype.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, damagetype.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, damagetype.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, damagetype.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, damagetype.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, damagetype.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, damagetype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, damagetype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, damagetype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, damagetype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, damagetype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, damagetype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, damagetype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, damagetype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, damagetype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, damagetype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, damagetype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, damagetype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, damagetype.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDamageTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return damagetype.And(predicates...), nil
	}
}

// RaceWhereInput represents a where input for filtering Race queries.
type RaceWhereInput struct {
	Predicates []predicate.Race  `json:"-"`
	Not        *RaceWhereInput   `json:"not,omitempty"`
	Or         []*RaceWhereInput `json:"or,omitempty"`
	And        []*RaceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "speed" field predicates.
	Speed      *int  `json:"speed,omitempty"`
	SpeedNEQ   *int  `json:"speedNEQ,omitempty"`
	SpeedIn    []int `json:"speedIn,omitempty"`
	SpeedNotIn []int `json:"speedNotIn,omitempty"`
	SpeedGT    *int  `json:"speedGT,omitempty"`
	SpeedGTE   *int  `json:"speedGTE,omitempty"`
	SpeedLT    *int  `json:"speedLT,omitempty"`
	SpeedLTE   *int  `json:"speedLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RaceWhereInput) AddPredicates(predicates ...predicate.Race) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RaceWhereInput filter on the RaceQuery builder.
func (i *RaceWhereInput) Filter(q *RaceQuery) (*RaceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRaceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRaceWhereInput is returned in case the RaceWhereInput is empty.
var ErrEmptyRaceWhereInput = errors.New("ent: empty predicate RaceWhereInput")

// P returns a predicate for filtering races.
// An error is returned if the input is empty or invalid.
func (i *RaceWhereInput) P() (predicate.Race, error) {
	var predicates []predicate.Race
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, race.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Race, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, race.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Race, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, race.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, race.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, race.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, race.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, race.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, race.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, race.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, race.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, race.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, race.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, race.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, race.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, race.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, race.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, race.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, race.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, race.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, race.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, race.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, race.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, race.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, race.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, race.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, race.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, race.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, race.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, race.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, race.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, race.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, race.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, race.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, race.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, race.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, race.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, race.NameContainsFold(*i.NameContainsFold))
	}
	if i.Speed != nil {
		predicates = append(predicates, race.SpeedEQ(*i.Speed))
	}
	if i.SpeedNEQ != nil {
		predicates = append(predicates, race.SpeedNEQ(*i.SpeedNEQ))
	}
	if len(i.SpeedIn) > 0 {
		predicates = append(predicates, race.SpeedIn(i.SpeedIn...))
	}
	if len(i.SpeedNotIn) > 0 {
		predicates = append(predicates, race.SpeedNotIn(i.SpeedNotIn...))
	}
	if i.SpeedGT != nil {
		predicates = append(predicates, race.SpeedGT(*i.SpeedGT))
	}
	if i.SpeedGTE != nil {
		predicates = append(predicates, race.SpeedGTE(*i.SpeedGTE))
	}
	if i.SpeedLT != nil {
		predicates = append(predicates, race.SpeedLT(*i.SpeedLT))
	}
	if i.SpeedLTE != nil {
		predicates = append(predicates, race.SpeedLTE(*i.SpeedLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRaceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return race.And(predicates...), nil
	}
}

// SkillWhereInput represents a where input for filtering Skill queries.
type SkillWhereInput struct {
	Predicates []predicate.Skill  `json:"-"`
	Not        *SkillWhereInput   `json:"not,omitempty"`
	Or         []*SkillWhereInput `json:"or,omitempty"`
	And        []*SkillWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "ability_score" edge predicates.
	HasAbilityScore     *bool                     `json:"hasAbilityScore,omitempty"`
	HasAbilityScoreWith []*AbilityScoreWhereInput `json:"hasAbilityScoreWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SkillWhereInput) AddPredicates(predicates ...predicate.Skill) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SkillWhereInput filter on the SkillQuery builder.
func (i *SkillWhereInput) Filter(q *SkillQuery) (*SkillQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySkillWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySkillWhereInput is returned in case the SkillWhereInput is empty.
var ErrEmptySkillWhereInput = errors.New("ent: empty predicate SkillWhereInput")

// P returns a predicate for filtering skills.
// An error is returned if the input is empty or invalid.
func (i *SkillWhereInput) P() (predicate.Skill, error) {
	var predicates []predicate.Skill
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, skill.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Skill, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, skill.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Skill, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, skill.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, skill.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, skill.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, skill.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, skill.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, skill.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, skill.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, skill.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, skill.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, skill.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, skill.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, skill.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, skill.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, skill.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, skill.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, skill.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, skill.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, skill.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, skill.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, skill.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, skill.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, skill.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, skill.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, skill.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, skill.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, skill.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, skill.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, skill.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, skill.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, skill.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, skill.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, skill.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, skill.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, skill.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, skill.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasAbilityScore != nil {
		p := skill.HasAbilityScore()
		if !*i.HasAbilityScore {
			p = skill.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAbilityScoreWith) > 0 {
		with := make([]predicate.AbilityScore, 0, len(i.HasAbilityScoreWith))
		for _, w := range i.HasAbilityScoreWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAbilityScoreWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, skill.HasAbilityScoreWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySkillWhereInput
	case 1:
		return predicates[0], nil
	default:
		return skill.And(predicates...), nil
	}
}

// UnitValueWhereInput represents a where input for filtering UnitValue queries.
type UnitValueWhereInput struct {
	Predicates []predicate.UnitValue  `json:"-"`
	Not        *UnitValueWhereInput   `json:"not,omitempty"`
	Or         []*UnitValueWhereInput `json:"or,omitempty"`
	And        []*UnitValueWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "val" field predicates.
	Val      *int  `json:"val,omitempty"`
	ValNEQ   *int  `json:"valNEQ,omitempty"`
	ValIn    []int `json:"valIn,omitempty"`
	ValNotIn []int `json:"valNotIn,omitempty"`
	ValGT    *int  `json:"valGT,omitempty"`
	ValGTE   *int  `json:"valGTE,omitempty"`
	ValLT    *int  `json:"valLT,omitempty"`
	ValLTE   *int  `json:"valLTE,omitempty"`

	// "unit" field predicates.
	Unit             *string  `json:"unit,omitempty"`
	UnitNEQ          *string  `json:"unitNEQ,omitempty"`
	UnitIn           []string `json:"unitIn,omitempty"`
	UnitNotIn        []string `json:"unitNotIn,omitempty"`
	UnitGT           *string  `json:"unitGT,omitempty"`
	UnitGTE          *string  `json:"unitGTE,omitempty"`
	UnitLT           *string  `json:"unitLT,omitempty"`
	UnitLTE          *string  `json:"unitLTE,omitempty"`
	UnitContains     *string  `json:"unitContains,omitempty"`
	UnitHasPrefix    *string  `json:"unitHasPrefix,omitempty"`
	UnitHasSuffix    *string  `json:"unitHasSuffix,omitempty"`
	UnitEqualFold    *string  `json:"unitEqualFold,omitempty"`
	UnitContainsFold *string  `json:"unitContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UnitValueWhereInput) AddPredicates(predicates ...predicate.UnitValue) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UnitValueWhereInput filter on the UnitValueQuery builder.
func (i *UnitValueWhereInput) Filter(q *UnitValueQuery) (*UnitValueQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUnitValueWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUnitValueWhereInput is returned in case the UnitValueWhereInput is empty.
var ErrEmptyUnitValueWhereInput = errors.New("ent: empty predicate UnitValueWhereInput")

// P returns a predicate for filtering unitvalues.
// An error is returned if the input is empty or invalid.
func (i *UnitValueWhereInput) P() (predicate.UnitValue, error) {
	var predicates []predicate.UnitValue
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, unitvalue.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UnitValue, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, unitvalue.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UnitValue, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, unitvalue.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, unitvalue.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, unitvalue.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, unitvalue.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, unitvalue.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, unitvalue.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, unitvalue.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, unitvalue.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, unitvalue.IDLTE(*i.IDLTE))
	}
	if i.Val != nil {
		predicates = append(predicates, unitvalue.ValEQ(*i.Val))
	}
	if i.ValNEQ != nil {
		predicates = append(predicates, unitvalue.ValNEQ(*i.ValNEQ))
	}
	if len(i.ValIn) > 0 {
		predicates = append(predicates, unitvalue.ValIn(i.ValIn...))
	}
	if len(i.ValNotIn) > 0 {
		predicates = append(predicates, unitvalue.ValNotIn(i.ValNotIn...))
	}
	if i.ValGT != nil {
		predicates = append(predicates, unitvalue.ValGT(*i.ValGT))
	}
	if i.ValGTE != nil {
		predicates = append(predicates, unitvalue.ValGTE(*i.ValGTE))
	}
	if i.ValLT != nil {
		predicates = append(predicates, unitvalue.ValLT(*i.ValLT))
	}
	if i.ValLTE != nil {
		predicates = append(predicates, unitvalue.ValLTE(*i.ValLTE))
	}
	if i.Unit != nil {
		predicates = append(predicates, unitvalue.UnitEQ(*i.Unit))
	}
	if i.UnitNEQ != nil {
		predicates = append(predicates, unitvalue.UnitNEQ(*i.UnitNEQ))
	}
	if len(i.UnitIn) > 0 {
		predicates = append(predicates, unitvalue.UnitIn(i.UnitIn...))
	}
	if len(i.UnitNotIn) > 0 {
		predicates = append(predicates, unitvalue.UnitNotIn(i.UnitNotIn...))
	}
	if i.UnitGT != nil {
		predicates = append(predicates, unitvalue.UnitGT(*i.UnitGT))
	}
	if i.UnitGTE != nil {
		predicates = append(predicates, unitvalue.UnitGTE(*i.UnitGTE))
	}
	if i.UnitLT != nil {
		predicates = append(predicates, unitvalue.UnitLT(*i.UnitLT))
	}
	if i.UnitLTE != nil {
		predicates = append(predicates, unitvalue.UnitLTE(*i.UnitLTE))
	}
	if i.UnitContains != nil {
		predicates = append(predicates, unitvalue.UnitContains(*i.UnitContains))
	}
	if i.UnitHasPrefix != nil {
		predicates = append(predicates, unitvalue.UnitHasPrefix(*i.UnitHasPrefix))
	}
	if i.UnitHasSuffix != nil {
		predicates = append(predicates, unitvalue.UnitHasSuffix(*i.UnitHasSuffix))
	}
	if i.UnitEqualFold != nil {
		predicates = append(predicates, unitvalue.UnitEqualFold(*i.UnitEqualFold))
	}
	if i.UnitContainsFold != nil {
		predicates = append(predicates, unitvalue.UnitContainsFold(*i.UnitContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUnitValueWhereInput
	case 1:
		return predicates[0], nil
	default:
		return unitvalue.And(predicates...), nil
	}
}

// WeaponWhereInput represents a where input for filtering Weapon queries.
type WeaponWhereInput struct {
	Predicates []predicate.Weapon  `json:"-"`
	Not        *WeaponWhereInput   `json:"not,omitempty"`
	Or         []*WeaponWhereInput `json:"or,omitempty"`
	And        []*WeaponWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "weight" field predicates.
	Weight      *float64  `json:"weight,omitempty"`
	WeightNEQ   *float64  `json:"weightNEQ,omitempty"`
	WeightIn    []float64 `json:"weightIn,omitempty"`
	WeightNotIn []float64 `json:"weightNotIn,omitempty"`
	WeightGT    *float64  `json:"weightGT,omitempty"`
	WeightGTE   *float64  `json:"weightGTE,omitempty"`
	WeightLT    *float64  `json:"weightLT,omitempty"`
	WeightLTE   *float64  `json:"weightLTE,omitempty"`

	// "melee_range" edge predicates.
	HasMeleeRange     *bool                    `json:"hasMeleeRange,omitempty"`
	HasMeleeRangeWith []*WeaponRangeWhereInput `json:"hasMeleeRangeWith,omitempty"`

	// "throw_range" edge predicates.
	HasThrowRange     *bool                    `json:"hasThrowRange,omitempty"`
	HasThrowRangeWith []*WeaponRangeWhereInput `json:"hasThrowRangeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WeaponWhereInput) AddPredicates(predicates ...predicate.Weapon) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WeaponWhereInput filter on the WeaponQuery builder.
func (i *WeaponWhereInput) Filter(q *WeaponQuery) (*WeaponQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWeaponWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWeaponWhereInput is returned in case the WeaponWhereInput is empty.
var ErrEmptyWeaponWhereInput = errors.New("ent: empty predicate WeaponWhereInput")

// P returns a predicate for filtering weapons.
// An error is returned if the input is empty or invalid.
func (i *WeaponWhereInput) P() (predicate.Weapon, error) {
	var predicates []predicate.Weapon
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, weapon.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Weapon, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, weapon.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Weapon, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, weapon.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, weapon.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, weapon.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, weapon.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, weapon.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, weapon.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, weapon.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, weapon.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, weapon.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, weapon.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, weapon.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, weapon.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, weapon.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, weapon.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, weapon.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, weapon.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, weapon.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, weapon.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, weapon.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, weapon.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, weapon.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, weapon.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, weapon.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, weapon.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, weapon.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, weapon.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, weapon.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, weapon.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, weapon.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, weapon.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, weapon.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, weapon.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, weapon.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, weapon.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, weapon.NameContainsFold(*i.NameContainsFold))
	}
	if i.Weight != nil {
		predicates = append(predicates, weapon.WeightEQ(*i.Weight))
	}
	if i.WeightNEQ != nil {
		predicates = append(predicates, weapon.WeightNEQ(*i.WeightNEQ))
	}
	if len(i.WeightIn) > 0 {
		predicates = append(predicates, weapon.WeightIn(i.WeightIn...))
	}
	if len(i.WeightNotIn) > 0 {
		predicates = append(predicates, weapon.WeightNotIn(i.WeightNotIn...))
	}
	if i.WeightGT != nil {
		predicates = append(predicates, weapon.WeightGT(*i.WeightGT))
	}
	if i.WeightGTE != nil {
		predicates = append(predicates, weapon.WeightGTE(*i.WeightGTE))
	}
	if i.WeightLT != nil {
		predicates = append(predicates, weapon.WeightLT(*i.WeightLT))
	}
	if i.WeightLTE != nil {
		predicates = append(predicates, weapon.WeightLTE(*i.WeightLTE))
	}

	if i.HasMeleeRange != nil {
		p := weapon.HasMeleeRange()
		if !*i.HasMeleeRange {
			p = weapon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMeleeRangeWith) > 0 {
		with := make([]predicate.WeaponRange, 0, len(i.HasMeleeRangeWith))
		for _, w := range i.HasMeleeRangeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMeleeRangeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weapon.HasMeleeRangeWith(with...))
	}
	if i.HasThrowRange != nil {
		p := weapon.HasThrowRange()
		if !*i.HasThrowRange {
			p = weapon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasThrowRangeWith) > 0 {
		with := make([]predicate.WeaponRange, 0, len(i.HasThrowRangeWith))
		for _, w := range i.HasThrowRangeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasThrowRangeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weapon.HasThrowRangeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWeaponWhereInput
	case 1:
		return predicates[0], nil
	default:
		return weapon.And(predicates...), nil
	}
}

// WeaponDamageWhereInput represents a where input for filtering WeaponDamage queries.
type WeaponDamageWhereInput struct {
	Predicates []predicate.WeaponDamage  `json:"-"`
	Not        *WeaponDamageWhereInput   `json:"not,omitempty"`
	Or         []*WeaponDamageWhereInput `json:"or,omitempty"`
	And        []*WeaponDamageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "dice" field predicates.
	Dice             *string  `json:"dice,omitempty"`
	DiceNEQ          *string  `json:"diceNEQ,omitempty"`
	DiceIn           []string `json:"diceIn,omitempty"`
	DiceNotIn        []string `json:"diceNotIn,omitempty"`
	DiceGT           *string  `json:"diceGT,omitempty"`
	DiceGTE          *string  `json:"diceGTE,omitempty"`
	DiceLT           *string  `json:"diceLT,omitempty"`
	DiceLTE          *string  `json:"diceLTE,omitempty"`
	DiceContains     *string  `json:"diceContains,omitempty"`
	DiceHasPrefix    *string  `json:"diceHasPrefix,omitempty"`
	DiceHasSuffix    *string  `json:"diceHasSuffix,omitempty"`
	DiceEqualFold    *string  `json:"diceEqualFold,omitempty"`
	DiceContainsFold *string  `json:"diceContainsFold,omitempty"`

	// "damage_type" edge predicates.
	HasDamageType     *bool                   `json:"hasDamageType,omitempty"`
	HasDamageTypeWith []*DamageTypeWhereInput `json:"hasDamageTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WeaponDamageWhereInput) AddPredicates(predicates ...predicate.WeaponDamage) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WeaponDamageWhereInput filter on the WeaponDamageQuery builder.
func (i *WeaponDamageWhereInput) Filter(q *WeaponDamageQuery) (*WeaponDamageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWeaponDamageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWeaponDamageWhereInput is returned in case the WeaponDamageWhereInput is empty.
var ErrEmptyWeaponDamageWhereInput = errors.New("ent: empty predicate WeaponDamageWhereInput")

// P returns a predicate for filtering weapondamages.
// An error is returned if the input is empty or invalid.
func (i *WeaponDamageWhereInput) P() (predicate.WeaponDamage, error) {
	var predicates []predicate.WeaponDamage
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, weapondamage.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WeaponDamage, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, weapondamage.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WeaponDamage, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, weapondamage.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, weapondamage.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, weapondamage.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, weapondamage.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, weapondamage.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, weapondamage.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, weapondamage.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, weapondamage.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, weapondamage.IDLTE(*i.IDLTE))
	}
	if i.Dice != nil {
		predicates = append(predicates, weapondamage.DiceEQ(*i.Dice))
	}
	if i.DiceNEQ != nil {
		predicates = append(predicates, weapondamage.DiceNEQ(*i.DiceNEQ))
	}
	if len(i.DiceIn) > 0 {
		predicates = append(predicates, weapondamage.DiceIn(i.DiceIn...))
	}
	if len(i.DiceNotIn) > 0 {
		predicates = append(predicates, weapondamage.DiceNotIn(i.DiceNotIn...))
	}
	if i.DiceGT != nil {
		predicates = append(predicates, weapondamage.DiceGT(*i.DiceGT))
	}
	if i.DiceGTE != nil {
		predicates = append(predicates, weapondamage.DiceGTE(*i.DiceGTE))
	}
	if i.DiceLT != nil {
		predicates = append(predicates, weapondamage.DiceLT(*i.DiceLT))
	}
	if i.DiceLTE != nil {
		predicates = append(predicates, weapondamage.DiceLTE(*i.DiceLTE))
	}
	if i.DiceContains != nil {
		predicates = append(predicates, weapondamage.DiceContains(*i.DiceContains))
	}
	if i.DiceHasPrefix != nil {
		predicates = append(predicates, weapondamage.DiceHasPrefix(*i.DiceHasPrefix))
	}
	if i.DiceHasSuffix != nil {
		predicates = append(predicates, weapondamage.DiceHasSuffix(*i.DiceHasSuffix))
	}
	if i.DiceEqualFold != nil {
		predicates = append(predicates, weapondamage.DiceEqualFold(*i.DiceEqualFold))
	}
	if i.DiceContainsFold != nil {
		predicates = append(predicates, weapondamage.DiceContainsFold(*i.DiceContainsFold))
	}

	if i.HasDamageType != nil {
		p := weapondamage.HasDamageType()
		if !*i.HasDamageType {
			p = weapondamage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDamageTypeWith) > 0 {
		with := make([]predicate.DamageType, 0, len(i.HasDamageTypeWith))
		for _, w := range i.HasDamageTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDamageTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weapondamage.HasDamageTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWeaponDamageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return weapondamage.And(predicates...), nil
	}
}

// WeaponRangeWhereInput represents a where input for filtering WeaponRange queries.
type WeaponRangeWhereInput struct {
	Predicates []predicate.WeaponRange  `json:"-"`
	Not        *WeaponRangeWhereInput   `json:"not,omitempty"`
	Or         []*WeaponRangeWhereInput `json:"or,omitempty"`
	And        []*WeaponRangeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "normal" field predicates.
	Normal      *int  `json:"normal,omitempty"`
	NormalNEQ   *int  `json:"normalNEQ,omitempty"`
	NormalIn    []int `json:"normalIn,omitempty"`
	NormalNotIn []int `json:"normalNotIn,omitempty"`
	NormalGT    *int  `json:"normalGT,omitempty"`
	NormalGTE   *int  `json:"normalGTE,omitempty"`
	NormalLT    *int  `json:"normalLT,omitempty"`
	NormalLTE   *int  `json:"normalLTE,omitempty"`

	// "long" field predicates.
	Long      *int  `json:"long,omitempty"`
	LongNEQ   *int  `json:"longNEQ,omitempty"`
	LongIn    []int `json:"longIn,omitempty"`
	LongNotIn []int `json:"longNotIn,omitempty"`
	LongGT    *int  `json:"longGT,omitempty"`
	LongGTE   *int  `json:"longGTE,omitempty"`
	LongLT    *int  `json:"longLT,omitempty"`
	LongLTE   *int  `json:"longLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WeaponRangeWhereInput) AddPredicates(predicates ...predicate.WeaponRange) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WeaponRangeWhereInput filter on the WeaponRangeQuery builder.
func (i *WeaponRangeWhereInput) Filter(q *WeaponRangeQuery) (*WeaponRangeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWeaponRangeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWeaponRangeWhereInput is returned in case the WeaponRangeWhereInput is empty.
var ErrEmptyWeaponRangeWhereInput = errors.New("ent: empty predicate WeaponRangeWhereInput")

// P returns a predicate for filtering weaponranges.
// An error is returned if the input is empty or invalid.
func (i *WeaponRangeWhereInput) P() (predicate.WeaponRange, error) {
	var predicates []predicate.WeaponRange
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, weaponrange.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WeaponRange, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, weaponrange.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WeaponRange, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, weaponrange.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, weaponrange.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, weaponrange.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, weaponrange.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, weaponrange.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, weaponrange.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, weaponrange.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, weaponrange.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, weaponrange.IDLTE(*i.IDLTE))
	}
	if i.Normal != nil {
		predicates = append(predicates, weaponrange.NormalEQ(*i.Normal))
	}
	if i.NormalNEQ != nil {
		predicates = append(predicates, weaponrange.NormalNEQ(*i.NormalNEQ))
	}
	if len(i.NormalIn) > 0 {
		predicates = append(predicates, weaponrange.NormalIn(i.NormalIn...))
	}
	if len(i.NormalNotIn) > 0 {
		predicates = append(predicates, weaponrange.NormalNotIn(i.NormalNotIn...))
	}
	if i.NormalGT != nil {
		predicates = append(predicates, weaponrange.NormalGT(*i.NormalGT))
	}
	if i.NormalGTE != nil {
		predicates = append(predicates, weaponrange.NormalGTE(*i.NormalGTE))
	}
	if i.NormalLT != nil {
		predicates = append(predicates, weaponrange.NormalLT(*i.NormalLT))
	}
	if i.NormalLTE != nil {
		predicates = append(predicates, weaponrange.NormalLTE(*i.NormalLTE))
	}
	if i.Long != nil {
		predicates = append(predicates, weaponrange.LongEQ(*i.Long))
	}
	if i.LongNEQ != nil {
		predicates = append(predicates, weaponrange.LongNEQ(*i.LongNEQ))
	}
	if len(i.LongIn) > 0 {
		predicates = append(predicates, weaponrange.LongIn(i.LongIn...))
	}
	if len(i.LongNotIn) > 0 {
		predicates = append(predicates, weaponrange.LongNotIn(i.LongNotIn...))
	}
	if i.LongGT != nil {
		predicates = append(predicates, weaponrange.LongGT(*i.LongGT))
	}
	if i.LongGTE != nil {
		predicates = append(predicates, weaponrange.LongGTE(*i.LongGTE))
	}
	if i.LongLT != nil {
		predicates = append(predicates, weaponrange.LongLT(*i.LongLT))
	}
	if i.LongLTE != nil {
		predicates = append(predicates, weaponrange.LongLTE(*i.LongLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWeaponRangeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return weaponrange.And(predicates...), nil
	}
}
