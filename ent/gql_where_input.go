// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"github.com/ecshreve/dndgen/ent/abilitybonus"
	"github.com/ecshreve/dndgen/ent/abilityscore"
	"github.com/ecshreve/dndgen/ent/armor"
	"github.com/ecshreve/dndgen/ent/armorclass"
	"github.com/ecshreve/dndgen/ent/choice"
	"github.com/ecshreve/dndgen/ent/class"
	"github.com/ecshreve/dndgen/ent/cost"
	"github.com/ecshreve/dndgen/ent/damagetype"
	"github.com/ecshreve/dndgen/ent/equipment"
	"github.com/ecshreve/dndgen/ent/gear"
	"github.com/ecshreve/dndgen/ent/language"
	"github.com/ecshreve/dndgen/ent/magicschool"
	"github.com/ecshreve/dndgen/ent/predicate"
	"github.com/ecshreve/dndgen/ent/proficiency"
	"github.com/ecshreve/dndgen/ent/race"
	"github.com/ecshreve/dndgen/ent/rule"
	"github.com/ecshreve/dndgen/ent/rulesection"
	"github.com/ecshreve/dndgen/ent/skill"
	"github.com/ecshreve/dndgen/ent/subrace"
	"github.com/ecshreve/dndgen/ent/tool"
	"github.com/ecshreve/dndgen/ent/trait"
	"github.com/ecshreve/dndgen/ent/vehicle"
	"github.com/ecshreve/dndgen/ent/weapon"
	"github.com/ecshreve/dndgen/ent/weapondamage"
	"github.com/ecshreve/dndgen/ent/weaponproperty"
)

// AbilityBonusWhereInput represents a where input for filtering AbilityBonus queries.
type AbilityBonusWhereInput struct {
	Predicates []predicate.AbilityBonus  `json:"-"`
	Not        *AbilityBonusWhereInput   `json:"not,omitempty"`
	Or         []*AbilityBonusWhereInput `json:"or,omitempty"`
	And        []*AbilityBonusWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "ability_score_id" field predicates.
	AbilityScoreID      *int  `json:"abilityScoreID,omitempty"`
	AbilityScoreIDNEQ   *int  `json:"abilityScoreIDNEQ,omitempty"`
	AbilityScoreIDIn    []int `json:"abilityScoreIDIn,omitempty"`
	AbilityScoreIDNotIn []int `json:"abilityScoreIDNotIn,omitempty"`

	// "bonus" field predicates.
	Bonus      *int  `json:"bonus,omitempty"`
	BonusNEQ   *int  `json:"bonusNEQ,omitempty"`
	BonusIn    []int `json:"bonusIn,omitempty"`
	BonusNotIn []int `json:"bonusNotIn,omitempty"`
	BonusGT    *int  `json:"bonusGT,omitempty"`
	BonusGTE   *int  `json:"bonusGTE,omitempty"`
	BonusLT    *int  `json:"bonusLT,omitempty"`
	BonusLTE   *int  `json:"bonusLTE,omitempty"`

	// "ability_score" edge predicates.
	HasAbilityScore     *bool                     `json:"hasAbilityScore,omitempty"`
	HasAbilityScoreWith []*AbilityScoreWhereInput `json:"hasAbilityScoreWith,omitempty"`

	// "race" edge predicates.
	HasRace     *bool             `json:"hasRace,omitempty"`
	HasRaceWith []*RaceWhereInput `json:"hasRaceWith,omitempty"`

	// "subrace" edge predicates.
	HasSubrace     *bool                `json:"hasSubrace,omitempty"`
	HasSubraceWith []*SubraceWhereInput `json:"hasSubraceWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AbilityBonusWhereInput) AddPredicates(predicates ...predicate.AbilityBonus) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AbilityBonusWhereInput filter on the AbilityBonusQuery builder.
func (i *AbilityBonusWhereInput) Filter(q *AbilityBonusQuery) (*AbilityBonusQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAbilityBonusWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAbilityBonusWhereInput is returned in case the AbilityBonusWhereInput is empty.
var ErrEmptyAbilityBonusWhereInput = errors.New("ent: empty predicate AbilityBonusWhereInput")

// P returns a predicate for filtering abilitybonusslice.
// An error is returned if the input is empty or invalid.
func (i *AbilityBonusWhereInput) P() (predicate.AbilityBonus, error) {
	var predicates []predicate.AbilityBonus
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, abilitybonus.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AbilityBonus, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, abilitybonus.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AbilityBonus, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, abilitybonus.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, abilitybonus.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, abilitybonus.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, abilitybonus.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, abilitybonus.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, abilitybonus.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, abilitybonus.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, abilitybonus.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, abilitybonus.IDLTE(*i.IDLTE))
	}
	if i.AbilityScoreID != nil {
		predicates = append(predicates, abilitybonus.AbilityScoreIDEQ(*i.AbilityScoreID))
	}
	if i.AbilityScoreIDNEQ != nil {
		predicates = append(predicates, abilitybonus.AbilityScoreIDNEQ(*i.AbilityScoreIDNEQ))
	}
	if len(i.AbilityScoreIDIn) > 0 {
		predicates = append(predicates, abilitybonus.AbilityScoreIDIn(i.AbilityScoreIDIn...))
	}
	if len(i.AbilityScoreIDNotIn) > 0 {
		predicates = append(predicates, abilitybonus.AbilityScoreIDNotIn(i.AbilityScoreIDNotIn...))
	}
	if i.Bonus != nil {
		predicates = append(predicates, abilitybonus.BonusEQ(*i.Bonus))
	}
	if i.BonusNEQ != nil {
		predicates = append(predicates, abilitybonus.BonusNEQ(*i.BonusNEQ))
	}
	if len(i.BonusIn) > 0 {
		predicates = append(predicates, abilitybonus.BonusIn(i.BonusIn...))
	}
	if len(i.BonusNotIn) > 0 {
		predicates = append(predicates, abilitybonus.BonusNotIn(i.BonusNotIn...))
	}
	if i.BonusGT != nil {
		predicates = append(predicates, abilitybonus.BonusGT(*i.BonusGT))
	}
	if i.BonusGTE != nil {
		predicates = append(predicates, abilitybonus.BonusGTE(*i.BonusGTE))
	}
	if i.BonusLT != nil {
		predicates = append(predicates, abilitybonus.BonusLT(*i.BonusLT))
	}
	if i.BonusLTE != nil {
		predicates = append(predicates, abilitybonus.BonusLTE(*i.BonusLTE))
	}

	if i.HasAbilityScore != nil {
		p := abilitybonus.HasAbilityScore()
		if !*i.HasAbilityScore {
			p = abilitybonus.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAbilityScoreWith) > 0 {
		with := make([]predicate.AbilityScore, 0, len(i.HasAbilityScoreWith))
		for _, w := range i.HasAbilityScoreWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAbilityScoreWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, abilitybonus.HasAbilityScoreWith(with...))
	}
	if i.HasRace != nil {
		p := abilitybonus.HasRace()
		if !*i.HasRace {
			p = abilitybonus.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRaceWith) > 0 {
		with := make([]predicate.Race, 0, len(i.HasRaceWith))
		for _, w := range i.HasRaceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRaceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, abilitybonus.HasRaceWith(with...))
	}
	if i.HasSubrace != nil {
		p := abilitybonus.HasSubrace()
		if !*i.HasSubrace {
			p = abilitybonus.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubraceWith) > 0 {
		with := make([]predicate.Subrace, 0, len(i.HasSubraceWith))
		for _, w := range i.HasSubraceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubraceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, abilitybonus.HasSubraceWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAbilityBonusWhereInput
	case 1:
		return predicates[0], nil
	default:
		return abilitybonus.And(predicates...), nil
	}
}

// AbilityScoreWhereInput represents a where input for filtering AbilityScore queries.
type AbilityScoreWhereInput struct {
	Predicates []predicate.AbilityScore  `json:"-"`
	Not        *AbilityScoreWhereInput   `json:"not,omitempty"`
	Or         []*AbilityScoreWhereInput `json:"or,omitempty"`
	And        []*AbilityScoreWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "full_name" field predicates.
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNEQ          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGT           *string  `json:"fullNameGT,omitempty"`
	FullNameGTE          *string  `json:"fullNameGTE,omitempty"`
	FullNameLT           *string  `json:"fullNameLT,omitempty"`
	FullNameLTE          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`

	// "skills" edge predicates.
	HasSkills     *bool              `json:"hasSkills,omitempty"`
	HasSkillsWith []*SkillWhereInput `json:"hasSkillsWith,omitempty"`

	// "ability_bonuses" edge predicates.
	HasAbilityBonuses     *bool                     `json:"hasAbilityBonuses,omitempty"`
	HasAbilityBonusesWith []*AbilityBonusWhereInput `json:"hasAbilityBonusesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AbilityScoreWhereInput) AddPredicates(predicates ...predicate.AbilityScore) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AbilityScoreWhereInput filter on the AbilityScoreQuery builder.
func (i *AbilityScoreWhereInput) Filter(q *AbilityScoreQuery) (*AbilityScoreQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAbilityScoreWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAbilityScoreWhereInput is returned in case the AbilityScoreWhereInput is empty.
var ErrEmptyAbilityScoreWhereInput = errors.New("ent: empty predicate AbilityScoreWhereInput")

// P returns a predicate for filtering abilityscores.
// An error is returned if the input is empty or invalid.
func (i *AbilityScoreWhereInput) P() (predicate.AbilityScore, error) {
	var predicates []predicate.AbilityScore
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, abilityscore.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AbilityScore, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, abilityscore.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AbilityScore, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, abilityscore.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, abilityscore.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, abilityscore.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, abilityscore.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, abilityscore.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, abilityscore.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, abilityscore.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, abilityscore.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, abilityscore.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, abilityscore.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, abilityscore.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, abilityscore.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, abilityscore.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, abilityscore.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, abilityscore.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, abilityscore.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, abilityscore.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, abilityscore.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, abilityscore.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, abilityscore.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, abilityscore.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, abilityscore.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, abilityscore.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, abilityscore.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, abilityscore.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, abilityscore.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, abilityscore.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, abilityscore.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, abilityscore.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, abilityscore.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, abilityscore.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, abilityscore.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, abilityscore.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, abilityscore.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, abilityscore.NameContainsFold(*i.NameContainsFold))
	}
	if i.FullName != nil {
		predicates = append(predicates, abilityscore.FullNameEQ(*i.FullName))
	}
	if i.FullNameNEQ != nil {
		predicates = append(predicates, abilityscore.FullNameNEQ(*i.FullNameNEQ))
	}
	if len(i.FullNameIn) > 0 {
		predicates = append(predicates, abilityscore.FullNameIn(i.FullNameIn...))
	}
	if len(i.FullNameNotIn) > 0 {
		predicates = append(predicates, abilityscore.FullNameNotIn(i.FullNameNotIn...))
	}
	if i.FullNameGT != nil {
		predicates = append(predicates, abilityscore.FullNameGT(*i.FullNameGT))
	}
	if i.FullNameGTE != nil {
		predicates = append(predicates, abilityscore.FullNameGTE(*i.FullNameGTE))
	}
	if i.FullNameLT != nil {
		predicates = append(predicates, abilityscore.FullNameLT(*i.FullNameLT))
	}
	if i.FullNameLTE != nil {
		predicates = append(predicates, abilityscore.FullNameLTE(*i.FullNameLTE))
	}
	if i.FullNameContains != nil {
		predicates = append(predicates, abilityscore.FullNameContains(*i.FullNameContains))
	}
	if i.FullNameHasPrefix != nil {
		predicates = append(predicates, abilityscore.FullNameHasPrefix(*i.FullNameHasPrefix))
	}
	if i.FullNameHasSuffix != nil {
		predicates = append(predicates, abilityscore.FullNameHasSuffix(*i.FullNameHasSuffix))
	}
	if i.FullNameEqualFold != nil {
		predicates = append(predicates, abilityscore.FullNameEqualFold(*i.FullNameEqualFold))
	}
	if i.FullNameContainsFold != nil {
		predicates = append(predicates, abilityscore.FullNameContainsFold(*i.FullNameContainsFold))
	}

	if i.HasSkills != nil {
		p := abilityscore.HasSkills()
		if !*i.HasSkills {
			p = abilityscore.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSkillsWith) > 0 {
		with := make([]predicate.Skill, 0, len(i.HasSkillsWith))
		for _, w := range i.HasSkillsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSkillsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, abilityscore.HasSkillsWith(with...))
	}
	if i.HasAbilityBonuses != nil {
		p := abilityscore.HasAbilityBonuses()
		if !*i.HasAbilityBonuses {
			p = abilityscore.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAbilityBonusesWith) > 0 {
		with := make([]predicate.AbilityBonus, 0, len(i.HasAbilityBonusesWith))
		for _, w := range i.HasAbilityBonusesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAbilityBonusesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, abilityscore.HasAbilityBonusesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAbilityScoreWhereInput
	case 1:
		return predicates[0], nil
	default:
		return abilityscore.And(predicates...), nil
	}
}

// ArmorWhereInput represents a where input for filtering Armor queries.
type ArmorWhereInput struct {
	Predicates []predicate.Armor  `json:"-"`
	Not        *ArmorWhereInput   `json:"not,omitempty"`
	Or         []*ArmorWhereInput `json:"or,omitempty"`
	And        []*ArmorWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "armor_category" field predicates.
	ArmorCategory             *string  `json:"armorCategory,omitempty"`
	ArmorCategoryNEQ          *string  `json:"armorCategoryNEQ,omitempty"`
	ArmorCategoryIn           []string `json:"armorCategoryIn,omitempty"`
	ArmorCategoryNotIn        []string `json:"armorCategoryNotIn,omitempty"`
	ArmorCategoryGT           *string  `json:"armorCategoryGT,omitempty"`
	ArmorCategoryGTE          *string  `json:"armorCategoryGTE,omitempty"`
	ArmorCategoryLT           *string  `json:"armorCategoryLT,omitempty"`
	ArmorCategoryLTE          *string  `json:"armorCategoryLTE,omitempty"`
	ArmorCategoryContains     *string  `json:"armorCategoryContains,omitempty"`
	ArmorCategoryHasPrefix    *string  `json:"armorCategoryHasPrefix,omitempty"`
	ArmorCategoryHasSuffix    *string  `json:"armorCategoryHasSuffix,omitempty"`
	ArmorCategoryEqualFold    *string  `json:"armorCategoryEqualFold,omitempty"`
	ArmorCategoryContainsFold *string  `json:"armorCategoryContainsFold,omitempty"`

	// "stealth_disadvantage" field predicates.
	StealthDisadvantage    *bool `json:"stealthDisadvantage,omitempty"`
	StealthDisadvantageNEQ *bool `json:"stealthDisadvantageNEQ,omitempty"`

	// "min_strength" field predicates.
	MinStrength      *int  `json:"minStrength,omitempty"`
	MinStrengthNEQ   *int  `json:"minStrengthNEQ,omitempty"`
	MinStrengthIn    []int `json:"minStrengthIn,omitempty"`
	MinStrengthNotIn []int `json:"minStrengthNotIn,omitempty"`
	MinStrengthGT    *int  `json:"minStrengthGT,omitempty"`
	MinStrengthGTE   *int  `json:"minStrengthGTE,omitempty"`
	MinStrengthLT    *int  `json:"minStrengthLT,omitempty"`
	MinStrengthLTE   *int  `json:"minStrengthLTE,omitempty"`

	// "equipment_id" field predicates.
	EquipmentID      *int  `json:"equipmentID,omitempty"`
	EquipmentIDNEQ   *int  `json:"equipmentIDNEQ,omitempty"`
	EquipmentIDIn    []int `json:"equipmentIDIn,omitempty"`
	EquipmentIDNotIn []int `json:"equipmentIDNotIn,omitempty"`

	// "equipment" edge predicates.
	HasEquipment     *bool                  `json:"hasEquipment,omitempty"`
	HasEquipmentWith []*EquipmentWhereInput `json:"hasEquipmentWith,omitempty"`

	// "armor_class" edge predicates.
	HasArmorClass     *bool                   `json:"hasArmorClass,omitempty"`
	HasArmorClassWith []*ArmorClassWhereInput `json:"hasArmorClassWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArmorWhereInput) AddPredicates(predicates ...predicate.Armor) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArmorWhereInput filter on the ArmorQuery builder.
func (i *ArmorWhereInput) Filter(q *ArmorQuery) (*ArmorQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArmorWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArmorWhereInput is returned in case the ArmorWhereInput is empty.
var ErrEmptyArmorWhereInput = errors.New("ent: empty predicate ArmorWhereInput")

// P returns a predicate for filtering armors.
// An error is returned if the input is empty or invalid.
func (i *ArmorWhereInput) P() (predicate.Armor, error) {
	var predicates []predicate.Armor
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, armor.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Armor, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, armor.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Armor, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, armor.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, armor.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, armor.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, armor.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, armor.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, armor.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, armor.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, armor.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, armor.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, armor.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, armor.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, armor.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, armor.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, armor.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, armor.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, armor.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, armor.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, armor.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, armor.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, armor.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, armor.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, armor.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, armor.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, armor.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, armor.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, armor.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, armor.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, armor.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, armor.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, armor.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, armor.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, armor.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, armor.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, armor.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, armor.NameContainsFold(*i.NameContainsFold))
	}
	if i.ArmorCategory != nil {
		predicates = append(predicates, armor.ArmorCategoryEQ(*i.ArmorCategory))
	}
	if i.ArmorCategoryNEQ != nil {
		predicates = append(predicates, armor.ArmorCategoryNEQ(*i.ArmorCategoryNEQ))
	}
	if len(i.ArmorCategoryIn) > 0 {
		predicates = append(predicates, armor.ArmorCategoryIn(i.ArmorCategoryIn...))
	}
	if len(i.ArmorCategoryNotIn) > 0 {
		predicates = append(predicates, armor.ArmorCategoryNotIn(i.ArmorCategoryNotIn...))
	}
	if i.ArmorCategoryGT != nil {
		predicates = append(predicates, armor.ArmorCategoryGT(*i.ArmorCategoryGT))
	}
	if i.ArmorCategoryGTE != nil {
		predicates = append(predicates, armor.ArmorCategoryGTE(*i.ArmorCategoryGTE))
	}
	if i.ArmorCategoryLT != nil {
		predicates = append(predicates, armor.ArmorCategoryLT(*i.ArmorCategoryLT))
	}
	if i.ArmorCategoryLTE != nil {
		predicates = append(predicates, armor.ArmorCategoryLTE(*i.ArmorCategoryLTE))
	}
	if i.ArmorCategoryContains != nil {
		predicates = append(predicates, armor.ArmorCategoryContains(*i.ArmorCategoryContains))
	}
	if i.ArmorCategoryHasPrefix != nil {
		predicates = append(predicates, armor.ArmorCategoryHasPrefix(*i.ArmorCategoryHasPrefix))
	}
	if i.ArmorCategoryHasSuffix != nil {
		predicates = append(predicates, armor.ArmorCategoryHasSuffix(*i.ArmorCategoryHasSuffix))
	}
	if i.ArmorCategoryEqualFold != nil {
		predicates = append(predicates, armor.ArmorCategoryEqualFold(*i.ArmorCategoryEqualFold))
	}
	if i.ArmorCategoryContainsFold != nil {
		predicates = append(predicates, armor.ArmorCategoryContainsFold(*i.ArmorCategoryContainsFold))
	}
	if i.StealthDisadvantage != nil {
		predicates = append(predicates, armor.StealthDisadvantageEQ(*i.StealthDisadvantage))
	}
	if i.StealthDisadvantageNEQ != nil {
		predicates = append(predicates, armor.StealthDisadvantageNEQ(*i.StealthDisadvantageNEQ))
	}
	if i.MinStrength != nil {
		predicates = append(predicates, armor.MinStrengthEQ(*i.MinStrength))
	}
	if i.MinStrengthNEQ != nil {
		predicates = append(predicates, armor.MinStrengthNEQ(*i.MinStrengthNEQ))
	}
	if len(i.MinStrengthIn) > 0 {
		predicates = append(predicates, armor.MinStrengthIn(i.MinStrengthIn...))
	}
	if len(i.MinStrengthNotIn) > 0 {
		predicates = append(predicates, armor.MinStrengthNotIn(i.MinStrengthNotIn...))
	}
	if i.MinStrengthGT != nil {
		predicates = append(predicates, armor.MinStrengthGT(*i.MinStrengthGT))
	}
	if i.MinStrengthGTE != nil {
		predicates = append(predicates, armor.MinStrengthGTE(*i.MinStrengthGTE))
	}
	if i.MinStrengthLT != nil {
		predicates = append(predicates, armor.MinStrengthLT(*i.MinStrengthLT))
	}
	if i.MinStrengthLTE != nil {
		predicates = append(predicates, armor.MinStrengthLTE(*i.MinStrengthLTE))
	}
	if i.EquipmentID != nil {
		predicates = append(predicates, armor.EquipmentIDEQ(*i.EquipmentID))
	}
	if i.EquipmentIDNEQ != nil {
		predicates = append(predicates, armor.EquipmentIDNEQ(*i.EquipmentIDNEQ))
	}
	if len(i.EquipmentIDIn) > 0 {
		predicates = append(predicates, armor.EquipmentIDIn(i.EquipmentIDIn...))
	}
	if len(i.EquipmentIDNotIn) > 0 {
		predicates = append(predicates, armor.EquipmentIDNotIn(i.EquipmentIDNotIn...))
	}

	if i.HasEquipment != nil {
		p := armor.HasEquipment()
		if !*i.HasEquipment {
			p = armor.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentWith))
		for _, w := range i.HasEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, armor.HasEquipmentWith(with...))
	}
	if i.HasArmorClass != nil {
		p := armor.HasArmorClass()
		if !*i.HasArmorClass {
			p = armor.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArmorClassWith) > 0 {
		with := make([]predicate.ArmorClass, 0, len(i.HasArmorClassWith))
		for _, w := range i.HasArmorClassWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArmorClassWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, armor.HasArmorClassWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArmorWhereInput
	case 1:
		return predicates[0], nil
	default:
		return armor.And(predicates...), nil
	}
}

// ArmorClassWhereInput represents a where input for filtering ArmorClass queries.
type ArmorClassWhereInput struct {
	Predicates []predicate.ArmorClass  `json:"-"`
	Not        *ArmorClassWhereInput   `json:"not,omitempty"`
	Or         []*ArmorClassWhereInput `json:"or,omitempty"`
	And        []*ArmorClassWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "base" field predicates.
	Base      *int  `json:"base,omitempty"`
	BaseNEQ   *int  `json:"baseNEQ,omitempty"`
	BaseIn    []int `json:"baseIn,omitempty"`
	BaseNotIn []int `json:"baseNotIn,omitempty"`
	BaseGT    *int  `json:"baseGT,omitempty"`
	BaseGTE   *int  `json:"baseGTE,omitempty"`
	BaseLT    *int  `json:"baseLT,omitempty"`
	BaseLTE   *int  `json:"baseLTE,omitempty"`

	// "dex_bonus" field predicates.
	DexBonus    *bool `json:"dexBonus,omitempty"`
	DexBonusNEQ *bool `json:"dexBonusNEQ,omitempty"`

	// "max_bonus" field predicates.
	MaxBonus       *int  `json:"maxBonus,omitempty"`
	MaxBonusNEQ    *int  `json:"maxBonusNEQ,omitempty"`
	MaxBonusIn     []int `json:"maxBonusIn,omitempty"`
	MaxBonusNotIn  []int `json:"maxBonusNotIn,omitempty"`
	MaxBonusGT     *int  `json:"maxBonusGT,omitempty"`
	MaxBonusGTE    *int  `json:"maxBonusGTE,omitempty"`
	MaxBonusLT     *int  `json:"maxBonusLT,omitempty"`
	MaxBonusLTE    *int  `json:"maxBonusLTE,omitempty"`
	MaxBonusIsNil  bool  `json:"maxBonusIsNil,omitempty"`
	MaxBonusNotNil bool  `json:"maxBonusNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ArmorClassWhereInput) AddPredicates(predicates ...predicate.ArmorClass) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ArmorClassWhereInput filter on the ArmorClassQuery builder.
func (i *ArmorClassWhereInput) Filter(q *ArmorClassQuery) (*ArmorClassQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyArmorClassWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyArmorClassWhereInput is returned in case the ArmorClassWhereInput is empty.
var ErrEmptyArmorClassWhereInput = errors.New("ent: empty predicate ArmorClassWhereInput")

// P returns a predicate for filtering armorclasses.
// An error is returned if the input is empty or invalid.
func (i *ArmorClassWhereInput) P() (predicate.ArmorClass, error) {
	var predicates []predicate.ArmorClass
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, armorclass.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ArmorClass, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, armorclass.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ArmorClass, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, armorclass.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, armorclass.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, armorclass.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, armorclass.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, armorclass.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, armorclass.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, armorclass.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, armorclass.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, armorclass.IDLTE(*i.IDLTE))
	}
	if i.Base != nil {
		predicates = append(predicates, armorclass.BaseEQ(*i.Base))
	}
	if i.BaseNEQ != nil {
		predicates = append(predicates, armorclass.BaseNEQ(*i.BaseNEQ))
	}
	if len(i.BaseIn) > 0 {
		predicates = append(predicates, armorclass.BaseIn(i.BaseIn...))
	}
	if len(i.BaseNotIn) > 0 {
		predicates = append(predicates, armorclass.BaseNotIn(i.BaseNotIn...))
	}
	if i.BaseGT != nil {
		predicates = append(predicates, armorclass.BaseGT(*i.BaseGT))
	}
	if i.BaseGTE != nil {
		predicates = append(predicates, armorclass.BaseGTE(*i.BaseGTE))
	}
	if i.BaseLT != nil {
		predicates = append(predicates, armorclass.BaseLT(*i.BaseLT))
	}
	if i.BaseLTE != nil {
		predicates = append(predicates, armorclass.BaseLTE(*i.BaseLTE))
	}
	if i.DexBonus != nil {
		predicates = append(predicates, armorclass.DexBonusEQ(*i.DexBonus))
	}
	if i.DexBonusNEQ != nil {
		predicates = append(predicates, armorclass.DexBonusNEQ(*i.DexBonusNEQ))
	}
	if i.MaxBonus != nil {
		predicates = append(predicates, armorclass.MaxBonusEQ(*i.MaxBonus))
	}
	if i.MaxBonusNEQ != nil {
		predicates = append(predicates, armorclass.MaxBonusNEQ(*i.MaxBonusNEQ))
	}
	if len(i.MaxBonusIn) > 0 {
		predicates = append(predicates, armorclass.MaxBonusIn(i.MaxBonusIn...))
	}
	if len(i.MaxBonusNotIn) > 0 {
		predicates = append(predicates, armorclass.MaxBonusNotIn(i.MaxBonusNotIn...))
	}
	if i.MaxBonusGT != nil {
		predicates = append(predicates, armorclass.MaxBonusGT(*i.MaxBonusGT))
	}
	if i.MaxBonusGTE != nil {
		predicates = append(predicates, armorclass.MaxBonusGTE(*i.MaxBonusGTE))
	}
	if i.MaxBonusLT != nil {
		predicates = append(predicates, armorclass.MaxBonusLT(*i.MaxBonusLT))
	}
	if i.MaxBonusLTE != nil {
		predicates = append(predicates, armorclass.MaxBonusLTE(*i.MaxBonusLTE))
	}
	if i.MaxBonusIsNil {
		predicates = append(predicates, armorclass.MaxBonusIsNil())
	}
	if i.MaxBonusNotNil {
		predicates = append(predicates, armorclass.MaxBonusNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyArmorClassWhereInput
	case 1:
		return predicates[0], nil
	default:
		return armorclass.And(predicates...), nil
	}
}

// ChoiceWhereInput represents a where input for filtering Choice queries.
type ChoiceWhereInput struct {
	Predicates []predicate.Choice  `json:"-"`
	Not        *ChoiceWhereInput   `json:"not,omitempty"`
	Or         []*ChoiceWhereInput `json:"or,omitempty"`
	And        []*ChoiceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "choose" field predicates.
	Choose      *int  `json:"choose,omitempty"`
	ChooseNEQ   *int  `json:"chooseNEQ,omitempty"`
	ChooseIn    []int `json:"chooseIn,omitempty"`
	ChooseNotIn []int `json:"chooseNotIn,omitempty"`
	ChooseGT    *int  `json:"chooseGT,omitempty"`
	ChooseGTE   *int  `json:"chooseGTE,omitempty"`
	ChooseLT    *int  `json:"chooseLT,omitempty"`
	ChooseLTE   *int  `json:"chooseLTE,omitempty"`

	// "desc" field predicates.
	Desc             *string  `json:"desc,omitempty"`
	DescNEQ          *string  `json:"descNEQ,omitempty"`
	DescIn           []string `json:"descIn,omitempty"`
	DescNotIn        []string `json:"descNotIn,omitempty"`
	DescGT           *string  `json:"descGT,omitempty"`
	DescGTE          *string  `json:"descGTE,omitempty"`
	DescLT           *string  `json:"descLT,omitempty"`
	DescLTE          *string  `json:"descLTE,omitempty"`
	DescContains     *string  `json:"descContains,omitempty"`
	DescHasPrefix    *string  `json:"descHasPrefix,omitempty"`
	DescHasSuffix    *string  `json:"descHasSuffix,omitempty"`
	DescIsNil        bool     `json:"descIsNil,omitempty"`
	DescNotNil       bool     `json:"descNotNil,omitempty"`
	DescEqualFold    *string  `json:"descEqualFold,omitempty"`
	DescContainsFold *string  `json:"descContainsFold,omitempty"`

	// "parent_choice" edge predicates.
	HasParentChoice     *bool               `json:"hasParentChoice,omitempty"`
	HasParentChoiceWith []*ChoiceWhereInput `json:"hasParentChoiceWith,omitempty"`

	// "choices" edge predicates.
	HasChoices     *bool               `json:"hasChoices,omitempty"`
	HasChoicesWith []*ChoiceWhereInput `json:"hasChoicesWith,omitempty"`

	// "proficiency_options" edge predicates.
	HasProficiencyOptions     *bool                    `json:"hasProficiencyOptions,omitempty"`
	HasProficiencyOptionsWith []*ProficiencyWhereInput `json:"hasProficiencyOptionsWith,omitempty"`

	// "starting_equipment_options" edge predicates.
	HasStartingEquipmentOptions     *bool                  `json:"hasStartingEquipmentOptions,omitempty"`
	HasStartingEquipmentOptionsWith []*EquipmentWhereInput `json:"hasStartingEquipmentOptionsWith,omitempty"`

	// "class" edge predicates.
	HasClass     *bool              `json:"hasClass,omitempty"`
	HasClassWith []*ClassWhereInput `json:"hasClassWith,omitempty"`

	// "race" edge predicates.
	HasRace     *bool             `json:"hasRace,omitempty"`
	HasRaceWith []*RaceWhereInput `json:"hasRaceWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChoiceWhereInput) AddPredicates(predicates ...predicate.Choice) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChoiceWhereInput filter on the ChoiceQuery builder.
func (i *ChoiceWhereInput) Filter(q *ChoiceQuery) (*ChoiceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChoiceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChoiceWhereInput is returned in case the ChoiceWhereInput is empty.
var ErrEmptyChoiceWhereInput = errors.New("ent: empty predicate ChoiceWhereInput")

// P returns a predicate for filtering choices.
// An error is returned if the input is empty or invalid.
func (i *ChoiceWhereInput) P() (predicate.Choice, error) {
	var predicates []predicate.Choice
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, choice.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Choice, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, choice.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Choice, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, choice.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, choice.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, choice.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, choice.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, choice.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, choice.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, choice.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, choice.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, choice.IDLTE(*i.IDLTE))
	}
	if i.Choose != nil {
		predicates = append(predicates, choice.ChooseEQ(*i.Choose))
	}
	if i.ChooseNEQ != nil {
		predicates = append(predicates, choice.ChooseNEQ(*i.ChooseNEQ))
	}
	if len(i.ChooseIn) > 0 {
		predicates = append(predicates, choice.ChooseIn(i.ChooseIn...))
	}
	if len(i.ChooseNotIn) > 0 {
		predicates = append(predicates, choice.ChooseNotIn(i.ChooseNotIn...))
	}
	if i.ChooseGT != nil {
		predicates = append(predicates, choice.ChooseGT(*i.ChooseGT))
	}
	if i.ChooseGTE != nil {
		predicates = append(predicates, choice.ChooseGTE(*i.ChooseGTE))
	}
	if i.ChooseLT != nil {
		predicates = append(predicates, choice.ChooseLT(*i.ChooseLT))
	}
	if i.ChooseLTE != nil {
		predicates = append(predicates, choice.ChooseLTE(*i.ChooseLTE))
	}
	if i.Desc != nil {
		predicates = append(predicates, choice.DescEQ(*i.Desc))
	}
	if i.DescNEQ != nil {
		predicates = append(predicates, choice.DescNEQ(*i.DescNEQ))
	}
	if len(i.DescIn) > 0 {
		predicates = append(predicates, choice.DescIn(i.DescIn...))
	}
	if len(i.DescNotIn) > 0 {
		predicates = append(predicates, choice.DescNotIn(i.DescNotIn...))
	}
	if i.DescGT != nil {
		predicates = append(predicates, choice.DescGT(*i.DescGT))
	}
	if i.DescGTE != nil {
		predicates = append(predicates, choice.DescGTE(*i.DescGTE))
	}
	if i.DescLT != nil {
		predicates = append(predicates, choice.DescLT(*i.DescLT))
	}
	if i.DescLTE != nil {
		predicates = append(predicates, choice.DescLTE(*i.DescLTE))
	}
	if i.DescContains != nil {
		predicates = append(predicates, choice.DescContains(*i.DescContains))
	}
	if i.DescHasPrefix != nil {
		predicates = append(predicates, choice.DescHasPrefix(*i.DescHasPrefix))
	}
	if i.DescHasSuffix != nil {
		predicates = append(predicates, choice.DescHasSuffix(*i.DescHasSuffix))
	}
	if i.DescIsNil {
		predicates = append(predicates, choice.DescIsNil())
	}
	if i.DescNotNil {
		predicates = append(predicates, choice.DescNotNil())
	}
	if i.DescEqualFold != nil {
		predicates = append(predicates, choice.DescEqualFold(*i.DescEqualFold))
	}
	if i.DescContainsFold != nil {
		predicates = append(predicates, choice.DescContainsFold(*i.DescContainsFold))
	}

	if i.HasParentChoice != nil {
		p := choice.HasParentChoice()
		if !*i.HasParentChoice {
			p = choice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentChoiceWith) > 0 {
		with := make([]predicate.Choice, 0, len(i.HasParentChoiceWith))
		for _, w := range i.HasParentChoiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentChoiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, choice.HasParentChoiceWith(with...))
	}
	if i.HasChoices != nil {
		p := choice.HasChoices()
		if !*i.HasChoices {
			p = choice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChoicesWith) > 0 {
		with := make([]predicate.Choice, 0, len(i.HasChoicesWith))
		for _, w := range i.HasChoicesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChoicesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, choice.HasChoicesWith(with...))
	}
	if i.HasProficiencyOptions != nil {
		p := choice.HasProficiencyOptions()
		if !*i.HasProficiencyOptions {
			p = choice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProficiencyOptionsWith) > 0 {
		with := make([]predicate.Proficiency, 0, len(i.HasProficiencyOptionsWith))
		for _, w := range i.HasProficiencyOptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProficiencyOptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, choice.HasProficiencyOptionsWith(with...))
	}
	if i.HasStartingEquipmentOptions != nil {
		p := choice.HasStartingEquipmentOptions()
		if !*i.HasStartingEquipmentOptions {
			p = choice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStartingEquipmentOptionsWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasStartingEquipmentOptionsWith))
		for _, w := range i.HasStartingEquipmentOptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStartingEquipmentOptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, choice.HasStartingEquipmentOptionsWith(with...))
	}
	if i.HasClass != nil {
		p := choice.HasClass()
		if !*i.HasClass {
			p = choice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClassWith) > 0 {
		with := make([]predicate.Class, 0, len(i.HasClassWith))
		for _, w := range i.HasClassWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasClassWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, choice.HasClassWith(with...))
	}
	if i.HasRace != nil {
		p := choice.HasRace()
		if !*i.HasRace {
			p = choice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRaceWith) > 0 {
		with := make([]predicate.Race, 0, len(i.HasRaceWith))
		for _, w := range i.HasRaceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRaceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, choice.HasRaceWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChoiceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return choice.And(predicates...), nil
	}
}

// ClassWhereInput represents a where input for filtering Class queries.
type ClassWhereInput struct {
	Predicates []predicate.Class  `json:"-"`
	Not        *ClassWhereInput   `json:"not,omitempty"`
	Or         []*ClassWhereInput `json:"or,omitempty"`
	And        []*ClassWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "hit_die" field predicates.
	HitDie      *int  `json:"hitDie,omitempty"`
	HitDieNEQ   *int  `json:"hitDieNEQ,omitempty"`
	HitDieIn    []int `json:"hitDieIn,omitempty"`
	HitDieNotIn []int `json:"hitDieNotIn,omitempty"`
	HitDieGT    *int  `json:"hitDieGT,omitempty"`
	HitDieGTE   *int  `json:"hitDieGTE,omitempty"`
	HitDieLT    *int  `json:"hitDieLT,omitempty"`
	HitDieLTE   *int  `json:"hitDieLTE,omitempty"`

	// "proficiencies" edge predicates.
	HasProficiencies     *bool                    `json:"hasProficiencies,omitempty"`
	HasProficienciesWith []*ProficiencyWhereInput `json:"hasProficienciesWith,omitempty"`

	// "proficiency_choices" edge predicates.
	HasProficiencyChoices     *bool               `json:"hasProficiencyChoices,omitempty"`
	HasProficiencyChoicesWith []*ChoiceWhereInput `json:"hasProficiencyChoicesWith,omitempty"`

	// "starting_equipment" edge predicates.
	HasStartingEquipment     *bool                  `json:"hasStartingEquipment,omitempty"`
	HasStartingEquipmentWith []*EquipmentWhereInput `json:"hasStartingEquipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ClassWhereInput) AddPredicates(predicates ...predicate.Class) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ClassWhereInput filter on the ClassQuery builder.
func (i *ClassWhereInput) Filter(q *ClassQuery) (*ClassQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyClassWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyClassWhereInput is returned in case the ClassWhereInput is empty.
var ErrEmptyClassWhereInput = errors.New("ent: empty predicate ClassWhereInput")

// P returns a predicate for filtering classes.
// An error is returned if the input is empty or invalid.
func (i *ClassWhereInput) P() (predicate.Class, error) {
	var predicates []predicate.Class
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, class.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Class, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, class.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Class, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, class.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, class.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, class.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, class.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, class.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, class.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, class.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, class.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, class.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, class.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, class.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, class.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, class.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, class.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, class.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, class.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, class.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, class.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, class.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, class.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, class.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, class.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, class.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, class.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, class.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, class.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, class.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, class.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, class.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, class.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, class.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, class.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, class.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, class.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, class.NameContainsFold(*i.NameContainsFold))
	}
	if i.HitDie != nil {
		predicates = append(predicates, class.HitDieEQ(*i.HitDie))
	}
	if i.HitDieNEQ != nil {
		predicates = append(predicates, class.HitDieNEQ(*i.HitDieNEQ))
	}
	if len(i.HitDieIn) > 0 {
		predicates = append(predicates, class.HitDieIn(i.HitDieIn...))
	}
	if len(i.HitDieNotIn) > 0 {
		predicates = append(predicates, class.HitDieNotIn(i.HitDieNotIn...))
	}
	if i.HitDieGT != nil {
		predicates = append(predicates, class.HitDieGT(*i.HitDieGT))
	}
	if i.HitDieGTE != nil {
		predicates = append(predicates, class.HitDieGTE(*i.HitDieGTE))
	}
	if i.HitDieLT != nil {
		predicates = append(predicates, class.HitDieLT(*i.HitDieLT))
	}
	if i.HitDieLTE != nil {
		predicates = append(predicates, class.HitDieLTE(*i.HitDieLTE))
	}

	if i.HasProficiencies != nil {
		p := class.HasProficiencies()
		if !*i.HasProficiencies {
			p = class.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProficienciesWith) > 0 {
		with := make([]predicate.Proficiency, 0, len(i.HasProficienciesWith))
		for _, w := range i.HasProficienciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProficienciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, class.HasProficienciesWith(with...))
	}
	if i.HasProficiencyChoices != nil {
		p := class.HasProficiencyChoices()
		if !*i.HasProficiencyChoices {
			p = class.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProficiencyChoicesWith) > 0 {
		with := make([]predicate.Choice, 0, len(i.HasProficiencyChoicesWith))
		for _, w := range i.HasProficiencyChoicesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProficiencyChoicesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, class.HasProficiencyChoicesWith(with...))
	}
	if i.HasStartingEquipment != nil {
		p := class.HasStartingEquipment()
		if !*i.HasStartingEquipment {
			p = class.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStartingEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasStartingEquipmentWith))
		for _, w := range i.HasStartingEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStartingEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, class.HasStartingEquipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyClassWhereInput
	case 1:
		return predicates[0], nil
	default:
		return class.And(predicates...), nil
	}
}

// CostWhereInput represents a where input for filtering Cost queries.
type CostWhereInput struct {
	Predicates []predicate.Cost  `json:"-"`
	Not        *CostWhereInput   `json:"not,omitempty"`
	Or         []*CostWhereInput `json:"or,omitempty"`
	And        []*CostWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "quantity" field predicates.
	Quantity      *int  `json:"quantity,omitempty"`
	QuantityNEQ   *int  `json:"quantityNEQ,omitempty"`
	QuantityIn    []int `json:"quantityIn,omitempty"`
	QuantityNotIn []int `json:"quantityNotIn,omitempty"`
	QuantityGT    *int  `json:"quantityGT,omitempty"`
	QuantityGTE   *int  `json:"quantityGTE,omitempty"`
	QuantityLT    *int  `json:"quantityLT,omitempty"`
	QuantityLTE   *int  `json:"quantityLTE,omitempty"`

	// "unit" field predicates.
	Unit             *string  `json:"unit,omitempty"`
	UnitNEQ          *string  `json:"unitNEQ,omitempty"`
	UnitIn           []string `json:"unitIn,omitempty"`
	UnitNotIn        []string `json:"unitNotIn,omitempty"`
	UnitGT           *string  `json:"unitGT,omitempty"`
	UnitGTE          *string  `json:"unitGTE,omitempty"`
	UnitLT           *string  `json:"unitLT,omitempty"`
	UnitLTE          *string  `json:"unitLTE,omitempty"`
	UnitContains     *string  `json:"unitContains,omitempty"`
	UnitHasPrefix    *string  `json:"unitHasPrefix,omitempty"`
	UnitHasSuffix    *string  `json:"unitHasSuffix,omitempty"`
	UnitEqualFold    *string  `json:"unitEqualFold,omitempty"`
	UnitContainsFold *string  `json:"unitContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CostWhereInput) AddPredicates(predicates ...predicate.Cost) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CostWhereInput filter on the CostQuery builder.
func (i *CostWhereInput) Filter(q *CostQuery) (*CostQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCostWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCostWhereInput is returned in case the CostWhereInput is empty.
var ErrEmptyCostWhereInput = errors.New("ent: empty predicate CostWhereInput")

// P returns a predicate for filtering costs.
// An error is returned if the input is empty or invalid.
func (i *CostWhereInput) P() (predicate.Cost, error) {
	var predicates []predicate.Cost
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, cost.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Cost, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, cost.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Cost, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, cost.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, cost.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, cost.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, cost.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, cost.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, cost.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, cost.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, cost.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, cost.IDLTE(*i.IDLTE))
	}
	if i.Quantity != nil {
		predicates = append(predicates, cost.QuantityEQ(*i.Quantity))
	}
	if i.QuantityNEQ != nil {
		predicates = append(predicates, cost.QuantityNEQ(*i.QuantityNEQ))
	}
	if len(i.QuantityIn) > 0 {
		predicates = append(predicates, cost.QuantityIn(i.QuantityIn...))
	}
	if len(i.QuantityNotIn) > 0 {
		predicates = append(predicates, cost.QuantityNotIn(i.QuantityNotIn...))
	}
	if i.QuantityGT != nil {
		predicates = append(predicates, cost.QuantityGT(*i.QuantityGT))
	}
	if i.QuantityGTE != nil {
		predicates = append(predicates, cost.QuantityGTE(*i.QuantityGTE))
	}
	if i.QuantityLT != nil {
		predicates = append(predicates, cost.QuantityLT(*i.QuantityLT))
	}
	if i.QuantityLTE != nil {
		predicates = append(predicates, cost.QuantityLTE(*i.QuantityLTE))
	}
	if i.Unit != nil {
		predicates = append(predicates, cost.UnitEQ(*i.Unit))
	}
	if i.UnitNEQ != nil {
		predicates = append(predicates, cost.UnitNEQ(*i.UnitNEQ))
	}
	if len(i.UnitIn) > 0 {
		predicates = append(predicates, cost.UnitIn(i.UnitIn...))
	}
	if len(i.UnitNotIn) > 0 {
		predicates = append(predicates, cost.UnitNotIn(i.UnitNotIn...))
	}
	if i.UnitGT != nil {
		predicates = append(predicates, cost.UnitGT(*i.UnitGT))
	}
	if i.UnitGTE != nil {
		predicates = append(predicates, cost.UnitGTE(*i.UnitGTE))
	}
	if i.UnitLT != nil {
		predicates = append(predicates, cost.UnitLT(*i.UnitLT))
	}
	if i.UnitLTE != nil {
		predicates = append(predicates, cost.UnitLTE(*i.UnitLTE))
	}
	if i.UnitContains != nil {
		predicates = append(predicates, cost.UnitContains(*i.UnitContains))
	}
	if i.UnitHasPrefix != nil {
		predicates = append(predicates, cost.UnitHasPrefix(*i.UnitHasPrefix))
	}
	if i.UnitHasSuffix != nil {
		predicates = append(predicates, cost.UnitHasSuffix(*i.UnitHasSuffix))
	}
	if i.UnitEqualFold != nil {
		predicates = append(predicates, cost.UnitEqualFold(*i.UnitEqualFold))
	}
	if i.UnitContainsFold != nil {
		predicates = append(predicates, cost.UnitContainsFold(*i.UnitContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCostWhereInput
	case 1:
		return predicates[0], nil
	default:
		return cost.And(predicates...), nil
	}
}

// DamageTypeWhereInput represents a where input for filtering DamageType queries.
type DamageTypeWhereInput struct {
	Predicates []predicate.DamageType  `json:"-"`
	Not        *DamageTypeWhereInput   `json:"not,omitempty"`
	Or         []*DamageTypeWhereInput `json:"or,omitempty"`
	And        []*DamageTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "weapon_damage" edge predicates.
	HasWeaponDamage     *bool                     `json:"hasWeaponDamage,omitempty"`
	HasWeaponDamageWith []*WeaponDamageWhereInput `json:"hasWeaponDamageWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DamageTypeWhereInput) AddPredicates(predicates ...predicate.DamageType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DamageTypeWhereInput filter on the DamageTypeQuery builder.
func (i *DamageTypeWhereInput) Filter(q *DamageTypeQuery) (*DamageTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDamageTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDamageTypeWhereInput is returned in case the DamageTypeWhereInput is empty.
var ErrEmptyDamageTypeWhereInput = errors.New("ent: empty predicate DamageTypeWhereInput")

// P returns a predicate for filtering damagetypes.
// An error is returned if the input is empty or invalid.
func (i *DamageTypeWhereInput) P() (predicate.DamageType, error) {
	var predicates []predicate.DamageType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, damagetype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DamageType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, damagetype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DamageType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, damagetype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, damagetype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, damagetype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, damagetype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, damagetype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, damagetype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, damagetype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, damagetype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, damagetype.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, damagetype.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, damagetype.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, damagetype.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, damagetype.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, damagetype.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, damagetype.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, damagetype.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, damagetype.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, damagetype.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, damagetype.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, damagetype.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, damagetype.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, damagetype.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, damagetype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, damagetype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, damagetype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, damagetype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, damagetype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, damagetype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, damagetype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, damagetype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, damagetype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, damagetype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, damagetype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, damagetype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, damagetype.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasWeaponDamage != nil {
		p := damagetype.HasWeaponDamage()
		if !*i.HasWeaponDamage {
			p = damagetype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWeaponDamageWith) > 0 {
		with := make([]predicate.WeaponDamage, 0, len(i.HasWeaponDamageWith))
		for _, w := range i.HasWeaponDamageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWeaponDamageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, damagetype.HasWeaponDamageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDamageTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return damagetype.And(predicates...), nil
	}
}

// EquipmentWhereInput represents a where input for filtering Equipment queries.
type EquipmentWhereInput struct {
	Predicates []predicate.Equipment  `json:"-"`
	Not        *EquipmentWhereInput   `json:"not,omitempty"`
	Or         []*EquipmentWhereInput `json:"or,omitempty"`
	And        []*EquipmentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "equipment_category" field predicates.
	EquipmentCategory      *equipment.EquipmentCategory  `json:"equipmentCategory,omitempty"`
	EquipmentCategoryNEQ   *equipment.EquipmentCategory  `json:"equipmentCategoryNEQ,omitempty"`
	EquipmentCategoryIn    []equipment.EquipmentCategory `json:"equipmentCategoryIn,omitempty"`
	EquipmentCategoryNotIn []equipment.EquipmentCategory `json:"equipmentCategoryNotIn,omitempty"`

	// "cost" edge predicates.
	HasCost     *bool             `json:"hasCost,omitempty"`
	HasCostWith []*CostWhereInput `json:"hasCostWith,omitempty"`

	// "weapon" edge predicates.
	HasWeapon     *bool               `json:"hasWeapon,omitempty"`
	HasWeaponWith []*WeaponWhereInput `json:"hasWeaponWith,omitempty"`

	// "armor" edge predicates.
	HasArmor     *bool              `json:"hasArmor,omitempty"`
	HasArmorWith []*ArmorWhereInput `json:"hasArmorWith,omitempty"`

	// "gear" edge predicates.
	HasGear     *bool             `json:"hasGear,omitempty"`
	HasGearWith []*GearWhereInput `json:"hasGearWith,omitempty"`

	// "tool" edge predicates.
	HasTool     *bool             `json:"hasTool,omitempty"`
	HasToolWith []*ToolWhereInput `json:"hasToolWith,omitempty"`

	// "vehicle" edge predicates.
	HasVehicle     *bool                `json:"hasVehicle,omitempty"`
	HasVehicleWith []*VehicleWhereInput `json:"hasVehicleWith,omitempty"`

	// "class" edge predicates.
	HasClass     *bool              `json:"hasClass,omitempty"`
	HasClassWith []*ClassWhereInput `json:"hasClassWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EquipmentWhereInput) AddPredicates(predicates ...predicate.Equipment) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EquipmentWhereInput filter on the EquipmentQuery builder.
func (i *EquipmentWhereInput) Filter(q *EquipmentQuery) (*EquipmentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEquipmentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEquipmentWhereInput is returned in case the EquipmentWhereInput is empty.
var ErrEmptyEquipmentWhereInput = errors.New("ent: empty predicate EquipmentWhereInput")

// P returns a predicate for filtering equipmentslice.
// An error is returned if the input is empty or invalid.
func (i *EquipmentWhereInput) P() (predicate.Equipment, error) {
	var predicates []predicate.Equipment
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, equipment.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Equipment, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, equipment.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Equipment, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, equipment.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, equipment.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, equipment.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, equipment.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, equipment.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, equipment.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, equipment.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, equipment.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, equipment.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, equipment.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, equipment.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, equipment.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, equipment.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, equipment.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, equipment.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, equipment.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, equipment.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, equipment.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, equipment.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, equipment.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, equipment.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, equipment.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, equipment.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, equipment.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, equipment.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, equipment.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, equipment.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, equipment.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, equipment.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, equipment.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, equipment.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, equipment.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, equipment.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, equipment.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, equipment.NameContainsFold(*i.NameContainsFold))
	}
	if i.EquipmentCategory != nil {
		predicates = append(predicates, equipment.EquipmentCategoryEQ(*i.EquipmentCategory))
	}
	if i.EquipmentCategoryNEQ != nil {
		predicates = append(predicates, equipment.EquipmentCategoryNEQ(*i.EquipmentCategoryNEQ))
	}
	if len(i.EquipmentCategoryIn) > 0 {
		predicates = append(predicates, equipment.EquipmentCategoryIn(i.EquipmentCategoryIn...))
	}
	if len(i.EquipmentCategoryNotIn) > 0 {
		predicates = append(predicates, equipment.EquipmentCategoryNotIn(i.EquipmentCategoryNotIn...))
	}

	if i.HasCost != nil {
		p := equipment.HasCost()
		if !*i.HasCost {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCostWith) > 0 {
		with := make([]predicate.Cost, 0, len(i.HasCostWith))
		for _, w := range i.HasCostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasCostWith(with...))
	}
	if i.HasWeapon != nil {
		p := equipment.HasWeapon()
		if !*i.HasWeapon {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWeaponWith) > 0 {
		with := make([]predicate.Weapon, 0, len(i.HasWeaponWith))
		for _, w := range i.HasWeaponWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWeaponWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasWeaponWith(with...))
	}
	if i.HasArmor != nil {
		p := equipment.HasArmor()
		if !*i.HasArmor {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasArmorWith) > 0 {
		with := make([]predicate.Armor, 0, len(i.HasArmorWith))
		for _, w := range i.HasArmorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasArmorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasArmorWith(with...))
	}
	if i.HasGear != nil {
		p := equipment.HasGear()
		if !*i.HasGear {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGearWith) > 0 {
		with := make([]predicate.Gear, 0, len(i.HasGearWith))
		for _, w := range i.HasGearWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGearWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasGearWith(with...))
	}
	if i.HasTool != nil {
		p := equipment.HasTool()
		if !*i.HasTool {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasToolWith) > 0 {
		with := make([]predicate.Tool, 0, len(i.HasToolWith))
		for _, w := range i.HasToolWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasToolWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasToolWith(with...))
	}
	if i.HasVehicle != nil {
		p := equipment.HasVehicle()
		if !*i.HasVehicle {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehicleWith) > 0 {
		with := make([]predicate.Vehicle, 0, len(i.HasVehicleWith))
		for _, w := range i.HasVehicleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVehicleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasVehicleWith(with...))
	}
	if i.HasClass != nil {
		p := equipment.HasClass()
		if !*i.HasClass {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClassWith) > 0 {
		with := make([]predicate.Class, 0, len(i.HasClassWith))
		for _, w := range i.HasClassWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasClassWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasClassWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEquipmentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return equipment.And(predicates...), nil
	}
}

// GearWhereInput represents a where input for filtering Gear queries.
type GearWhereInput struct {
	Predicates []predicate.Gear  `json:"-"`
	Not        *GearWhereInput   `json:"not,omitempty"`
	Or         []*GearWhereInput `json:"or,omitempty"`
	And        []*GearWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "gear_category" field predicates.
	GearCategory      *gear.GearCategory  `json:"gearCategory,omitempty"`
	GearCategoryNEQ   *gear.GearCategory  `json:"gearCategoryNEQ,omitempty"`
	GearCategoryIn    []gear.GearCategory `json:"gearCategoryIn,omitempty"`
	GearCategoryNotIn []gear.GearCategory `json:"gearCategoryNotIn,omitempty"`

	// "quantity" field predicates.
	Quantity       *int  `json:"quantity,omitempty"`
	QuantityNEQ    *int  `json:"quantityNEQ,omitempty"`
	QuantityIn     []int `json:"quantityIn,omitempty"`
	QuantityNotIn  []int `json:"quantityNotIn,omitempty"`
	QuantityGT     *int  `json:"quantityGT,omitempty"`
	QuantityGTE    *int  `json:"quantityGTE,omitempty"`
	QuantityLT     *int  `json:"quantityLT,omitempty"`
	QuantityLTE    *int  `json:"quantityLTE,omitempty"`
	QuantityIsNil  bool  `json:"quantityIsNil,omitempty"`
	QuantityNotNil bool  `json:"quantityNotNil,omitempty"`

	// "equipment_id" field predicates.
	EquipmentID      *int  `json:"equipmentID,omitempty"`
	EquipmentIDNEQ   *int  `json:"equipmentIDNEQ,omitempty"`
	EquipmentIDIn    []int `json:"equipmentIDIn,omitempty"`
	EquipmentIDNotIn []int `json:"equipmentIDNotIn,omitempty"`

	// "equipment" edge predicates.
	HasEquipment     *bool                  `json:"hasEquipment,omitempty"`
	HasEquipmentWith []*EquipmentWhereInput `json:"hasEquipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GearWhereInput) AddPredicates(predicates ...predicate.Gear) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GearWhereInput filter on the GearQuery builder.
func (i *GearWhereInput) Filter(q *GearQuery) (*GearQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGearWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGearWhereInput is returned in case the GearWhereInput is empty.
var ErrEmptyGearWhereInput = errors.New("ent: empty predicate GearWhereInput")

// P returns a predicate for filtering gears.
// An error is returned if the input is empty or invalid.
func (i *GearWhereInput) P() (predicate.Gear, error) {
	var predicates []predicate.Gear
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, gear.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Gear, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, gear.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Gear, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, gear.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, gear.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, gear.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, gear.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, gear.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, gear.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, gear.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, gear.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, gear.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, gear.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, gear.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, gear.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, gear.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, gear.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, gear.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, gear.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, gear.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, gear.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, gear.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, gear.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, gear.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, gear.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, gear.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, gear.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, gear.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, gear.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, gear.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, gear.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, gear.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, gear.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, gear.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, gear.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, gear.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, gear.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, gear.NameContainsFold(*i.NameContainsFold))
	}
	if i.GearCategory != nil {
		predicates = append(predicates, gear.GearCategoryEQ(*i.GearCategory))
	}
	if i.GearCategoryNEQ != nil {
		predicates = append(predicates, gear.GearCategoryNEQ(*i.GearCategoryNEQ))
	}
	if len(i.GearCategoryIn) > 0 {
		predicates = append(predicates, gear.GearCategoryIn(i.GearCategoryIn...))
	}
	if len(i.GearCategoryNotIn) > 0 {
		predicates = append(predicates, gear.GearCategoryNotIn(i.GearCategoryNotIn...))
	}
	if i.Quantity != nil {
		predicates = append(predicates, gear.QuantityEQ(*i.Quantity))
	}
	if i.QuantityNEQ != nil {
		predicates = append(predicates, gear.QuantityNEQ(*i.QuantityNEQ))
	}
	if len(i.QuantityIn) > 0 {
		predicates = append(predicates, gear.QuantityIn(i.QuantityIn...))
	}
	if len(i.QuantityNotIn) > 0 {
		predicates = append(predicates, gear.QuantityNotIn(i.QuantityNotIn...))
	}
	if i.QuantityGT != nil {
		predicates = append(predicates, gear.QuantityGT(*i.QuantityGT))
	}
	if i.QuantityGTE != nil {
		predicates = append(predicates, gear.QuantityGTE(*i.QuantityGTE))
	}
	if i.QuantityLT != nil {
		predicates = append(predicates, gear.QuantityLT(*i.QuantityLT))
	}
	if i.QuantityLTE != nil {
		predicates = append(predicates, gear.QuantityLTE(*i.QuantityLTE))
	}
	if i.QuantityIsNil {
		predicates = append(predicates, gear.QuantityIsNil())
	}
	if i.QuantityNotNil {
		predicates = append(predicates, gear.QuantityNotNil())
	}
	if i.EquipmentID != nil {
		predicates = append(predicates, gear.EquipmentIDEQ(*i.EquipmentID))
	}
	if i.EquipmentIDNEQ != nil {
		predicates = append(predicates, gear.EquipmentIDNEQ(*i.EquipmentIDNEQ))
	}
	if len(i.EquipmentIDIn) > 0 {
		predicates = append(predicates, gear.EquipmentIDIn(i.EquipmentIDIn...))
	}
	if len(i.EquipmentIDNotIn) > 0 {
		predicates = append(predicates, gear.EquipmentIDNotIn(i.EquipmentIDNotIn...))
	}

	if i.HasEquipment != nil {
		p := gear.HasEquipment()
		if !*i.HasEquipment {
			p = gear.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentWith))
		for _, w := range i.HasEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, gear.HasEquipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGearWhereInput
	case 1:
		return predicates[0], nil
	default:
		return gear.And(predicates...), nil
	}
}

// LanguageWhereInput represents a where input for filtering Language queries.
type LanguageWhereInput struct {
	Predicates []predicate.Language  `json:"-"`
	Not        *LanguageWhereInput   `json:"not,omitempty"`
	Or         []*LanguageWhereInput `json:"or,omitempty"`
	And        []*LanguageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "desc" field predicates.
	Desc             *string  `json:"desc,omitempty"`
	DescNEQ          *string  `json:"descNEQ,omitempty"`
	DescIn           []string `json:"descIn,omitempty"`
	DescNotIn        []string `json:"descNotIn,omitempty"`
	DescGT           *string  `json:"descGT,omitempty"`
	DescGTE          *string  `json:"descGTE,omitempty"`
	DescLT           *string  `json:"descLT,omitempty"`
	DescLTE          *string  `json:"descLTE,omitempty"`
	DescContains     *string  `json:"descContains,omitempty"`
	DescHasPrefix    *string  `json:"descHasPrefix,omitempty"`
	DescHasSuffix    *string  `json:"descHasSuffix,omitempty"`
	DescEqualFold    *string  `json:"descEqualFold,omitempty"`
	DescContainsFold *string  `json:"descContainsFold,omitempty"`

	// "language_type" field predicates.
	LanguageType      *language.LanguageType  `json:"languageType,omitempty"`
	LanguageTypeNEQ   *language.LanguageType  `json:"languageTypeNEQ,omitempty"`
	LanguageTypeIn    []language.LanguageType `json:"languageTypeIn,omitempty"`
	LanguageTypeNotIn []language.LanguageType `json:"languageTypeNotIn,omitempty"`

	// "script" field predicates.
	Script       *language.Script  `json:"script,omitempty"`
	ScriptNEQ    *language.Script  `json:"scriptNEQ,omitempty"`
	ScriptIn     []language.Script `json:"scriptIn,omitempty"`
	ScriptNotIn  []language.Script `json:"scriptNotIn,omitempty"`
	ScriptIsNil  bool              `json:"scriptIsNil,omitempty"`
	ScriptNotNil bool              `json:"scriptNotNil,omitempty"`

	// "race_speakers" edge predicates.
	HasRaceSpeakers     *bool             `json:"hasRaceSpeakers,omitempty"`
	HasRaceSpeakersWith []*RaceWhereInput `json:"hasRaceSpeakersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LanguageWhereInput) AddPredicates(predicates ...predicate.Language) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LanguageWhereInput filter on the LanguageQuery builder.
func (i *LanguageWhereInput) Filter(q *LanguageQuery) (*LanguageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLanguageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLanguageWhereInput is returned in case the LanguageWhereInput is empty.
var ErrEmptyLanguageWhereInput = errors.New("ent: empty predicate LanguageWhereInput")

// P returns a predicate for filtering languages.
// An error is returned if the input is empty or invalid.
func (i *LanguageWhereInput) P() (predicate.Language, error) {
	var predicates []predicate.Language
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, language.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Language, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, language.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Language, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, language.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, language.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, language.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, language.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, language.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, language.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, language.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, language.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, language.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, language.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, language.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, language.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, language.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, language.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, language.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, language.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, language.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, language.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, language.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, language.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, language.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, language.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, language.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, language.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, language.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, language.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, language.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, language.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, language.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, language.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, language.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, language.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, language.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, language.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, language.NameContainsFold(*i.NameContainsFold))
	}
	if i.Desc != nil {
		predicates = append(predicates, language.DescEQ(*i.Desc))
	}
	if i.DescNEQ != nil {
		predicates = append(predicates, language.DescNEQ(*i.DescNEQ))
	}
	if len(i.DescIn) > 0 {
		predicates = append(predicates, language.DescIn(i.DescIn...))
	}
	if len(i.DescNotIn) > 0 {
		predicates = append(predicates, language.DescNotIn(i.DescNotIn...))
	}
	if i.DescGT != nil {
		predicates = append(predicates, language.DescGT(*i.DescGT))
	}
	if i.DescGTE != nil {
		predicates = append(predicates, language.DescGTE(*i.DescGTE))
	}
	if i.DescLT != nil {
		predicates = append(predicates, language.DescLT(*i.DescLT))
	}
	if i.DescLTE != nil {
		predicates = append(predicates, language.DescLTE(*i.DescLTE))
	}
	if i.DescContains != nil {
		predicates = append(predicates, language.DescContains(*i.DescContains))
	}
	if i.DescHasPrefix != nil {
		predicates = append(predicates, language.DescHasPrefix(*i.DescHasPrefix))
	}
	if i.DescHasSuffix != nil {
		predicates = append(predicates, language.DescHasSuffix(*i.DescHasSuffix))
	}
	if i.DescEqualFold != nil {
		predicates = append(predicates, language.DescEqualFold(*i.DescEqualFold))
	}
	if i.DescContainsFold != nil {
		predicates = append(predicates, language.DescContainsFold(*i.DescContainsFold))
	}
	if i.LanguageType != nil {
		predicates = append(predicates, language.LanguageTypeEQ(*i.LanguageType))
	}
	if i.LanguageTypeNEQ != nil {
		predicates = append(predicates, language.LanguageTypeNEQ(*i.LanguageTypeNEQ))
	}
	if len(i.LanguageTypeIn) > 0 {
		predicates = append(predicates, language.LanguageTypeIn(i.LanguageTypeIn...))
	}
	if len(i.LanguageTypeNotIn) > 0 {
		predicates = append(predicates, language.LanguageTypeNotIn(i.LanguageTypeNotIn...))
	}
	if i.Script != nil {
		predicates = append(predicates, language.ScriptEQ(*i.Script))
	}
	if i.ScriptNEQ != nil {
		predicates = append(predicates, language.ScriptNEQ(*i.ScriptNEQ))
	}
	if len(i.ScriptIn) > 0 {
		predicates = append(predicates, language.ScriptIn(i.ScriptIn...))
	}
	if len(i.ScriptNotIn) > 0 {
		predicates = append(predicates, language.ScriptNotIn(i.ScriptNotIn...))
	}
	if i.ScriptIsNil {
		predicates = append(predicates, language.ScriptIsNil())
	}
	if i.ScriptNotNil {
		predicates = append(predicates, language.ScriptNotNil())
	}

	if i.HasRaceSpeakers != nil {
		p := language.HasRaceSpeakers()
		if !*i.HasRaceSpeakers {
			p = language.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRaceSpeakersWith) > 0 {
		with := make([]predicate.Race, 0, len(i.HasRaceSpeakersWith))
		for _, w := range i.HasRaceSpeakersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRaceSpeakersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, language.HasRaceSpeakersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLanguageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return language.And(predicates...), nil
	}
}

// MagicSchoolWhereInput represents a where input for filtering MagicSchool queries.
type MagicSchoolWhereInput struct {
	Predicates []predicate.MagicSchool  `json:"-"`
	Not        *MagicSchoolWhereInput   `json:"not,omitempty"`
	Or         []*MagicSchoolWhereInput `json:"or,omitempty"`
	And        []*MagicSchoolWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "desc" field predicates.
	Desc             *string  `json:"desc,omitempty"`
	DescNEQ          *string  `json:"descNEQ,omitempty"`
	DescIn           []string `json:"descIn,omitempty"`
	DescNotIn        []string `json:"descNotIn,omitempty"`
	DescGT           *string  `json:"descGT,omitempty"`
	DescGTE          *string  `json:"descGTE,omitempty"`
	DescLT           *string  `json:"descLT,omitempty"`
	DescLTE          *string  `json:"descLTE,omitempty"`
	DescContains     *string  `json:"descContains,omitempty"`
	DescHasPrefix    *string  `json:"descHasPrefix,omitempty"`
	DescHasSuffix    *string  `json:"descHasSuffix,omitempty"`
	DescEqualFold    *string  `json:"descEqualFold,omitempty"`
	DescContainsFold *string  `json:"descContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MagicSchoolWhereInput) AddPredicates(predicates ...predicate.MagicSchool) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MagicSchoolWhereInput filter on the MagicSchoolQuery builder.
func (i *MagicSchoolWhereInput) Filter(q *MagicSchoolQuery) (*MagicSchoolQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMagicSchoolWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMagicSchoolWhereInput is returned in case the MagicSchoolWhereInput is empty.
var ErrEmptyMagicSchoolWhereInput = errors.New("ent: empty predicate MagicSchoolWhereInput")

// P returns a predicate for filtering magicschools.
// An error is returned if the input is empty or invalid.
func (i *MagicSchoolWhereInput) P() (predicate.MagicSchool, error) {
	var predicates []predicate.MagicSchool
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, magicschool.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MagicSchool, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, magicschool.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MagicSchool, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, magicschool.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, magicschool.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, magicschool.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, magicschool.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, magicschool.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, magicschool.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, magicschool.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, magicschool.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, magicschool.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, magicschool.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, magicschool.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, magicschool.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, magicschool.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, magicschool.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, magicschool.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, magicschool.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, magicschool.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, magicschool.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, magicschool.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, magicschool.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, magicschool.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, magicschool.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, magicschool.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, magicschool.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, magicschool.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, magicschool.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, magicschool.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, magicschool.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, magicschool.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, magicschool.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, magicschool.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, magicschool.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, magicschool.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, magicschool.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, magicschool.NameContainsFold(*i.NameContainsFold))
	}
	if i.Desc != nil {
		predicates = append(predicates, magicschool.DescEQ(*i.Desc))
	}
	if i.DescNEQ != nil {
		predicates = append(predicates, magicschool.DescNEQ(*i.DescNEQ))
	}
	if len(i.DescIn) > 0 {
		predicates = append(predicates, magicschool.DescIn(i.DescIn...))
	}
	if len(i.DescNotIn) > 0 {
		predicates = append(predicates, magicschool.DescNotIn(i.DescNotIn...))
	}
	if i.DescGT != nil {
		predicates = append(predicates, magicschool.DescGT(*i.DescGT))
	}
	if i.DescGTE != nil {
		predicates = append(predicates, magicschool.DescGTE(*i.DescGTE))
	}
	if i.DescLT != nil {
		predicates = append(predicates, magicschool.DescLT(*i.DescLT))
	}
	if i.DescLTE != nil {
		predicates = append(predicates, magicschool.DescLTE(*i.DescLTE))
	}
	if i.DescContains != nil {
		predicates = append(predicates, magicschool.DescContains(*i.DescContains))
	}
	if i.DescHasPrefix != nil {
		predicates = append(predicates, magicschool.DescHasPrefix(*i.DescHasPrefix))
	}
	if i.DescHasSuffix != nil {
		predicates = append(predicates, magicschool.DescHasSuffix(*i.DescHasSuffix))
	}
	if i.DescEqualFold != nil {
		predicates = append(predicates, magicschool.DescEqualFold(*i.DescEqualFold))
	}
	if i.DescContainsFold != nil {
		predicates = append(predicates, magicschool.DescContainsFold(*i.DescContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMagicSchoolWhereInput
	case 1:
		return predicates[0], nil
	default:
		return magicschool.And(predicates...), nil
	}
}

// ProficiencyWhereInput represents a where input for filtering Proficiency queries.
type ProficiencyWhereInput struct {
	Predicates []predicate.Proficiency  `json:"-"`
	Not        *ProficiencyWhereInput   `json:"not,omitempty"`
	Or         []*ProficiencyWhereInput `json:"or,omitempty"`
	And        []*ProficiencyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "proficiency_category" field predicates.
	ProficiencyCategory             *string  `json:"proficiencyCategory,omitempty"`
	ProficiencyCategoryNEQ          *string  `json:"proficiencyCategoryNEQ,omitempty"`
	ProficiencyCategoryIn           []string `json:"proficiencyCategoryIn,omitempty"`
	ProficiencyCategoryNotIn        []string `json:"proficiencyCategoryNotIn,omitempty"`
	ProficiencyCategoryGT           *string  `json:"proficiencyCategoryGT,omitempty"`
	ProficiencyCategoryGTE          *string  `json:"proficiencyCategoryGTE,omitempty"`
	ProficiencyCategoryLT           *string  `json:"proficiencyCategoryLT,omitempty"`
	ProficiencyCategoryLTE          *string  `json:"proficiencyCategoryLTE,omitempty"`
	ProficiencyCategoryContains     *string  `json:"proficiencyCategoryContains,omitempty"`
	ProficiencyCategoryHasPrefix    *string  `json:"proficiencyCategoryHasPrefix,omitempty"`
	ProficiencyCategoryHasSuffix    *string  `json:"proficiencyCategoryHasSuffix,omitempty"`
	ProficiencyCategoryEqualFold    *string  `json:"proficiencyCategoryEqualFold,omitempty"`
	ProficiencyCategoryContainsFold *string  `json:"proficiencyCategoryContainsFold,omitempty"`

	// "classes" edge predicates.
	HasClasses     *bool              `json:"hasClasses,omitempty"`
	HasClassesWith []*ClassWhereInput `json:"hasClassesWith,omitempty"`

	// "races" edge predicates.
	HasRaces     *bool             `json:"hasRaces,omitempty"`
	HasRacesWith []*RaceWhereInput `json:"hasRacesWith,omitempty"`

	// "subraces" edge predicates.
	HasSubraces     *bool                `json:"hasSubraces,omitempty"`
	HasSubracesWith []*SubraceWhereInput `json:"hasSubracesWith,omitempty"`

	// "choice" edge predicates.
	HasChoice     *bool               `json:"hasChoice,omitempty"`
	HasChoiceWith []*ChoiceWhereInput `json:"hasChoiceWith,omitempty"`

	// "skill" edge predicates.
	HasSkill     *bool              `json:"hasSkill,omitempty"`
	HasSkillWith []*SkillWhereInput `json:"hasSkillWith,omitempty"`

	// "equipment" edge predicates.
	HasEquipment     *bool                  `json:"hasEquipment,omitempty"`
	HasEquipmentWith []*EquipmentWhereInput `json:"hasEquipmentWith,omitempty"`

	// "saving_throw" edge predicates.
	HasSavingThrow     *bool                     `json:"hasSavingThrow,omitempty"`
	HasSavingThrowWith []*AbilityScoreWhereInput `json:"hasSavingThrowWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProficiencyWhereInput) AddPredicates(predicates ...predicate.Proficiency) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProficiencyWhereInput filter on the ProficiencyQuery builder.
func (i *ProficiencyWhereInput) Filter(q *ProficiencyQuery) (*ProficiencyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProficiencyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProficiencyWhereInput is returned in case the ProficiencyWhereInput is empty.
var ErrEmptyProficiencyWhereInput = errors.New("ent: empty predicate ProficiencyWhereInput")

// P returns a predicate for filtering proficiencies.
// An error is returned if the input is empty or invalid.
func (i *ProficiencyWhereInput) P() (predicate.Proficiency, error) {
	var predicates []predicate.Proficiency
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, proficiency.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Proficiency, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, proficiency.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Proficiency, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, proficiency.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, proficiency.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, proficiency.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, proficiency.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, proficiency.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, proficiency.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, proficiency.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, proficiency.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, proficiency.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, proficiency.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, proficiency.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, proficiency.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, proficiency.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, proficiency.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, proficiency.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, proficiency.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, proficiency.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, proficiency.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, proficiency.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, proficiency.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, proficiency.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, proficiency.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, proficiency.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, proficiency.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, proficiency.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, proficiency.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, proficiency.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, proficiency.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, proficiency.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, proficiency.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, proficiency.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, proficiency.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, proficiency.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, proficiency.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, proficiency.NameContainsFold(*i.NameContainsFold))
	}
	if i.ProficiencyCategory != nil {
		predicates = append(predicates, proficiency.ProficiencyCategoryEQ(*i.ProficiencyCategory))
	}
	if i.ProficiencyCategoryNEQ != nil {
		predicates = append(predicates, proficiency.ProficiencyCategoryNEQ(*i.ProficiencyCategoryNEQ))
	}
	if len(i.ProficiencyCategoryIn) > 0 {
		predicates = append(predicates, proficiency.ProficiencyCategoryIn(i.ProficiencyCategoryIn...))
	}
	if len(i.ProficiencyCategoryNotIn) > 0 {
		predicates = append(predicates, proficiency.ProficiencyCategoryNotIn(i.ProficiencyCategoryNotIn...))
	}
	if i.ProficiencyCategoryGT != nil {
		predicates = append(predicates, proficiency.ProficiencyCategoryGT(*i.ProficiencyCategoryGT))
	}
	if i.ProficiencyCategoryGTE != nil {
		predicates = append(predicates, proficiency.ProficiencyCategoryGTE(*i.ProficiencyCategoryGTE))
	}
	if i.ProficiencyCategoryLT != nil {
		predicates = append(predicates, proficiency.ProficiencyCategoryLT(*i.ProficiencyCategoryLT))
	}
	if i.ProficiencyCategoryLTE != nil {
		predicates = append(predicates, proficiency.ProficiencyCategoryLTE(*i.ProficiencyCategoryLTE))
	}
	if i.ProficiencyCategoryContains != nil {
		predicates = append(predicates, proficiency.ProficiencyCategoryContains(*i.ProficiencyCategoryContains))
	}
	if i.ProficiencyCategoryHasPrefix != nil {
		predicates = append(predicates, proficiency.ProficiencyCategoryHasPrefix(*i.ProficiencyCategoryHasPrefix))
	}
	if i.ProficiencyCategoryHasSuffix != nil {
		predicates = append(predicates, proficiency.ProficiencyCategoryHasSuffix(*i.ProficiencyCategoryHasSuffix))
	}
	if i.ProficiencyCategoryEqualFold != nil {
		predicates = append(predicates, proficiency.ProficiencyCategoryEqualFold(*i.ProficiencyCategoryEqualFold))
	}
	if i.ProficiencyCategoryContainsFold != nil {
		predicates = append(predicates, proficiency.ProficiencyCategoryContainsFold(*i.ProficiencyCategoryContainsFold))
	}

	if i.HasClasses != nil {
		p := proficiency.HasClasses()
		if !*i.HasClasses {
			p = proficiency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClassesWith) > 0 {
		with := make([]predicate.Class, 0, len(i.HasClassesWith))
		for _, w := range i.HasClassesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasClassesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, proficiency.HasClassesWith(with...))
	}
	if i.HasRaces != nil {
		p := proficiency.HasRaces()
		if !*i.HasRaces {
			p = proficiency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRacesWith) > 0 {
		with := make([]predicate.Race, 0, len(i.HasRacesWith))
		for _, w := range i.HasRacesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRacesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, proficiency.HasRacesWith(with...))
	}
	if i.HasSubraces != nil {
		p := proficiency.HasSubraces()
		if !*i.HasSubraces {
			p = proficiency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubracesWith) > 0 {
		with := make([]predicate.Subrace, 0, len(i.HasSubracesWith))
		for _, w := range i.HasSubracesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubracesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, proficiency.HasSubracesWith(with...))
	}
	if i.HasChoice != nil {
		p := proficiency.HasChoice()
		if !*i.HasChoice {
			p = proficiency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChoiceWith) > 0 {
		with := make([]predicate.Choice, 0, len(i.HasChoiceWith))
		for _, w := range i.HasChoiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChoiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, proficiency.HasChoiceWith(with...))
	}
	if i.HasSkill != nil {
		p := proficiency.HasSkill()
		if !*i.HasSkill {
			p = proficiency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSkillWith) > 0 {
		with := make([]predicate.Skill, 0, len(i.HasSkillWith))
		for _, w := range i.HasSkillWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSkillWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, proficiency.HasSkillWith(with...))
	}
	if i.HasEquipment != nil {
		p := proficiency.HasEquipment()
		if !*i.HasEquipment {
			p = proficiency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentWith))
		for _, w := range i.HasEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, proficiency.HasEquipmentWith(with...))
	}
	if i.HasSavingThrow != nil {
		p := proficiency.HasSavingThrow()
		if !*i.HasSavingThrow {
			p = proficiency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSavingThrowWith) > 0 {
		with := make([]predicate.AbilityScore, 0, len(i.HasSavingThrowWith))
		for _, w := range i.HasSavingThrowWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSavingThrowWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, proficiency.HasSavingThrowWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProficiencyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return proficiency.And(predicates...), nil
	}
}

// RaceWhereInput represents a where input for filtering Race queries.
type RaceWhereInput struct {
	Predicates []predicate.Race  `json:"-"`
	Not        *RaceWhereInput   `json:"not,omitempty"`
	Or         []*RaceWhereInput `json:"or,omitempty"`
	And        []*RaceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "alignment" field predicates.
	Alignment             *string  `json:"alignment,omitempty"`
	AlignmentNEQ          *string  `json:"alignmentNEQ,omitempty"`
	AlignmentIn           []string `json:"alignmentIn,omitempty"`
	AlignmentNotIn        []string `json:"alignmentNotIn,omitempty"`
	AlignmentGT           *string  `json:"alignmentGT,omitempty"`
	AlignmentGTE          *string  `json:"alignmentGTE,omitempty"`
	AlignmentLT           *string  `json:"alignmentLT,omitempty"`
	AlignmentLTE          *string  `json:"alignmentLTE,omitempty"`
	AlignmentContains     *string  `json:"alignmentContains,omitempty"`
	AlignmentHasPrefix    *string  `json:"alignmentHasPrefix,omitempty"`
	AlignmentHasSuffix    *string  `json:"alignmentHasSuffix,omitempty"`
	AlignmentEqualFold    *string  `json:"alignmentEqualFold,omitempty"`
	AlignmentContainsFold *string  `json:"alignmentContainsFold,omitempty"`

	// "age" field predicates.
	Age             *string  `json:"age,omitempty"`
	AgeNEQ          *string  `json:"ageNEQ,omitempty"`
	AgeIn           []string `json:"ageIn,omitempty"`
	AgeNotIn        []string `json:"ageNotIn,omitempty"`
	AgeGT           *string  `json:"ageGT,omitempty"`
	AgeGTE          *string  `json:"ageGTE,omitempty"`
	AgeLT           *string  `json:"ageLT,omitempty"`
	AgeLTE          *string  `json:"ageLTE,omitempty"`
	AgeContains     *string  `json:"ageContains,omitempty"`
	AgeHasPrefix    *string  `json:"ageHasPrefix,omitempty"`
	AgeHasSuffix    *string  `json:"ageHasSuffix,omitempty"`
	AgeEqualFold    *string  `json:"ageEqualFold,omitempty"`
	AgeContainsFold *string  `json:"ageContainsFold,omitempty"`

	// "size" field predicates.
	Size             *string  `json:"size,omitempty"`
	SizeNEQ          *string  `json:"sizeNEQ,omitempty"`
	SizeIn           []string `json:"sizeIn,omitempty"`
	SizeNotIn        []string `json:"sizeNotIn,omitempty"`
	SizeGT           *string  `json:"sizeGT,omitempty"`
	SizeGTE          *string  `json:"sizeGTE,omitempty"`
	SizeLT           *string  `json:"sizeLT,omitempty"`
	SizeLTE          *string  `json:"sizeLTE,omitempty"`
	SizeContains     *string  `json:"sizeContains,omitempty"`
	SizeHasPrefix    *string  `json:"sizeHasPrefix,omitempty"`
	SizeHasSuffix    *string  `json:"sizeHasSuffix,omitempty"`
	SizeEqualFold    *string  `json:"sizeEqualFold,omitempty"`
	SizeContainsFold *string  `json:"sizeContainsFold,omitempty"`

	// "size_description" field predicates.
	SizeDescription             *string  `json:"sizeDescription,omitempty"`
	SizeDescriptionNEQ          *string  `json:"sizeDescriptionNEQ,omitempty"`
	SizeDescriptionIn           []string `json:"sizeDescriptionIn,omitempty"`
	SizeDescriptionNotIn        []string `json:"sizeDescriptionNotIn,omitempty"`
	SizeDescriptionGT           *string  `json:"sizeDescriptionGT,omitempty"`
	SizeDescriptionGTE          *string  `json:"sizeDescriptionGTE,omitempty"`
	SizeDescriptionLT           *string  `json:"sizeDescriptionLT,omitempty"`
	SizeDescriptionLTE          *string  `json:"sizeDescriptionLTE,omitempty"`
	SizeDescriptionContains     *string  `json:"sizeDescriptionContains,omitempty"`
	SizeDescriptionHasPrefix    *string  `json:"sizeDescriptionHasPrefix,omitempty"`
	SizeDescriptionHasSuffix    *string  `json:"sizeDescriptionHasSuffix,omitempty"`
	SizeDescriptionEqualFold    *string  `json:"sizeDescriptionEqualFold,omitempty"`
	SizeDescriptionContainsFold *string  `json:"sizeDescriptionContainsFold,omitempty"`

	// "language_desc" field predicates.
	LanguageDesc             *string  `json:"languageDesc,omitempty"`
	LanguageDescNEQ          *string  `json:"languageDescNEQ,omitempty"`
	LanguageDescIn           []string `json:"languageDescIn,omitempty"`
	LanguageDescNotIn        []string `json:"languageDescNotIn,omitempty"`
	LanguageDescGT           *string  `json:"languageDescGT,omitempty"`
	LanguageDescGTE          *string  `json:"languageDescGTE,omitempty"`
	LanguageDescLT           *string  `json:"languageDescLT,omitempty"`
	LanguageDescLTE          *string  `json:"languageDescLTE,omitempty"`
	LanguageDescContains     *string  `json:"languageDescContains,omitempty"`
	LanguageDescHasPrefix    *string  `json:"languageDescHasPrefix,omitempty"`
	LanguageDescHasSuffix    *string  `json:"languageDescHasSuffix,omitempty"`
	LanguageDescEqualFold    *string  `json:"languageDescEqualFold,omitempty"`
	LanguageDescContainsFold *string  `json:"languageDescContainsFold,omitempty"`

	// "speed" field predicates.
	Speed      *int  `json:"speed,omitempty"`
	SpeedNEQ   *int  `json:"speedNEQ,omitempty"`
	SpeedIn    []int `json:"speedIn,omitempty"`
	SpeedNotIn []int `json:"speedNotIn,omitempty"`
	SpeedGT    *int  `json:"speedGT,omitempty"`
	SpeedGTE   *int  `json:"speedGTE,omitempty"`
	SpeedLT    *int  `json:"speedLT,omitempty"`
	SpeedLTE   *int  `json:"speedLTE,omitempty"`

	// "languages" edge predicates.
	HasLanguages     *bool                 `json:"hasLanguages,omitempty"`
	HasLanguagesWith []*LanguageWhereInput `json:"hasLanguagesWith,omitempty"`

	// "proficiencies" edge predicates.
	HasProficiencies     *bool                    `json:"hasProficiencies,omitempty"`
	HasProficienciesWith []*ProficiencyWhereInput `json:"hasProficienciesWith,omitempty"`

	// "subraces" edge predicates.
	HasSubraces     *bool                `json:"hasSubraces,omitempty"`
	HasSubracesWith []*SubraceWhereInput `json:"hasSubracesWith,omitempty"`

	// "traits" edge predicates.
	HasTraits     *bool              `json:"hasTraits,omitempty"`
	HasTraitsWith []*TraitWhereInput `json:"hasTraitsWith,omitempty"`

	// "ability_bonuses" edge predicates.
	HasAbilityBonuses     *bool                     `json:"hasAbilityBonuses,omitempty"`
	HasAbilityBonusesWith []*AbilityBonusWhereInput `json:"hasAbilityBonusesWith,omitempty"`

	// "starting_proficiency_options" edge predicates.
	HasStartingProficiencyOptions     *bool               `json:"hasStartingProficiencyOptions,omitempty"`
	HasStartingProficiencyOptionsWith []*ChoiceWhereInput `json:"hasStartingProficiencyOptionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RaceWhereInput) AddPredicates(predicates ...predicate.Race) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RaceWhereInput filter on the RaceQuery builder.
func (i *RaceWhereInput) Filter(q *RaceQuery) (*RaceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRaceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRaceWhereInput is returned in case the RaceWhereInput is empty.
var ErrEmptyRaceWhereInput = errors.New("ent: empty predicate RaceWhereInput")

// P returns a predicate for filtering races.
// An error is returned if the input is empty or invalid.
func (i *RaceWhereInput) P() (predicate.Race, error) {
	var predicates []predicate.Race
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, race.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Race, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, race.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Race, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, race.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, race.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, race.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, race.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, race.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, race.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, race.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, race.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, race.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, race.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, race.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, race.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, race.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, race.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, race.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, race.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, race.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, race.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, race.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, race.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, race.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, race.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, race.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, race.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, race.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, race.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, race.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, race.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, race.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, race.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, race.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, race.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, race.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, race.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, race.NameContainsFold(*i.NameContainsFold))
	}
	if i.Alignment != nil {
		predicates = append(predicates, race.AlignmentEQ(*i.Alignment))
	}
	if i.AlignmentNEQ != nil {
		predicates = append(predicates, race.AlignmentNEQ(*i.AlignmentNEQ))
	}
	if len(i.AlignmentIn) > 0 {
		predicates = append(predicates, race.AlignmentIn(i.AlignmentIn...))
	}
	if len(i.AlignmentNotIn) > 0 {
		predicates = append(predicates, race.AlignmentNotIn(i.AlignmentNotIn...))
	}
	if i.AlignmentGT != nil {
		predicates = append(predicates, race.AlignmentGT(*i.AlignmentGT))
	}
	if i.AlignmentGTE != nil {
		predicates = append(predicates, race.AlignmentGTE(*i.AlignmentGTE))
	}
	if i.AlignmentLT != nil {
		predicates = append(predicates, race.AlignmentLT(*i.AlignmentLT))
	}
	if i.AlignmentLTE != nil {
		predicates = append(predicates, race.AlignmentLTE(*i.AlignmentLTE))
	}
	if i.AlignmentContains != nil {
		predicates = append(predicates, race.AlignmentContains(*i.AlignmentContains))
	}
	if i.AlignmentHasPrefix != nil {
		predicates = append(predicates, race.AlignmentHasPrefix(*i.AlignmentHasPrefix))
	}
	if i.AlignmentHasSuffix != nil {
		predicates = append(predicates, race.AlignmentHasSuffix(*i.AlignmentHasSuffix))
	}
	if i.AlignmentEqualFold != nil {
		predicates = append(predicates, race.AlignmentEqualFold(*i.AlignmentEqualFold))
	}
	if i.AlignmentContainsFold != nil {
		predicates = append(predicates, race.AlignmentContainsFold(*i.AlignmentContainsFold))
	}
	if i.Age != nil {
		predicates = append(predicates, race.AgeEQ(*i.Age))
	}
	if i.AgeNEQ != nil {
		predicates = append(predicates, race.AgeNEQ(*i.AgeNEQ))
	}
	if len(i.AgeIn) > 0 {
		predicates = append(predicates, race.AgeIn(i.AgeIn...))
	}
	if len(i.AgeNotIn) > 0 {
		predicates = append(predicates, race.AgeNotIn(i.AgeNotIn...))
	}
	if i.AgeGT != nil {
		predicates = append(predicates, race.AgeGT(*i.AgeGT))
	}
	if i.AgeGTE != nil {
		predicates = append(predicates, race.AgeGTE(*i.AgeGTE))
	}
	if i.AgeLT != nil {
		predicates = append(predicates, race.AgeLT(*i.AgeLT))
	}
	if i.AgeLTE != nil {
		predicates = append(predicates, race.AgeLTE(*i.AgeLTE))
	}
	if i.AgeContains != nil {
		predicates = append(predicates, race.AgeContains(*i.AgeContains))
	}
	if i.AgeHasPrefix != nil {
		predicates = append(predicates, race.AgeHasPrefix(*i.AgeHasPrefix))
	}
	if i.AgeHasSuffix != nil {
		predicates = append(predicates, race.AgeHasSuffix(*i.AgeHasSuffix))
	}
	if i.AgeEqualFold != nil {
		predicates = append(predicates, race.AgeEqualFold(*i.AgeEqualFold))
	}
	if i.AgeContainsFold != nil {
		predicates = append(predicates, race.AgeContainsFold(*i.AgeContainsFold))
	}
	if i.Size != nil {
		predicates = append(predicates, race.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, race.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, race.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, race.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, race.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, race.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, race.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, race.SizeLTE(*i.SizeLTE))
	}
	if i.SizeContains != nil {
		predicates = append(predicates, race.SizeContains(*i.SizeContains))
	}
	if i.SizeHasPrefix != nil {
		predicates = append(predicates, race.SizeHasPrefix(*i.SizeHasPrefix))
	}
	if i.SizeHasSuffix != nil {
		predicates = append(predicates, race.SizeHasSuffix(*i.SizeHasSuffix))
	}
	if i.SizeEqualFold != nil {
		predicates = append(predicates, race.SizeEqualFold(*i.SizeEqualFold))
	}
	if i.SizeContainsFold != nil {
		predicates = append(predicates, race.SizeContainsFold(*i.SizeContainsFold))
	}
	if i.SizeDescription != nil {
		predicates = append(predicates, race.SizeDescriptionEQ(*i.SizeDescription))
	}
	if i.SizeDescriptionNEQ != nil {
		predicates = append(predicates, race.SizeDescriptionNEQ(*i.SizeDescriptionNEQ))
	}
	if len(i.SizeDescriptionIn) > 0 {
		predicates = append(predicates, race.SizeDescriptionIn(i.SizeDescriptionIn...))
	}
	if len(i.SizeDescriptionNotIn) > 0 {
		predicates = append(predicates, race.SizeDescriptionNotIn(i.SizeDescriptionNotIn...))
	}
	if i.SizeDescriptionGT != nil {
		predicates = append(predicates, race.SizeDescriptionGT(*i.SizeDescriptionGT))
	}
	if i.SizeDescriptionGTE != nil {
		predicates = append(predicates, race.SizeDescriptionGTE(*i.SizeDescriptionGTE))
	}
	if i.SizeDescriptionLT != nil {
		predicates = append(predicates, race.SizeDescriptionLT(*i.SizeDescriptionLT))
	}
	if i.SizeDescriptionLTE != nil {
		predicates = append(predicates, race.SizeDescriptionLTE(*i.SizeDescriptionLTE))
	}
	if i.SizeDescriptionContains != nil {
		predicates = append(predicates, race.SizeDescriptionContains(*i.SizeDescriptionContains))
	}
	if i.SizeDescriptionHasPrefix != nil {
		predicates = append(predicates, race.SizeDescriptionHasPrefix(*i.SizeDescriptionHasPrefix))
	}
	if i.SizeDescriptionHasSuffix != nil {
		predicates = append(predicates, race.SizeDescriptionHasSuffix(*i.SizeDescriptionHasSuffix))
	}
	if i.SizeDescriptionEqualFold != nil {
		predicates = append(predicates, race.SizeDescriptionEqualFold(*i.SizeDescriptionEqualFold))
	}
	if i.SizeDescriptionContainsFold != nil {
		predicates = append(predicates, race.SizeDescriptionContainsFold(*i.SizeDescriptionContainsFold))
	}
	if i.LanguageDesc != nil {
		predicates = append(predicates, race.LanguageDescEQ(*i.LanguageDesc))
	}
	if i.LanguageDescNEQ != nil {
		predicates = append(predicates, race.LanguageDescNEQ(*i.LanguageDescNEQ))
	}
	if len(i.LanguageDescIn) > 0 {
		predicates = append(predicates, race.LanguageDescIn(i.LanguageDescIn...))
	}
	if len(i.LanguageDescNotIn) > 0 {
		predicates = append(predicates, race.LanguageDescNotIn(i.LanguageDescNotIn...))
	}
	if i.LanguageDescGT != nil {
		predicates = append(predicates, race.LanguageDescGT(*i.LanguageDescGT))
	}
	if i.LanguageDescGTE != nil {
		predicates = append(predicates, race.LanguageDescGTE(*i.LanguageDescGTE))
	}
	if i.LanguageDescLT != nil {
		predicates = append(predicates, race.LanguageDescLT(*i.LanguageDescLT))
	}
	if i.LanguageDescLTE != nil {
		predicates = append(predicates, race.LanguageDescLTE(*i.LanguageDescLTE))
	}
	if i.LanguageDescContains != nil {
		predicates = append(predicates, race.LanguageDescContains(*i.LanguageDescContains))
	}
	if i.LanguageDescHasPrefix != nil {
		predicates = append(predicates, race.LanguageDescHasPrefix(*i.LanguageDescHasPrefix))
	}
	if i.LanguageDescHasSuffix != nil {
		predicates = append(predicates, race.LanguageDescHasSuffix(*i.LanguageDescHasSuffix))
	}
	if i.LanguageDescEqualFold != nil {
		predicates = append(predicates, race.LanguageDescEqualFold(*i.LanguageDescEqualFold))
	}
	if i.LanguageDescContainsFold != nil {
		predicates = append(predicates, race.LanguageDescContainsFold(*i.LanguageDescContainsFold))
	}
	if i.Speed != nil {
		predicates = append(predicates, race.SpeedEQ(*i.Speed))
	}
	if i.SpeedNEQ != nil {
		predicates = append(predicates, race.SpeedNEQ(*i.SpeedNEQ))
	}
	if len(i.SpeedIn) > 0 {
		predicates = append(predicates, race.SpeedIn(i.SpeedIn...))
	}
	if len(i.SpeedNotIn) > 0 {
		predicates = append(predicates, race.SpeedNotIn(i.SpeedNotIn...))
	}
	if i.SpeedGT != nil {
		predicates = append(predicates, race.SpeedGT(*i.SpeedGT))
	}
	if i.SpeedGTE != nil {
		predicates = append(predicates, race.SpeedGTE(*i.SpeedGTE))
	}
	if i.SpeedLT != nil {
		predicates = append(predicates, race.SpeedLT(*i.SpeedLT))
	}
	if i.SpeedLTE != nil {
		predicates = append(predicates, race.SpeedLTE(*i.SpeedLTE))
	}

	if i.HasLanguages != nil {
		p := race.HasLanguages()
		if !*i.HasLanguages {
			p = race.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLanguagesWith) > 0 {
		with := make([]predicate.Language, 0, len(i.HasLanguagesWith))
		for _, w := range i.HasLanguagesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLanguagesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, race.HasLanguagesWith(with...))
	}
	if i.HasProficiencies != nil {
		p := race.HasProficiencies()
		if !*i.HasProficiencies {
			p = race.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProficienciesWith) > 0 {
		with := make([]predicate.Proficiency, 0, len(i.HasProficienciesWith))
		for _, w := range i.HasProficienciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProficienciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, race.HasProficienciesWith(with...))
	}
	if i.HasSubraces != nil {
		p := race.HasSubraces()
		if !*i.HasSubraces {
			p = race.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubracesWith) > 0 {
		with := make([]predicate.Subrace, 0, len(i.HasSubracesWith))
		for _, w := range i.HasSubracesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubracesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, race.HasSubracesWith(with...))
	}
	if i.HasTraits != nil {
		p := race.HasTraits()
		if !*i.HasTraits {
			p = race.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTraitsWith) > 0 {
		with := make([]predicate.Trait, 0, len(i.HasTraitsWith))
		for _, w := range i.HasTraitsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTraitsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, race.HasTraitsWith(with...))
	}
	if i.HasAbilityBonuses != nil {
		p := race.HasAbilityBonuses()
		if !*i.HasAbilityBonuses {
			p = race.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAbilityBonusesWith) > 0 {
		with := make([]predicate.AbilityBonus, 0, len(i.HasAbilityBonusesWith))
		for _, w := range i.HasAbilityBonusesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAbilityBonusesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, race.HasAbilityBonusesWith(with...))
	}
	if i.HasStartingProficiencyOptions != nil {
		p := race.HasStartingProficiencyOptions()
		if !*i.HasStartingProficiencyOptions {
			p = race.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStartingProficiencyOptionsWith) > 0 {
		with := make([]predicate.Choice, 0, len(i.HasStartingProficiencyOptionsWith))
		for _, w := range i.HasStartingProficiencyOptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStartingProficiencyOptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, race.HasStartingProficiencyOptionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRaceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return race.And(predicates...), nil
	}
}

// RuleWhereInput represents a where input for filtering Rule queries.
type RuleWhereInput struct {
	Predicates []predicate.Rule  `json:"-"`
	Not        *RuleWhereInput   `json:"not,omitempty"`
	Or         []*RuleWhereInput `json:"or,omitempty"`
	And        []*RuleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "desc" field predicates.
	Desc             *string  `json:"desc,omitempty"`
	DescNEQ          *string  `json:"descNEQ,omitempty"`
	DescIn           []string `json:"descIn,omitempty"`
	DescNotIn        []string `json:"descNotIn,omitempty"`
	DescGT           *string  `json:"descGT,omitempty"`
	DescGTE          *string  `json:"descGTE,omitempty"`
	DescLT           *string  `json:"descLT,omitempty"`
	DescLTE          *string  `json:"descLTE,omitempty"`
	DescContains     *string  `json:"descContains,omitempty"`
	DescHasPrefix    *string  `json:"descHasPrefix,omitempty"`
	DescHasSuffix    *string  `json:"descHasSuffix,omitempty"`
	DescEqualFold    *string  `json:"descEqualFold,omitempty"`
	DescContainsFold *string  `json:"descContainsFold,omitempty"`

	// "rule_sections" edge predicates.
	HasRuleSections     *bool                    `json:"hasRuleSections,omitempty"`
	HasRuleSectionsWith []*RuleSectionWhereInput `json:"hasRuleSectionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RuleWhereInput) AddPredicates(predicates ...predicate.Rule) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RuleWhereInput filter on the RuleQuery builder.
func (i *RuleWhereInput) Filter(q *RuleQuery) (*RuleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRuleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRuleWhereInput is returned in case the RuleWhereInput is empty.
var ErrEmptyRuleWhereInput = errors.New("ent: empty predicate RuleWhereInput")

// P returns a predicate for filtering rules.
// An error is returned if the input is empty or invalid.
func (i *RuleWhereInput) P() (predicate.Rule, error) {
	var predicates []predicate.Rule
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, rule.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Rule, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, rule.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Rule, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, rule.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, rule.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, rule.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, rule.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, rule.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, rule.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, rule.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, rule.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, rule.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, rule.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, rule.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, rule.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, rule.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, rule.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, rule.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, rule.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, rule.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, rule.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, rule.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, rule.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, rule.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, rule.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, rule.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, rule.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, rule.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, rule.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, rule.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, rule.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, rule.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, rule.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, rule.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, rule.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, rule.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, rule.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, rule.NameContainsFold(*i.NameContainsFold))
	}
	if i.Desc != nil {
		predicates = append(predicates, rule.DescEQ(*i.Desc))
	}
	if i.DescNEQ != nil {
		predicates = append(predicates, rule.DescNEQ(*i.DescNEQ))
	}
	if len(i.DescIn) > 0 {
		predicates = append(predicates, rule.DescIn(i.DescIn...))
	}
	if len(i.DescNotIn) > 0 {
		predicates = append(predicates, rule.DescNotIn(i.DescNotIn...))
	}
	if i.DescGT != nil {
		predicates = append(predicates, rule.DescGT(*i.DescGT))
	}
	if i.DescGTE != nil {
		predicates = append(predicates, rule.DescGTE(*i.DescGTE))
	}
	if i.DescLT != nil {
		predicates = append(predicates, rule.DescLT(*i.DescLT))
	}
	if i.DescLTE != nil {
		predicates = append(predicates, rule.DescLTE(*i.DescLTE))
	}
	if i.DescContains != nil {
		predicates = append(predicates, rule.DescContains(*i.DescContains))
	}
	if i.DescHasPrefix != nil {
		predicates = append(predicates, rule.DescHasPrefix(*i.DescHasPrefix))
	}
	if i.DescHasSuffix != nil {
		predicates = append(predicates, rule.DescHasSuffix(*i.DescHasSuffix))
	}
	if i.DescEqualFold != nil {
		predicates = append(predicates, rule.DescEqualFold(*i.DescEqualFold))
	}
	if i.DescContainsFold != nil {
		predicates = append(predicates, rule.DescContainsFold(*i.DescContainsFold))
	}

	if i.HasRuleSections != nil {
		p := rule.HasRuleSections()
		if !*i.HasRuleSections {
			p = rule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRuleSectionsWith) > 0 {
		with := make([]predicate.RuleSection, 0, len(i.HasRuleSectionsWith))
		for _, w := range i.HasRuleSectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRuleSectionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, rule.HasRuleSectionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRuleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return rule.And(predicates...), nil
	}
}

// RuleSectionWhereInput represents a where input for filtering RuleSection queries.
type RuleSectionWhereInput struct {
	Predicates []predicate.RuleSection  `json:"-"`
	Not        *RuleSectionWhereInput   `json:"not,omitempty"`
	Or         []*RuleSectionWhereInput `json:"or,omitempty"`
	And        []*RuleSectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "desc" field predicates.
	Desc             *string  `json:"desc,omitempty"`
	DescNEQ          *string  `json:"descNEQ,omitempty"`
	DescIn           []string `json:"descIn,omitempty"`
	DescNotIn        []string `json:"descNotIn,omitempty"`
	DescGT           *string  `json:"descGT,omitempty"`
	DescGTE          *string  `json:"descGTE,omitempty"`
	DescLT           *string  `json:"descLT,omitempty"`
	DescLTE          *string  `json:"descLTE,omitempty"`
	DescContains     *string  `json:"descContains,omitempty"`
	DescHasPrefix    *string  `json:"descHasPrefix,omitempty"`
	DescHasSuffix    *string  `json:"descHasSuffix,omitempty"`
	DescEqualFold    *string  `json:"descEqualFold,omitempty"`
	DescContainsFold *string  `json:"descContainsFold,omitempty"`

	// "rules" edge predicates.
	HasRules     *bool             `json:"hasRules,omitempty"`
	HasRulesWith []*RuleWhereInput `json:"hasRulesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RuleSectionWhereInput) AddPredicates(predicates ...predicate.RuleSection) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RuleSectionWhereInput filter on the RuleSectionQuery builder.
func (i *RuleSectionWhereInput) Filter(q *RuleSectionQuery) (*RuleSectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRuleSectionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRuleSectionWhereInput is returned in case the RuleSectionWhereInput is empty.
var ErrEmptyRuleSectionWhereInput = errors.New("ent: empty predicate RuleSectionWhereInput")

// P returns a predicate for filtering rulesections.
// An error is returned if the input is empty or invalid.
func (i *RuleSectionWhereInput) P() (predicate.RuleSection, error) {
	var predicates []predicate.RuleSection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, rulesection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RuleSection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, rulesection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RuleSection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, rulesection.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, rulesection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, rulesection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, rulesection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, rulesection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, rulesection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, rulesection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, rulesection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, rulesection.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, rulesection.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, rulesection.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, rulesection.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, rulesection.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, rulesection.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, rulesection.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, rulesection.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, rulesection.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, rulesection.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, rulesection.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, rulesection.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, rulesection.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, rulesection.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, rulesection.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, rulesection.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, rulesection.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, rulesection.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, rulesection.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, rulesection.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, rulesection.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, rulesection.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, rulesection.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, rulesection.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, rulesection.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, rulesection.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, rulesection.NameContainsFold(*i.NameContainsFold))
	}
	if i.Desc != nil {
		predicates = append(predicates, rulesection.DescEQ(*i.Desc))
	}
	if i.DescNEQ != nil {
		predicates = append(predicates, rulesection.DescNEQ(*i.DescNEQ))
	}
	if len(i.DescIn) > 0 {
		predicates = append(predicates, rulesection.DescIn(i.DescIn...))
	}
	if len(i.DescNotIn) > 0 {
		predicates = append(predicates, rulesection.DescNotIn(i.DescNotIn...))
	}
	if i.DescGT != nil {
		predicates = append(predicates, rulesection.DescGT(*i.DescGT))
	}
	if i.DescGTE != nil {
		predicates = append(predicates, rulesection.DescGTE(*i.DescGTE))
	}
	if i.DescLT != nil {
		predicates = append(predicates, rulesection.DescLT(*i.DescLT))
	}
	if i.DescLTE != nil {
		predicates = append(predicates, rulesection.DescLTE(*i.DescLTE))
	}
	if i.DescContains != nil {
		predicates = append(predicates, rulesection.DescContains(*i.DescContains))
	}
	if i.DescHasPrefix != nil {
		predicates = append(predicates, rulesection.DescHasPrefix(*i.DescHasPrefix))
	}
	if i.DescHasSuffix != nil {
		predicates = append(predicates, rulesection.DescHasSuffix(*i.DescHasSuffix))
	}
	if i.DescEqualFold != nil {
		predicates = append(predicates, rulesection.DescEqualFold(*i.DescEqualFold))
	}
	if i.DescContainsFold != nil {
		predicates = append(predicates, rulesection.DescContainsFold(*i.DescContainsFold))
	}

	if i.HasRules != nil {
		p := rulesection.HasRules()
		if !*i.HasRules {
			p = rulesection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRulesWith) > 0 {
		with := make([]predicate.Rule, 0, len(i.HasRulesWith))
		for _, w := range i.HasRulesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRulesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, rulesection.HasRulesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRuleSectionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return rulesection.And(predicates...), nil
	}
}

// SkillWhereInput represents a where input for filtering Skill queries.
type SkillWhereInput struct {
	Predicates []predicate.Skill  `json:"-"`
	Not        *SkillWhereInput   `json:"not,omitempty"`
	Or         []*SkillWhereInput `json:"or,omitempty"`
	And        []*SkillWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "ability_score" edge predicates.
	HasAbilityScore     *bool                     `json:"hasAbilityScore,omitempty"`
	HasAbilityScoreWith []*AbilityScoreWhereInput `json:"hasAbilityScoreWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SkillWhereInput) AddPredicates(predicates ...predicate.Skill) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SkillWhereInput filter on the SkillQuery builder.
func (i *SkillWhereInput) Filter(q *SkillQuery) (*SkillQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySkillWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySkillWhereInput is returned in case the SkillWhereInput is empty.
var ErrEmptySkillWhereInput = errors.New("ent: empty predicate SkillWhereInput")

// P returns a predicate for filtering skills.
// An error is returned if the input is empty or invalid.
func (i *SkillWhereInput) P() (predicate.Skill, error) {
	var predicates []predicate.Skill
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, skill.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Skill, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, skill.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Skill, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, skill.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, skill.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, skill.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, skill.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, skill.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, skill.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, skill.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, skill.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, skill.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, skill.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, skill.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, skill.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, skill.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, skill.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, skill.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, skill.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, skill.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, skill.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, skill.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, skill.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, skill.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, skill.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, skill.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, skill.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, skill.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, skill.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, skill.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, skill.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, skill.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, skill.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, skill.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, skill.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, skill.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, skill.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, skill.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasAbilityScore != nil {
		p := skill.HasAbilityScore()
		if !*i.HasAbilityScore {
			p = skill.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAbilityScoreWith) > 0 {
		with := make([]predicate.AbilityScore, 0, len(i.HasAbilityScoreWith))
		for _, w := range i.HasAbilityScoreWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAbilityScoreWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, skill.HasAbilityScoreWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySkillWhereInput
	case 1:
		return predicates[0], nil
	default:
		return skill.And(predicates...), nil
	}
}

// SubraceWhereInput represents a where input for filtering Subrace queries.
type SubraceWhereInput struct {
	Predicates []predicate.Subrace  `json:"-"`
	Not        *SubraceWhereInput   `json:"not,omitempty"`
	Or         []*SubraceWhereInput `json:"or,omitempty"`
	And        []*SubraceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "desc" field predicates.
	Desc             *string  `json:"desc,omitempty"`
	DescNEQ          *string  `json:"descNEQ,omitempty"`
	DescIn           []string `json:"descIn,omitempty"`
	DescNotIn        []string `json:"descNotIn,omitempty"`
	DescGT           *string  `json:"descGT,omitempty"`
	DescGTE          *string  `json:"descGTE,omitempty"`
	DescLT           *string  `json:"descLT,omitempty"`
	DescLTE          *string  `json:"descLTE,omitempty"`
	DescContains     *string  `json:"descContains,omitempty"`
	DescHasPrefix    *string  `json:"descHasPrefix,omitempty"`
	DescHasSuffix    *string  `json:"descHasSuffix,omitempty"`
	DescEqualFold    *string  `json:"descEqualFold,omitempty"`
	DescContainsFold *string  `json:"descContainsFold,omitempty"`

	// "race" edge predicates.
	HasRace     *bool             `json:"hasRace,omitempty"`
	HasRaceWith []*RaceWhereInput `json:"hasRaceWith,omitempty"`

	// "proficiencies" edge predicates.
	HasProficiencies     *bool                    `json:"hasProficiencies,omitempty"`
	HasProficienciesWith []*ProficiencyWhereInput `json:"hasProficienciesWith,omitempty"`

	// "traits" edge predicates.
	HasTraits     *bool              `json:"hasTraits,omitempty"`
	HasTraitsWith []*TraitWhereInput `json:"hasTraitsWith,omitempty"`

	// "ability_bonuses" edge predicates.
	HasAbilityBonuses     *bool                     `json:"hasAbilityBonuses,omitempty"`
	HasAbilityBonusesWith []*AbilityBonusWhereInput `json:"hasAbilityBonusesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SubraceWhereInput) AddPredicates(predicates ...predicate.Subrace) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SubraceWhereInput filter on the SubraceQuery builder.
func (i *SubraceWhereInput) Filter(q *SubraceQuery) (*SubraceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySubraceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySubraceWhereInput is returned in case the SubraceWhereInput is empty.
var ErrEmptySubraceWhereInput = errors.New("ent: empty predicate SubraceWhereInput")

// P returns a predicate for filtering subraces.
// An error is returned if the input is empty or invalid.
func (i *SubraceWhereInput) P() (predicate.Subrace, error) {
	var predicates []predicate.Subrace
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, subrace.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Subrace, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, subrace.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Subrace, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, subrace.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, subrace.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, subrace.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, subrace.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, subrace.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, subrace.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, subrace.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, subrace.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, subrace.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, subrace.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, subrace.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, subrace.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, subrace.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, subrace.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, subrace.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, subrace.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, subrace.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, subrace.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, subrace.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, subrace.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, subrace.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, subrace.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, subrace.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, subrace.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, subrace.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, subrace.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, subrace.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, subrace.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, subrace.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, subrace.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, subrace.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, subrace.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, subrace.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, subrace.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, subrace.NameContainsFold(*i.NameContainsFold))
	}
	if i.Desc != nil {
		predicates = append(predicates, subrace.DescEQ(*i.Desc))
	}
	if i.DescNEQ != nil {
		predicates = append(predicates, subrace.DescNEQ(*i.DescNEQ))
	}
	if len(i.DescIn) > 0 {
		predicates = append(predicates, subrace.DescIn(i.DescIn...))
	}
	if len(i.DescNotIn) > 0 {
		predicates = append(predicates, subrace.DescNotIn(i.DescNotIn...))
	}
	if i.DescGT != nil {
		predicates = append(predicates, subrace.DescGT(*i.DescGT))
	}
	if i.DescGTE != nil {
		predicates = append(predicates, subrace.DescGTE(*i.DescGTE))
	}
	if i.DescLT != nil {
		predicates = append(predicates, subrace.DescLT(*i.DescLT))
	}
	if i.DescLTE != nil {
		predicates = append(predicates, subrace.DescLTE(*i.DescLTE))
	}
	if i.DescContains != nil {
		predicates = append(predicates, subrace.DescContains(*i.DescContains))
	}
	if i.DescHasPrefix != nil {
		predicates = append(predicates, subrace.DescHasPrefix(*i.DescHasPrefix))
	}
	if i.DescHasSuffix != nil {
		predicates = append(predicates, subrace.DescHasSuffix(*i.DescHasSuffix))
	}
	if i.DescEqualFold != nil {
		predicates = append(predicates, subrace.DescEqualFold(*i.DescEqualFold))
	}
	if i.DescContainsFold != nil {
		predicates = append(predicates, subrace.DescContainsFold(*i.DescContainsFold))
	}

	if i.HasRace != nil {
		p := subrace.HasRace()
		if !*i.HasRace {
			p = subrace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRaceWith) > 0 {
		with := make([]predicate.Race, 0, len(i.HasRaceWith))
		for _, w := range i.HasRaceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRaceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subrace.HasRaceWith(with...))
	}
	if i.HasProficiencies != nil {
		p := subrace.HasProficiencies()
		if !*i.HasProficiencies {
			p = subrace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProficienciesWith) > 0 {
		with := make([]predicate.Proficiency, 0, len(i.HasProficienciesWith))
		for _, w := range i.HasProficienciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProficienciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subrace.HasProficienciesWith(with...))
	}
	if i.HasTraits != nil {
		p := subrace.HasTraits()
		if !*i.HasTraits {
			p = subrace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTraitsWith) > 0 {
		with := make([]predicate.Trait, 0, len(i.HasTraitsWith))
		for _, w := range i.HasTraitsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTraitsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subrace.HasTraitsWith(with...))
	}
	if i.HasAbilityBonuses != nil {
		p := subrace.HasAbilityBonuses()
		if !*i.HasAbilityBonuses {
			p = subrace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAbilityBonusesWith) > 0 {
		with := make([]predicate.AbilityBonus, 0, len(i.HasAbilityBonusesWith))
		for _, w := range i.HasAbilityBonusesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAbilityBonusesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subrace.HasAbilityBonusesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySubraceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return subrace.And(predicates...), nil
	}
}

// ToolWhereInput represents a where input for filtering Tool queries.
type ToolWhereInput struct {
	Predicates []predicate.Tool  `json:"-"`
	Not        *ToolWhereInput   `json:"not,omitempty"`
	Or         []*ToolWhereInput `json:"or,omitempty"`
	And        []*ToolWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "tool_category" field predicates.
	ToolCategory             *string  `json:"toolCategory,omitempty"`
	ToolCategoryNEQ          *string  `json:"toolCategoryNEQ,omitempty"`
	ToolCategoryIn           []string `json:"toolCategoryIn,omitempty"`
	ToolCategoryNotIn        []string `json:"toolCategoryNotIn,omitempty"`
	ToolCategoryGT           *string  `json:"toolCategoryGT,omitempty"`
	ToolCategoryGTE          *string  `json:"toolCategoryGTE,omitempty"`
	ToolCategoryLT           *string  `json:"toolCategoryLT,omitempty"`
	ToolCategoryLTE          *string  `json:"toolCategoryLTE,omitempty"`
	ToolCategoryContains     *string  `json:"toolCategoryContains,omitempty"`
	ToolCategoryHasPrefix    *string  `json:"toolCategoryHasPrefix,omitempty"`
	ToolCategoryHasSuffix    *string  `json:"toolCategoryHasSuffix,omitempty"`
	ToolCategoryEqualFold    *string  `json:"toolCategoryEqualFold,omitempty"`
	ToolCategoryContainsFold *string  `json:"toolCategoryContainsFold,omitempty"`

	// "equipment_id" field predicates.
	EquipmentID      *int  `json:"equipmentID,omitempty"`
	EquipmentIDNEQ   *int  `json:"equipmentIDNEQ,omitempty"`
	EquipmentIDIn    []int `json:"equipmentIDIn,omitempty"`
	EquipmentIDNotIn []int `json:"equipmentIDNotIn,omitempty"`

	// "equipment" edge predicates.
	HasEquipment     *bool                  `json:"hasEquipment,omitempty"`
	HasEquipmentWith []*EquipmentWhereInput `json:"hasEquipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ToolWhereInput) AddPredicates(predicates ...predicate.Tool) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ToolWhereInput filter on the ToolQuery builder.
func (i *ToolWhereInput) Filter(q *ToolQuery) (*ToolQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyToolWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyToolWhereInput is returned in case the ToolWhereInput is empty.
var ErrEmptyToolWhereInput = errors.New("ent: empty predicate ToolWhereInput")

// P returns a predicate for filtering tools.
// An error is returned if the input is empty or invalid.
func (i *ToolWhereInput) P() (predicate.Tool, error) {
	var predicates []predicate.Tool
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tool.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tool, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tool.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tool, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tool.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tool.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tool.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tool.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tool.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tool.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tool.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tool.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tool.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, tool.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, tool.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, tool.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, tool.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, tool.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, tool.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, tool.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, tool.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, tool.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, tool.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, tool.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, tool.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, tool.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, tool.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, tool.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, tool.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, tool.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, tool.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, tool.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, tool.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, tool.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, tool.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, tool.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, tool.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, tool.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, tool.NameContainsFold(*i.NameContainsFold))
	}
	if i.ToolCategory != nil {
		predicates = append(predicates, tool.ToolCategoryEQ(*i.ToolCategory))
	}
	if i.ToolCategoryNEQ != nil {
		predicates = append(predicates, tool.ToolCategoryNEQ(*i.ToolCategoryNEQ))
	}
	if len(i.ToolCategoryIn) > 0 {
		predicates = append(predicates, tool.ToolCategoryIn(i.ToolCategoryIn...))
	}
	if len(i.ToolCategoryNotIn) > 0 {
		predicates = append(predicates, tool.ToolCategoryNotIn(i.ToolCategoryNotIn...))
	}
	if i.ToolCategoryGT != nil {
		predicates = append(predicates, tool.ToolCategoryGT(*i.ToolCategoryGT))
	}
	if i.ToolCategoryGTE != nil {
		predicates = append(predicates, tool.ToolCategoryGTE(*i.ToolCategoryGTE))
	}
	if i.ToolCategoryLT != nil {
		predicates = append(predicates, tool.ToolCategoryLT(*i.ToolCategoryLT))
	}
	if i.ToolCategoryLTE != nil {
		predicates = append(predicates, tool.ToolCategoryLTE(*i.ToolCategoryLTE))
	}
	if i.ToolCategoryContains != nil {
		predicates = append(predicates, tool.ToolCategoryContains(*i.ToolCategoryContains))
	}
	if i.ToolCategoryHasPrefix != nil {
		predicates = append(predicates, tool.ToolCategoryHasPrefix(*i.ToolCategoryHasPrefix))
	}
	if i.ToolCategoryHasSuffix != nil {
		predicates = append(predicates, tool.ToolCategoryHasSuffix(*i.ToolCategoryHasSuffix))
	}
	if i.ToolCategoryEqualFold != nil {
		predicates = append(predicates, tool.ToolCategoryEqualFold(*i.ToolCategoryEqualFold))
	}
	if i.ToolCategoryContainsFold != nil {
		predicates = append(predicates, tool.ToolCategoryContainsFold(*i.ToolCategoryContainsFold))
	}
	if i.EquipmentID != nil {
		predicates = append(predicates, tool.EquipmentIDEQ(*i.EquipmentID))
	}
	if i.EquipmentIDNEQ != nil {
		predicates = append(predicates, tool.EquipmentIDNEQ(*i.EquipmentIDNEQ))
	}
	if len(i.EquipmentIDIn) > 0 {
		predicates = append(predicates, tool.EquipmentIDIn(i.EquipmentIDIn...))
	}
	if len(i.EquipmentIDNotIn) > 0 {
		predicates = append(predicates, tool.EquipmentIDNotIn(i.EquipmentIDNotIn...))
	}

	if i.HasEquipment != nil {
		p := tool.HasEquipment()
		if !*i.HasEquipment {
			p = tool.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentWith))
		for _, w := range i.HasEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tool.HasEquipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyToolWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tool.And(predicates...), nil
	}
}

// TraitWhereInput represents a where input for filtering Trait queries.
type TraitWhereInput struct {
	Predicates []predicate.Trait  `json:"-"`
	Not        *TraitWhereInput   `json:"not,omitempty"`
	Or         []*TraitWhereInput `json:"or,omitempty"`
	And        []*TraitWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "races" edge predicates.
	HasRaces     *bool             `json:"hasRaces,omitempty"`
	HasRacesWith []*RaceWhereInput `json:"hasRacesWith,omitempty"`

	// "subraces" edge predicates.
	HasSubraces     *bool                `json:"hasSubraces,omitempty"`
	HasSubracesWith []*SubraceWhereInput `json:"hasSubracesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TraitWhereInput) AddPredicates(predicates ...predicate.Trait) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TraitWhereInput filter on the TraitQuery builder.
func (i *TraitWhereInput) Filter(q *TraitQuery) (*TraitQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTraitWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTraitWhereInput is returned in case the TraitWhereInput is empty.
var ErrEmptyTraitWhereInput = errors.New("ent: empty predicate TraitWhereInput")

// P returns a predicate for filtering traits.
// An error is returned if the input is empty or invalid.
func (i *TraitWhereInput) P() (predicate.Trait, error) {
	var predicates []predicate.Trait
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, trait.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Trait, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, trait.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Trait, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, trait.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, trait.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, trait.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, trait.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, trait.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, trait.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, trait.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, trait.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, trait.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, trait.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, trait.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, trait.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, trait.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, trait.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, trait.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, trait.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, trait.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, trait.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, trait.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, trait.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, trait.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, trait.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, trait.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, trait.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, trait.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, trait.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, trait.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, trait.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, trait.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, trait.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, trait.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, trait.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, trait.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, trait.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, trait.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasRaces != nil {
		p := trait.HasRaces()
		if !*i.HasRaces {
			p = trait.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRacesWith) > 0 {
		with := make([]predicate.Race, 0, len(i.HasRacesWith))
		for _, w := range i.HasRacesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRacesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trait.HasRacesWith(with...))
	}
	if i.HasSubraces != nil {
		p := trait.HasSubraces()
		if !*i.HasSubraces {
			p = trait.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubracesWith) > 0 {
		with := make([]predicate.Subrace, 0, len(i.HasSubracesWith))
		for _, w := range i.HasSubracesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubracesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trait.HasSubracesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTraitWhereInput
	case 1:
		return predicates[0], nil
	default:
		return trait.And(predicates...), nil
	}
}

// VehicleWhereInput represents a where input for filtering Vehicle queries.
type VehicleWhereInput struct {
	Predicates []predicate.Vehicle  `json:"-"`
	Not        *VehicleWhereInput   `json:"not,omitempty"`
	Or         []*VehicleWhereInput `json:"or,omitempty"`
	And        []*VehicleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "vehicle_category" field predicates.
	VehicleCategory             *string  `json:"vehicleCategory,omitempty"`
	VehicleCategoryNEQ          *string  `json:"vehicleCategoryNEQ,omitempty"`
	VehicleCategoryIn           []string `json:"vehicleCategoryIn,omitempty"`
	VehicleCategoryNotIn        []string `json:"vehicleCategoryNotIn,omitempty"`
	VehicleCategoryGT           *string  `json:"vehicleCategoryGT,omitempty"`
	VehicleCategoryGTE          *string  `json:"vehicleCategoryGTE,omitempty"`
	VehicleCategoryLT           *string  `json:"vehicleCategoryLT,omitempty"`
	VehicleCategoryLTE          *string  `json:"vehicleCategoryLTE,omitempty"`
	VehicleCategoryContains     *string  `json:"vehicleCategoryContains,omitempty"`
	VehicleCategoryHasPrefix    *string  `json:"vehicleCategoryHasPrefix,omitempty"`
	VehicleCategoryHasSuffix    *string  `json:"vehicleCategoryHasSuffix,omitempty"`
	VehicleCategoryEqualFold    *string  `json:"vehicleCategoryEqualFold,omitempty"`
	VehicleCategoryContainsFold *string  `json:"vehicleCategoryContainsFold,omitempty"`

	// "capacity" field predicates.
	Capacity             *string  `json:"capacity,omitempty"`
	CapacityNEQ          *string  `json:"capacityNEQ,omitempty"`
	CapacityIn           []string `json:"capacityIn,omitempty"`
	CapacityNotIn        []string `json:"capacityNotIn,omitempty"`
	CapacityGT           *string  `json:"capacityGT,omitempty"`
	CapacityGTE          *string  `json:"capacityGTE,omitempty"`
	CapacityLT           *string  `json:"capacityLT,omitempty"`
	CapacityLTE          *string  `json:"capacityLTE,omitempty"`
	CapacityContains     *string  `json:"capacityContains,omitempty"`
	CapacityHasPrefix    *string  `json:"capacityHasPrefix,omitempty"`
	CapacityHasSuffix    *string  `json:"capacityHasSuffix,omitempty"`
	CapacityEqualFold    *string  `json:"capacityEqualFold,omitempty"`
	CapacityContainsFold *string  `json:"capacityContainsFold,omitempty"`

	// "equipment_id" field predicates.
	EquipmentID      *int  `json:"equipmentID,omitempty"`
	EquipmentIDNEQ   *int  `json:"equipmentIDNEQ,omitempty"`
	EquipmentIDIn    []int `json:"equipmentIDIn,omitempty"`
	EquipmentIDNotIn []int `json:"equipmentIDNotIn,omitempty"`

	// "equipment" edge predicates.
	HasEquipment     *bool                  `json:"hasEquipment,omitempty"`
	HasEquipmentWith []*EquipmentWhereInput `json:"hasEquipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *VehicleWhereInput) AddPredicates(predicates ...predicate.Vehicle) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the VehicleWhereInput filter on the VehicleQuery builder.
func (i *VehicleWhereInput) Filter(q *VehicleQuery) (*VehicleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyVehicleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyVehicleWhereInput is returned in case the VehicleWhereInput is empty.
var ErrEmptyVehicleWhereInput = errors.New("ent: empty predicate VehicleWhereInput")

// P returns a predicate for filtering vehicles.
// An error is returned if the input is empty or invalid.
func (i *VehicleWhereInput) P() (predicate.Vehicle, error) {
	var predicates []predicate.Vehicle
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, vehicle.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Vehicle, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, vehicle.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Vehicle, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, vehicle.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, vehicle.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vehicle.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vehicle.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vehicle.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vehicle.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vehicle.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vehicle.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vehicle.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, vehicle.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, vehicle.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, vehicle.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, vehicle.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, vehicle.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, vehicle.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, vehicle.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, vehicle.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, vehicle.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, vehicle.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, vehicle.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, vehicle.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, vehicle.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, vehicle.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, vehicle.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, vehicle.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, vehicle.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, vehicle.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, vehicle.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, vehicle.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, vehicle.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, vehicle.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, vehicle.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, vehicle.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, vehicle.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, vehicle.NameContainsFold(*i.NameContainsFold))
	}
	if i.VehicleCategory != nil {
		predicates = append(predicates, vehicle.VehicleCategoryEQ(*i.VehicleCategory))
	}
	if i.VehicleCategoryNEQ != nil {
		predicates = append(predicates, vehicle.VehicleCategoryNEQ(*i.VehicleCategoryNEQ))
	}
	if len(i.VehicleCategoryIn) > 0 {
		predicates = append(predicates, vehicle.VehicleCategoryIn(i.VehicleCategoryIn...))
	}
	if len(i.VehicleCategoryNotIn) > 0 {
		predicates = append(predicates, vehicle.VehicleCategoryNotIn(i.VehicleCategoryNotIn...))
	}
	if i.VehicleCategoryGT != nil {
		predicates = append(predicates, vehicle.VehicleCategoryGT(*i.VehicleCategoryGT))
	}
	if i.VehicleCategoryGTE != nil {
		predicates = append(predicates, vehicle.VehicleCategoryGTE(*i.VehicleCategoryGTE))
	}
	if i.VehicleCategoryLT != nil {
		predicates = append(predicates, vehicle.VehicleCategoryLT(*i.VehicleCategoryLT))
	}
	if i.VehicleCategoryLTE != nil {
		predicates = append(predicates, vehicle.VehicleCategoryLTE(*i.VehicleCategoryLTE))
	}
	if i.VehicleCategoryContains != nil {
		predicates = append(predicates, vehicle.VehicleCategoryContains(*i.VehicleCategoryContains))
	}
	if i.VehicleCategoryHasPrefix != nil {
		predicates = append(predicates, vehicle.VehicleCategoryHasPrefix(*i.VehicleCategoryHasPrefix))
	}
	if i.VehicleCategoryHasSuffix != nil {
		predicates = append(predicates, vehicle.VehicleCategoryHasSuffix(*i.VehicleCategoryHasSuffix))
	}
	if i.VehicleCategoryEqualFold != nil {
		predicates = append(predicates, vehicle.VehicleCategoryEqualFold(*i.VehicleCategoryEqualFold))
	}
	if i.VehicleCategoryContainsFold != nil {
		predicates = append(predicates, vehicle.VehicleCategoryContainsFold(*i.VehicleCategoryContainsFold))
	}
	if i.Capacity != nil {
		predicates = append(predicates, vehicle.CapacityEQ(*i.Capacity))
	}
	if i.CapacityNEQ != nil {
		predicates = append(predicates, vehicle.CapacityNEQ(*i.CapacityNEQ))
	}
	if len(i.CapacityIn) > 0 {
		predicates = append(predicates, vehicle.CapacityIn(i.CapacityIn...))
	}
	if len(i.CapacityNotIn) > 0 {
		predicates = append(predicates, vehicle.CapacityNotIn(i.CapacityNotIn...))
	}
	if i.CapacityGT != nil {
		predicates = append(predicates, vehicle.CapacityGT(*i.CapacityGT))
	}
	if i.CapacityGTE != nil {
		predicates = append(predicates, vehicle.CapacityGTE(*i.CapacityGTE))
	}
	if i.CapacityLT != nil {
		predicates = append(predicates, vehicle.CapacityLT(*i.CapacityLT))
	}
	if i.CapacityLTE != nil {
		predicates = append(predicates, vehicle.CapacityLTE(*i.CapacityLTE))
	}
	if i.CapacityContains != nil {
		predicates = append(predicates, vehicle.CapacityContains(*i.CapacityContains))
	}
	if i.CapacityHasPrefix != nil {
		predicates = append(predicates, vehicle.CapacityHasPrefix(*i.CapacityHasPrefix))
	}
	if i.CapacityHasSuffix != nil {
		predicates = append(predicates, vehicle.CapacityHasSuffix(*i.CapacityHasSuffix))
	}
	if i.CapacityEqualFold != nil {
		predicates = append(predicates, vehicle.CapacityEqualFold(*i.CapacityEqualFold))
	}
	if i.CapacityContainsFold != nil {
		predicates = append(predicates, vehicle.CapacityContainsFold(*i.CapacityContainsFold))
	}
	if i.EquipmentID != nil {
		predicates = append(predicates, vehicle.EquipmentIDEQ(*i.EquipmentID))
	}
	if i.EquipmentIDNEQ != nil {
		predicates = append(predicates, vehicle.EquipmentIDNEQ(*i.EquipmentIDNEQ))
	}
	if len(i.EquipmentIDIn) > 0 {
		predicates = append(predicates, vehicle.EquipmentIDIn(i.EquipmentIDIn...))
	}
	if len(i.EquipmentIDNotIn) > 0 {
		predicates = append(predicates, vehicle.EquipmentIDNotIn(i.EquipmentIDNotIn...))
	}

	if i.HasEquipment != nil {
		p := vehicle.HasEquipment()
		if !*i.HasEquipment {
			p = vehicle.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentWith))
		for _, w := range i.HasEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, vehicle.HasEquipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyVehicleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return vehicle.And(predicates...), nil
	}
}

// WeaponWhereInput represents a where input for filtering Weapon queries.
type WeaponWhereInput struct {
	Predicates []predicate.Weapon  `json:"-"`
	Not        *WeaponWhereInput   `json:"not,omitempty"`
	Or         []*WeaponWhereInput `json:"or,omitempty"`
	And        []*WeaponWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "weapon_category" field predicates.
	WeaponCategory             *string  `json:"weaponCategory,omitempty"`
	WeaponCategoryNEQ          *string  `json:"weaponCategoryNEQ,omitempty"`
	WeaponCategoryIn           []string `json:"weaponCategoryIn,omitempty"`
	WeaponCategoryNotIn        []string `json:"weaponCategoryNotIn,omitempty"`
	WeaponCategoryGT           *string  `json:"weaponCategoryGT,omitempty"`
	WeaponCategoryGTE          *string  `json:"weaponCategoryGTE,omitempty"`
	WeaponCategoryLT           *string  `json:"weaponCategoryLT,omitempty"`
	WeaponCategoryLTE          *string  `json:"weaponCategoryLTE,omitempty"`
	WeaponCategoryContains     *string  `json:"weaponCategoryContains,omitempty"`
	WeaponCategoryHasPrefix    *string  `json:"weaponCategoryHasPrefix,omitempty"`
	WeaponCategoryHasSuffix    *string  `json:"weaponCategoryHasSuffix,omitempty"`
	WeaponCategoryEqualFold    *string  `json:"weaponCategoryEqualFold,omitempty"`
	WeaponCategoryContainsFold *string  `json:"weaponCategoryContainsFold,omitempty"`

	// "weapon_range" field predicates.
	WeaponRange             *string  `json:"weaponRange,omitempty"`
	WeaponRangeNEQ          *string  `json:"weaponRangeNEQ,omitempty"`
	WeaponRangeIn           []string `json:"weaponRangeIn,omitempty"`
	WeaponRangeNotIn        []string `json:"weaponRangeNotIn,omitempty"`
	WeaponRangeGT           *string  `json:"weaponRangeGT,omitempty"`
	WeaponRangeGTE          *string  `json:"weaponRangeGTE,omitempty"`
	WeaponRangeLT           *string  `json:"weaponRangeLT,omitempty"`
	WeaponRangeLTE          *string  `json:"weaponRangeLTE,omitempty"`
	WeaponRangeContains     *string  `json:"weaponRangeContains,omitempty"`
	WeaponRangeHasPrefix    *string  `json:"weaponRangeHasPrefix,omitempty"`
	WeaponRangeHasSuffix    *string  `json:"weaponRangeHasSuffix,omitempty"`
	WeaponRangeEqualFold    *string  `json:"weaponRangeEqualFold,omitempty"`
	WeaponRangeContainsFold *string  `json:"weaponRangeContainsFold,omitempty"`

	// "equipment" edge predicates.
	HasEquipment     *bool                  `json:"hasEquipment,omitempty"`
	HasEquipmentWith []*EquipmentWhereInput `json:"hasEquipmentWith,omitempty"`

	// "weapon_damage" edge predicates.
	HasWeaponDamage     *bool                     `json:"hasWeaponDamage,omitempty"`
	HasWeaponDamageWith []*WeaponDamageWhereInput `json:"hasWeaponDamageWith,omitempty"`

	// "weapon_properties" edge predicates.
	HasWeaponProperties     *bool                       `json:"hasWeaponProperties,omitempty"`
	HasWeaponPropertiesWith []*WeaponPropertyWhereInput `json:"hasWeaponPropertiesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WeaponWhereInput) AddPredicates(predicates ...predicate.Weapon) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WeaponWhereInput filter on the WeaponQuery builder.
func (i *WeaponWhereInput) Filter(q *WeaponQuery) (*WeaponQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWeaponWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWeaponWhereInput is returned in case the WeaponWhereInput is empty.
var ErrEmptyWeaponWhereInput = errors.New("ent: empty predicate WeaponWhereInput")

// P returns a predicate for filtering weapons.
// An error is returned if the input is empty or invalid.
func (i *WeaponWhereInput) P() (predicate.Weapon, error) {
	var predicates []predicate.Weapon
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, weapon.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Weapon, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, weapon.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Weapon, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, weapon.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, weapon.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, weapon.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, weapon.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, weapon.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, weapon.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, weapon.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, weapon.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, weapon.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, weapon.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, weapon.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, weapon.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, weapon.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, weapon.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, weapon.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, weapon.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, weapon.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, weapon.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, weapon.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, weapon.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, weapon.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, weapon.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, weapon.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, weapon.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, weapon.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, weapon.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, weapon.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, weapon.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, weapon.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, weapon.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, weapon.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, weapon.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, weapon.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, weapon.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, weapon.NameContainsFold(*i.NameContainsFold))
	}
	if i.WeaponCategory != nil {
		predicates = append(predicates, weapon.WeaponCategoryEQ(*i.WeaponCategory))
	}
	if i.WeaponCategoryNEQ != nil {
		predicates = append(predicates, weapon.WeaponCategoryNEQ(*i.WeaponCategoryNEQ))
	}
	if len(i.WeaponCategoryIn) > 0 {
		predicates = append(predicates, weapon.WeaponCategoryIn(i.WeaponCategoryIn...))
	}
	if len(i.WeaponCategoryNotIn) > 0 {
		predicates = append(predicates, weapon.WeaponCategoryNotIn(i.WeaponCategoryNotIn...))
	}
	if i.WeaponCategoryGT != nil {
		predicates = append(predicates, weapon.WeaponCategoryGT(*i.WeaponCategoryGT))
	}
	if i.WeaponCategoryGTE != nil {
		predicates = append(predicates, weapon.WeaponCategoryGTE(*i.WeaponCategoryGTE))
	}
	if i.WeaponCategoryLT != nil {
		predicates = append(predicates, weapon.WeaponCategoryLT(*i.WeaponCategoryLT))
	}
	if i.WeaponCategoryLTE != nil {
		predicates = append(predicates, weapon.WeaponCategoryLTE(*i.WeaponCategoryLTE))
	}
	if i.WeaponCategoryContains != nil {
		predicates = append(predicates, weapon.WeaponCategoryContains(*i.WeaponCategoryContains))
	}
	if i.WeaponCategoryHasPrefix != nil {
		predicates = append(predicates, weapon.WeaponCategoryHasPrefix(*i.WeaponCategoryHasPrefix))
	}
	if i.WeaponCategoryHasSuffix != nil {
		predicates = append(predicates, weapon.WeaponCategoryHasSuffix(*i.WeaponCategoryHasSuffix))
	}
	if i.WeaponCategoryEqualFold != nil {
		predicates = append(predicates, weapon.WeaponCategoryEqualFold(*i.WeaponCategoryEqualFold))
	}
	if i.WeaponCategoryContainsFold != nil {
		predicates = append(predicates, weapon.WeaponCategoryContainsFold(*i.WeaponCategoryContainsFold))
	}
	if i.WeaponRange != nil {
		predicates = append(predicates, weapon.WeaponRangeEQ(*i.WeaponRange))
	}
	if i.WeaponRangeNEQ != nil {
		predicates = append(predicates, weapon.WeaponRangeNEQ(*i.WeaponRangeNEQ))
	}
	if len(i.WeaponRangeIn) > 0 {
		predicates = append(predicates, weapon.WeaponRangeIn(i.WeaponRangeIn...))
	}
	if len(i.WeaponRangeNotIn) > 0 {
		predicates = append(predicates, weapon.WeaponRangeNotIn(i.WeaponRangeNotIn...))
	}
	if i.WeaponRangeGT != nil {
		predicates = append(predicates, weapon.WeaponRangeGT(*i.WeaponRangeGT))
	}
	if i.WeaponRangeGTE != nil {
		predicates = append(predicates, weapon.WeaponRangeGTE(*i.WeaponRangeGTE))
	}
	if i.WeaponRangeLT != nil {
		predicates = append(predicates, weapon.WeaponRangeLT(*i.WeaponRangeLT))
	}
	if i.WeaponRangeLTE != nil {
		predicates = append(predicates, weapon.WeaponRangeLTE(*i.WeaponRangeLTE))
	}
	if i.WeaponRangeContains != nil {
		predicates = append(predicates, weapon.WeaponRangeContains(*i.WeaponRangeContains))
	}
	if i.WeaponRangeHasPrefix != nil {
		predicates = append(predicates, weapon.WeaponRangeHasPrefix(*i.WeaponRangeHasPrefix))
	}
	if i.WeaponRangeHasSuffix != nil {
		predicates = append(predicates, weapon.WeaponRangeHasSuffix(*i.WeaponRangeHasSuffix))
	}
	if i.WeaponRangeEqualFold != nil {
		predicates = append(predicates, weapon.WeaponRangeEqualFold(*i.WeaponRangeEqualFold))
	}
	if i.WeaponRangeContainsFold != nil {
		predicates = append(predicates, weapon.WeaponRangeContainsFold(*i.WeaponRangeContainsFold))
	}

	if i.HasEquipment != nil {
		p := weapon.HasEquipment()
		if !*i.HasEquipment {
			p = weapon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentWith))
		for _, w := range i.HasEquipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weapon.HasEquipmentWith(with...))
	}
	if i.HasWeaponDamage != nil {
		p := weapon.HasWeaponDamage()
		if !*i.HasWeaponDamage {
			p = weapon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWeaponDamageWith) > 0 {
		with := make([]predicate.WeaponDamage, 0, len(i.HasWeaponDamageWith))
		for _, w := range i.HasWeaponDamageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWeaponDamageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weapon.HasWeaponDamageWith(with...))
	}
	if i.HasWeaponProperties != nil {
		p := weapon.HasWeaponProperties()
		if !*i.HasWeaponProperties {
			p = weapon.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWeaponPropertiesWith) > 0 {
		with := make([]predicate.WeaponProperty, 0, len(i.HasWeaponPropertiesWith))
		for _, w := range i.HasWeaponPropertiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWeaponPropertiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weapon.HasWeaponPropertiesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWeaponWhereInput
	case 1:
		return predicates[0], nil
	default:
		return weapon.And(predicates...), nil
	}
}

// WeaponDamageWhereInput represents a where input for filtering WeaponDamage queries.
type WeaponDamageWhereInput struct {
	Predicates []predicate.WeaponDamage  `json:"-"`
	Not        *WeaponDamageWhereInput   `json:"not,omitempty"`
	Or         []*WeaponDamageWhereInput `json:"or,omitempty"`
	And        []*WeaponDamageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "weapon_id" field predicates.
	WeaponID      *int  `json:"weaponID,omitempty"`
	WeaponIDNEQ   *int  `json:"weaponIDNEQ,omitempty"`
	WeaponIDIn    []int `json:"weaponIDIn,omitempty"`
	WeaponIDNotIn []int `json:"weaponIDNotIn,omitempty"`

	// "damage_type_id" field predicates.
	DamageTypeID      *int  `json:"damageTypeID,omitempty"`
	DamageTypeIDNEQ   *int  `json:"damageTypeIDNEQ,omitempty"`
	DamageTypeIDIn    []int `json:"damageTypeIDIn,omitempty"`
	DamageTypeIDNotIn []int `json:"damageTypeIDNotIn,omitempty"`

	// "dice" field predicates.
	Dice             *string  `json:"dice,omitempty"`
	DiceNEQ          *string  `json:"diceNEQ,omitempty"`
	DiceIn           []string `json:"diceIn,omitempty"`
	DiceNotIn        []string `json:"diceNotIn,omitempty"`
	DiceGT           *string  `json:"diceGT,omitempty"`
	DiceGTE          *string  `json:"diceGTE,omitempty"`
	DiceLT           *string  `json:"diceLT,omitempty"`
	DiceLTE          *string  `json:"diceLTE,omitempty"`
	DiceContains     *string  `json:"diceContains,omitempty"`
	DiceHasPrefix    *string  `json:"diceHasPrefix,omitempty"`
	DiceHasSuffix    *string  `json:"diceHasSuffix,omitempty"`
	DiceEqualFold    *string  `json:"diceEqualFold,omitempty"`
	DiceContainsFold *string  `json:"diceContainsFold,omitempty"`

	// "weapon" edge predicates.
	HasWeapon     *bool               `json:"hasWeapon,omitempty"`
	HasWeaponWith []*WeaponWhereInput `json:"hasWeaponWith,omitempty"`

	// "damage_type" edge predicates.
	HasDamageType     *bool                   `json:"hasDamageType,omitempty"`
	HasDamageTypeWith []*DamageTypeWhereInput `json:"hasDamageTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WeaponDamageWhereInput) AddPredicates(predicates ...predicate.WeaponDamage) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WeaponDamageWhereInput filter on the WeaponDamageQuery builder.
func (i *WeaponDamageWhereInput) Filter(q *WeaponDamageQuery) (*WeaponDamageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWeaponDamageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWeaponDamageWhereInput is returned in case the WeaponDamageWhereInput is empty.
var ErrEmptyWeaponDamageWhereInput = errors.New("ent: empty predicate WeaponDamageWhereInput")

// P returns a predicate for filtering weapondamages.
// An error is returned if the input is empty or invalid.
func (i *WeaponDamageWhereInput) P() (predicate.WeaponDamage, error) {
	var predicates []predicate.WeaponDamage
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, weapondamage.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WeaponDamage, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, weapondamage.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WeaponDamage, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, weapondamage.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, weapondamage.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, weapondamage.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, weapondamage.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, weapondamage.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, weapondamage.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, weapondamage.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, weapondamage.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, weapondamage.IDLTE(*i.IDLTE))
	}
	if i.WeaponID != nil {
		predicates = append(predicates, weapondamage.WeaponIDEQ(*i.WeaponID))
	}
	if i.WeaponIDNEQ != nil {
		predicates = append(predicates, weapondamage.WeaponIDNEQ(*i.WeaponIDNEQ))
	}
	if len(i.WeaponIDIn) > 0 {
		predicates = append(predicates, weapondamage.WeaponIDIn(i.WeaponIDIn...))
	}
	if len(i.WeaponIDNotIn) > 0 {
		predicates = append(predicates, weapondamage.WeaponIDNotIn(i.WeaponIDNotIn...))
	}
	if i.DamageTypeID != nil {
		predicates = append(predicates, weapondamage.DamageTypeIDEQ(*i.DamageTypeID))
	}
	if i.DamageTypeIDNEQ != nil {
		predicates = append(predicates, weapondamage.DamageTypeIDNEQ(*i.DamageTypeIDNEQ))
	}
	if len(i.DamageTypeIDIn) > 0 {
		predicates = append(predicates, weapondamage.DamageTypeIDIn(i.DamageTypeIDIn...))
	}
	if len(i.DamageTypeIDNotIn) > 0 {
		predicates = append(predicates, weapondamage.DamageTypeIDNotIn(i.DamageTypeIDNotIn...))
	}
	if i.Dice != nil {
		predicates = append(predicates, weapondamage.DiceEQ(*i.Dice))
	}
	if i.DiceNEQ != nil {
		predicates = append(predicates, weapondamage.DiceNEQ(*i.DiceNEQ))
	}
	if len(i.DiceIn) > 0 {
		predicates = append(predicates, weapondamage.DiceIn(i.DiceIn...))
	}
	if len(i.DiceNotIn) > 0 {
		predicates = append(predicates, weapondamage.DiceNotIn(i.DiceNotIn...))
	}
	if i.DiceGT != nil {
		predicates = append(predicates, weapondamage.DiceGT(*i.DiceGT))
	}
	if i.DiceGTE != nil {
		predicates = append(predicates, weapondamage.DiceGTE(*i.DiceGTE))
	}
	if i.DiceLT != nil {
		predicates = append(predicates, weapondamage.DiceLT(*i.DiceLT))
	}
	if i.DiceLTE != nil {
		predicates = append(predicates, weapondamage.DiceLTE(*i.DiceLTE))
	}
	if i.DiceContains != nil {
		predicates = append(predicates, weapondamage.DiceContains(*i.DiceContains))
	}
	if i.DiceHasPrefix != nil {
		predicates = append(predicates, weapondamage.DiceHasPrefix(*i.DiceHasPrefix))
	}
	if i.DiceHasSuffix != nil {
		predicates = append(predicates, weapondamage.DiceHasSuffix(*i.DiceHasSuffix))
	}
	if i.DiceEqualFold != nil {
		predicates = append(predicates, weapondamage.DiceEqualFold(*i.DiceEqualFold))
	}
	if i.DiceContainsFold != nil {
		predicates = append(predicates, weapondamage.DiceContainsFold(*i.DiceContainsFold))
	}

	if i.HasWeapon != nil {
		p := weapondamage.HasWeapon()
		if !*i.HasWeapon {
			p = weapondamage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWeaponWith) > 0 {
		with := make([]predicate.Weapon, 0, len(i.HasWeaponWith))
		for _, w := range i.HasWeaponWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWeaponWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weapondamage.HasWeaponWith(with...))
	}
	if i.HasDamageType != nil {
		p := weapondamage.HasDamageType()
		if !*i.HasDamageType {
			p = weapondamage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDamageTypeWith) > 0 {
		with := make([]predicate.DamageType, 0, len(i.HasDamageTypeWith))
		for _, w := range i.HasDamageTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDamageTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weapondamage.HasDamageTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWeaponDamageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return weapondamage.And(predicates...), nil
	}
}

// WeaponPropertyWhereInput represents a where input for filtering WeaponProperty queries.
type WeaponPropertyWhereInput struct {
	Predicates []predicate.WeaponProperty  `json:"-"`
	Not        *WeaponPropertyWhereInput   `json:"not,omitempty"`
	Or         []*WeaponPropertyWhereInput `json:"or,omitempty"`
	And        []*WeaponPropertyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "indx" field predicates.
	Indx             *string  `json:"indx,omitempty"`
	IndxNEQ          *string  `json:"indxNEQ,omitempty"`
	IndxIn           []string `json:"indxIn,omitempty"`
	IndxNotIn        []string `json:"indxNotIn,omitempty"`
	IndxGT           *string  `json:"indxGT,omitempty"`
	IndxGTE          *string  `json:"indxGTE,omitempty"`
	IndxLT           *string  `json:"indxLT,omitempty"`
	IndxLTE          *string  `json:"indxLTE,omitempty"`
	IndxContains     *string  `json:"indxContains,omitempty"`
	IndxHasPrefix    *string  `json:"indxHasPrefix,omitempty"`
	IndxHasSuffix    *string  `json:"indxHasSuffix,omitempty"`
	IndxEqualFold    *string  `json:"indxEqualFold,omitempty"`
	IndxContainsFold *string  `json:"indxContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "weapons" edge predicates.
	HasWeapons     *bool               `json:"hasWeapons,omitempty"`
	HasWeaponsWith []*WeaponWhereInput `json:"hasWeaponsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WeaponPropertyWhereInput) AddPredicates(predicates ...predicate.WeaponProperty) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WeaponPropertyWhereInput filter on the WeaponPropertyQuery builder.
func (i *WeaponPropertyWhereInput) Filter(q *WeaponPropertyQuery) (*WeaponPropertyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWeaponPropertyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWeaponPropertyWhereInput is returned in case the WeaponPropertyWhereInput is empty.
var ErrEmptyWeaponPropertyWhereInput = errors.New("ent: empty predicate WeaponPropertyWhereInput")

// P returns a predicate for filtering weaponproperties.
// An error is returned if the input is empty or invalid.
func (i *WeaponPropertyWhereInput) P() (predicate.WeaponProperty, error) {
	var predicates []predicate.WeaponProperty
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, weaponproperty.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WeaponProperty, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, weaponproperty.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WeaponProperty, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, weaponproperty.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, weaponproperty.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, weaponproperty.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, weaponproperty.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, weaponproperty.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, weaponproperty.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, weaponproperty.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, weaponproperty.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, weaponproperty.IDLTE(*i.IDLTE))
	}
	if i.Indx != nil {
		predicates = append(predicates, weaponproperty.IndxEQ(*i.Indx))
	}
	if i.IndxNEQ != nil {
		predicates = append(predicates, weaponproperty.IndxNEQ(*i.IndxNEQ))
	}
	if len(i.IndxIn) > 0 {
		predicates = append(predicates, weaponproperty.IndxIn(i.IndxIn...))
	}
	if len(i.IndxNotIn) > 0 {
		predicates = append(predicates, weaponproperty.IndxNotIn(i.IndxNotIn...))
	}
	if i.IndxGT != nil {
		predicates = append(predicates, weaponproperty.IndxGT(*i.IndxGT))
	}
	if i.IndxGTE != nil {
		predicates = append(predicates, weaponproperty.IndxGTE(*i.IndxGTE))
	}
	if i.IndxLT != nil {
		predicates = append(predicates, weaponproperty.IndxLT(*i.IndxLT))
	}
	if i.IndxLTE != nil {
		predicates = append(predicates, weaponproperty.IndxLTE(*i.IndxLTE))
	}
	if i.IndxContains != nil {
		predicates = append(predicates, weaponproperty.IndxContains(*i.IndxContains))
	}
	if i.IndxHasPrefix != nil {
		predicates = append(predicates, weaponproperty.IndxHasPrefix(*i.IndxHasPrefix))
	}
	if i.IndxHasSuffix != nil {
		predicates = append(predicates, weaponproperty.IndxHasSuffix(*i.IndxHasSuffix))
	}
	if i.IndxEqualFold != nil {
		predicates = append(predicates, weaponproperty.IndxEqualFold(*i.IndxEqualFold))
	}
	if i.IndxContainsFold != nil {
		predicates = append(predicates, weaponproperty.IndxContainsFold(*i.IndxContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, weaponproperty.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, weaponproperty.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, weaponproperty.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, weaponproperty.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, weaponproperty.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, weaponproperty.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, weaponproperty.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, weaponproperty.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, weaponproperty.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, weaponproperty.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, weaponproperty.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, weaponproperty.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, weaponproperty.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasWeapons != nil {
		p := weaponproperty.HasWeapons()
		if !*i.HasWeapons {
			p = weaponproperty.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWeaponsWith) > 0 {
		with := make([]predicate.Weapon, 0, len(i.HasWeaponsWith))
		for _, w := range i.HasWeaponsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWeaponsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, weaponproperty.HasWeaponsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWeaponPropertyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return weaponproperty.And(predicates...), nil
	}
}
