// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package dndgen

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/ecshreve/dndgen/ent"
	"github.com/ecshreve/dndgen/ent/language"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AbilityBonus struct {
		AbilityScore func(childComplexity int) int
		Bonus        func(childComplexity int) int
		ID           func(childComplexity int) int
		Race         func(childComplexity int) int
	}

	AbilityScore struct {
		AbilityBonuses func(childComplexity int) int
		Desc           func(childComplexity int) int
		FullName       func(childComplexity int) int
		ID             func(childComplexity int) int
		Indx           func(childComplexity int) int
		Name           func(childComplexity int) int
		Proficiencies  func(childComplexity int) int
		Skills         func(childComplexity int) int
	}

	Alignment struct {
		Abbr func(childComplexity int) int
		Desc func(childComplexity int) int
		ID   func(childComplexity int) int
		Indx func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Ammunition struct {
		Equipment func(childComplexity int) int
		ID        func(childComplexity int) int
		Quantity  func(childComplexity int) int
	}

	Armor struct {
		ArmorClass          func(childComplexity int) int
		Equipment           func(childComplexity int) int
		ID                  func(childComplexity int) int
		MinStrength         func(childComplexity int) int
		StealthDisadvantage func(childComplexity int) int
	}

	Class struct {
		Desc                  func(childComplexity int) int
		HitDie                func(childComplexity int) int
		ID                    func(childComplexity int) int
		Indx                  func(childComplexity int) int
		Name                  func(childComplexity int) int
		SavingThrows          func(childComplexity int) int
		StartingEquipment     func(childComplexity int) int
		StartingProficiencies func(childComplexity int) int
	}

	Condition struct {
		Desc func(childComplexity int) int
		ID   func(childComplexity int) int
		Indx func(childComplexity int) int
		Name func(childComplexity int) int
	}

	DamageType struct {
		Desc         func(childComplexity int) int
		ID           func(childComplexity int) int
		Indx         func(childComplexity int) int
		Name         func(childComplexity int) int
		WeaponDamage func(childComplexity int) int
	}

	Equipment struct {
		Ammunition    func(childComplexity int) int
		Armor         func(childComplexity int) int
		Category      func(childComplexity int) int
		Cost          func(childComplexity int) int
		Desc          func(childComplexity int) int
		Gear          func(childComplexity int) int
		ID            func(childComplexity int) int
		Indx          func(childComplexity int) int
		MagicItem     func(childComplexity int) int
		Name          func(childComplexity int) int
		Pack          func(childComplexity int) int
		Proficiencies func(childComplexity int) int
		Subcategory   func(childComplexity int) int
		Vehicle       func(childComplexity int) int
		Weapon        func(childComplexity int) int
		Weight        func(childComplexity int) int
	}

	EquipmentCategory struct {
		Desc      func(childComplexity int) int
		Equipment func(childComplexity int) int
		ID        func(childComplexity int) int
		Indx      func(childComplexity int) int
		Name      func(childComplexity int) int
	}

	Gear struct {
		Equipment func(childComplexity int) int
		ID        func(childComplexity int) int
	}

	Language struct {
		Category func(childComplexity int) int
		Desc     func(childComplexity int) int
		ID       func(childComplexity int) int
		Indx     func(childComplexity int) int
		Name     func(childComplexity int) int
		Script   func(childComplexity int) int
		Speakers func(childComplexity int) int
	}

	MagicItem struct {
		Equipment func(childComplexity int) int
		ID        func(childComplexity int) int
		Rarity    func(childComplexity int) int
	}

	MagicSchool struct {
		Desc func(childComplexity int) int
		ID   func(childComplexity int) int
		Indx func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Pack struct {
		Contents  func(childComplexity int) int
		Equipment func(childComplexity int) int
		ID        func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Prerequisite struct {
		AbilityScore func(childComplexity int) int
		ID           func(childComplexity int) int
		Minimum      func(childComplexity int) int
	}

	Proficiency struct {
		AbilityScore func(childComplexity int) int
		Classes      func(childComplexity int) int
		Desc         func(childComplexity int) int
		Equipment    func(childComplexity int) int
		ID           func(childComplexity int) int
		Indx         func(childComplexity int) int
		Name         func(childComplexity int) int
		Races        func(childComplexity int) int
		Skill        func(childComplexity int) int
		Tier         func(childComplexity int) int
	}

	Query struct {
		AbilityScores func(childComplexity int) int
		Node          func(childComplexity int, id int) int
		Nodes         func(childComplexity int, ids []int) int
		Skills        func(childComplexity int) int
	}

	Race struct {
		AbilityBonuses        func(childComplexity int) int
		Desc                  func(childComplexity int) int
		ID                    func(childComplexity int) int
		Indx                  func(childComplexity int) int
		Languages             func(childComplexity int) int
		Name                  func(childComplexity int) int
		Speed                 func(childComplexity int) int
		StartingProficiencies func(childComplexity int) int
	}

	Skill struct {
		AbilityScore  func(childComplexity int) int
		Desc          func(childComplexity int) int
		ID            func(childComplexity int) int
		Indx          func(childComplexity int) int
		Name          func(childComplexity int) int
		Proficiencies func(childComplexity int) int
	}

	Vehicle struct {
		Capacity  func(childComplexity int) int
		Equipment func(childComplexity int) int
		ID        func(childComplexity int) int
		Speed     func(childComplexity int) int
	}

	Weapon struct {
		Damage          func(childComplexity int) int
		Equipment       func(childComplexity int) int
		ID              func(childComplexity int) int
		Properties      func(childComplexity int) int
		Range           func(childComplexity int) int
		TwoHandedDamage func(childComplexity int) int
	}

	WeaponDamage struct {
		DamageType func(childComplexity int) int
		Dice       func(childComplexity int) int
		ID         func(childComplexity int) int
		Weapon     func(childComplexity int) int
	}

	WeaponRange struct {
		Desc   func(childComplexity int) int
		ID     func(childComplexity int) int
		Long   func(childComplexity int) int
		Normal func(childComplexity int) int
		Weapon func(childComplexity int) int
	}
}

type QueryResolver interface {
	Node(ctx context.Context, id int) (ent.Noder, error)
	Nodes(ctx context.Context, ids []int) ([]ent.Noder, error)
	AbilityScores(ctx context.Context) ([]*ent.AbilityScore, error)
	Skills(ctx context.Context) ([]*ent.Skill, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AbilityBonus.abilityScore":
		if e.complexity.AbilityBonus.AbilityScore == nil {
			break
		}

		return e.complexity.AbilityBonus.AbilityScore(childComplexity), true

	case "AbilityBonus.bonus":
		if e.complexity.AbilityBonus.Bonus == nil {
			break
		}

		return e.complexity.AbilityBonus.Bonus(childComplexity), true

	case "AbilityBonus.id":
		if e.complexity.AbilityBonus.ID == nil {
			break
		}

		return e.complexity.AbilityBonus.ID(childComplexity), true

	case "AbilityBonus.race":
		if e.complexity.AbilityBonus.Race == nil {
			break
		}

		return e.complexity.AbilityBonus.Race(childComplexity), true

	case "AbilityScore.abilityBonuses":
		if e.complexity.AbilityScore.AbilityBonuses == nil {
			break
		}

		return e.complexity.AbilityScore.AbilityBonuses(childComplexity), true

	case "AbilityScore.desc":
		if e.complexity.AbilityScore.Desc == nil {
			break
		}

		return e.complexity.AbilityScore.Desc(childComplexity), true

	case "AbilityScore.fullName":
		if e.complexity.AbilityScore.FullName == nil {
			break
		}

		return e.complexity.AbilityScore.FullName(childComplexity), true

	case "AbilityScore.id":
		if e.complexity.AbilityScore.ID == nil {
			break
		}

		return e.complexity.AbilityScore.ID(childComplexity), true

	case "AbilityScore.indx":
		if e.complexity.AbilityScore.Indx == nil {
			break
		}

		return e.complexity.AbilityScore.Indx(childComplexity), true

	case "AbilityScore.name":
		if e.complexity.AbilityScore.Name == nil {
			break
		}

		return e.complexity.AbilityScore.Name(childComplexity), true

	case "AbilityScore.proficiencies":
		if e.complexity.AbilityScore.Proficiencies == nil {
			break
		}

		return e.complexity.AbilityScore.Proficiencies(childComplexity), true

	case "AbilityScore.skills":
		if e.complexity.AbilityScore.Skills == nil {
			break
		}

		return e.complexity.AbilityScore.Skills(childComplexity), true

	case "Alignment.abbr":
		if e.complexity.Alignment.Abbr == nil {
			break
		}

		return e.complexity.Alignment.Abbr(childComplexity), true

	case "Alignment.desc":
		if e.complexity.Alignment.Desc == nil {
			break
		}

		return e.complexity.Alignment.Desc(childComplexity), true

	case "Alignment.id":
		if e.complexity.Alignment.ID == nil {
			break
		}

		return e.complexity.Alignment.ID(childComplexity), true

	case "Alignment.indx":
		if e.complexity.Alignment.Indx == nil {
			break
		}

		return e.complexity.Alignment.Indx(childComplexity), true

	case "Alignment.name":
		if e.complexity.Alignment.Name == nil {
			break
		}

		return e.complexity.Alignment.Name(childComplexity), true

	case "Ammunition.equipment":
		if e.complexity.Ammunition.Equipment == nil {
			break
		}

		return e.complexity.Ammunition.Equipment(childComplexity), true

	case "Ammunition.id":
		if e.complexity.Ammunition.ID == nil {
			break
		}

		return e.complexity.Ammunition.ID(childComplexity), true

	case "Ammunition.quantity":
		if e.complexity.Ammunition.Quantity == nil {
			break
		}

		return e.complexity.Ammunition.Quantity(childComplexity), true

	case "Armor.armorClass":
		if e.complexity.Armor.ArmorClass == nil {
			break
		}

		return e.complexity.Armor.ArmorClass(childComplexity), true

	case "Armor.equipment":
		if e.complexity.Armor.Equipment == nil {
			break
		}

		return e.complexity.Armor.Equipment(childComplexity), true

	case "Armor.id":
		if e.complexity.Armor.ID == nil {
			break
		}

		return e.complexity.Armor.ID(childComplexity), true

	case "Armor.minStrength":
		if e.complexity.Armor.MinStrength == nil {
			break
		}

		return e.complexity.Armor.MinStrength(childComplexity), true

	case "Armor.stealthDisadvantage":
		if e.complexity.Armor.StealthDisadvantage == nil {
			break
		}

		return e.complexity.Armor.StealthDisadvantage(childComplexity), true

	case "Class.desc":
		if e.complexity.Class.Desc == nil {
			break
		}

		return e.complexity.Class.Desc(childComplexity), true

	case "Class.hitDie":
		if e.complexity.Class.HitDie == nil {
			break
		}

		return e.complexity.Class.HitDie(childComplexity), true

	case "Class.id":
		if e.complexity.Class.ID == nil {
			break
		}

		return e.complexity.Class.ID(childComplexity), true

	case "Class.indx":
		if e.complexity.Class.Indx == nil {
			break
		}

		return e.complexity.Class.Indx(childComplexity), true

	case "Class.name":
		if e.complexity.Class.Name == nil {
			break
		}

		return e.complexity.Class.Name(childComplexity), true

	case "Class.savingThrows":
		if e.complexity.Class.SavingThrows == nil {
			break
		}

		return e.complexity.Class.SavingThrows(childComplexity), true

	case "Class.startingEquipment":
		if e.complexity.Class.StartingEquipment == nil {
			break
		}

		return e.complexity.Class.StartingEquipment(childComplexity), true

	case "Class.startingProficiencies":
		if e.complexity.Class.StartingProficiencies == nil {
			break
		}

		return e.complexity.Class.StartingProficiencies(childComplexity), true

	case "Condition.desc":
		if e.complexity.Condition.Desc == nil {
			break
		}

		return e.complexity.Condition.Desc(childComplexity), true

	case "Condition.id":
		if e.complexity.Condition.ID == nil {
			break
		}

		return e.complexity.Condition.ID(childComplexity), true

	case "Condition.indx":
		if e.complexity.Condition.Indx == nil {
			break
		}

		return e.complexity.Condition.Indx(childComplexity), true

	case "Condition.name":
		if e.complexity.Condition.Name == nil {
			break
		}

		return e.complexity.Condition.Name(childComplexity), true

	case "DamageType.desc":
		if e.complexity.DamageType.Desc == nil {
			break
		}

		return e.complexity.DamageType.Desc(childComplexity), true

	case "DamageType.id":
		if e.complexity.DamageType.ID == nil {
			break
		}

		return e.complexity.DamageType.ID(childComplexity), true

	case "DamageType.indx":
		if e.complexity.DamageType.Indx == nil {
			break
		}

		return e.complexity.DamageType.Indx(childComplexity), true

	case "DamageType.name":
		if e.complexity.DamageType.Name == nil {
			break
		}

		return e.complexity.DamageType.Name(childComplexity), true

	case "DamageType.weaponDamage":
		if e.complexity.DamageType.WeaponDamage == nil {
			break
		}

		return e.complexity.DamageType.WeaponDamage(childComplexity), true

	case "Equipment.ammunition":
		if e.complexity.Equipment.Ammunition == nil {
			break
		}

		return e.complexity.Equipment.Ammunition(childComplexity), true

	case "Equipment.armor":
		if e.complexity.Equipment.Armor == nil {
			break
		}

		return e.complexity.Equipment.Armor(childComplexity), true

	case "Equipment.category":
		if e.complexity.Equipment.Category == nil {
			break
		}

		return e.complexity.Equipment.Category(childComplexity), true

	case "Equipment.cost":
		if e.complexity.Equipment.Cost == nil {
			break
		}

		return e.complexity.Equipment.Cost(childComplexity), true

	case "Equipment.desc":
		if e.complexity.Equipment.Desc == nil {
			break
		}

		return e.complexity.Equipment.Desc(childComplexity), true

	case "Equipment.gear":
		if e.complexity.Equipment.Gear == nil {
			break
		}

		return e.complexity.Equipment.Gear(childComplexity), true

	case "Equipment.id":
		if e.complexity.Equipment.ID == nil {
			break
		}

		return e.complexity.Equipment.ID(childComplexity), true

	case "Equipment.indx":
		if e.complexity.Equipment.Indx == nil {
			break
		}

		return e.complexity.Equipment.Indx(childComplexity), true

	case "Equipment.magicItem":
		if e.complexity.Equipment.MagicItem == nil {
			break
		}

		return e.complexity.Equipment.MagicItem(childComplexity), true

	case "Equipment.name":
		if e.complexity.Equipment.Name == nil {
			break
		}

		return e.complexity.Equipment.Name(childComplexity), true

	case "Equipment.pack":
		if e.complexity.Equipment.Pack == nil {
			break
		}

		return e.complexity.Equipment.Pack(childComplexity), true

	case "Equipment.proficiencies":
		if e.complexity.Equipment.Proficiencies == nil {
			break
		}

		return e.complexity.Equipment.Proficiencies(childComplexity), true

	case "Equipment.subcategory":
		if e.complexity.Equipment.Subcategory == nil {
			break
		}

		return e.complexity.Equipment.Subcategory(childComplexity), true

	case "Equipment.vehicle":
		if e.complexity.Equipment.Vehicle == nil {
			break
		}

		return e.complexity.Equipment.Vehicle(childComplexity), true

	case "Equipment.weapon":
		if e.complexity.Equipment.Weapon == nil {
			break
		}

		return e.complexity.Equipment.Weapon(childComplexity), true

	case "Equipment.weight":
		if e.complexity.Equipment.Weight == nil {
			break
		}

		return e.complexity.Equipment.Weight(childComplexity), true

	case "EquipmentCategory.desc":
		if e.complexity.EquipmentCategory.Desc == nil {
			break
		}

		return e.complexity.EquipmentCategory.Desc(childComplexity), true

	case "EquipmentCategory.equipment":
		if e.complexity.EquipmentCategory.Equipment == nil {
			break
		}

		return e.complexity.EquipmentCategory.Equipment(childComplexity), true

	case "EquipmentCategory.id":
		if e.complexity.EquipmentCategory.ID == nil {
			break
		}

		return e.complexity.EquipmentCategory.ID(childComplexity), true

	case "EquipmentCategory.indx":
		if e.complexity.EquipmentCategory.Indx == nil {
			break
		}

		return e.complexity.EquipmentCategory.Indx(childComplexity), true

	case "EquipmentCategory.name":
		if e.complexity.EquipmentCategory.Name == nil {
			break
		}

		return e.complexity.EquipmentCategory.Name(childComplexity), true

	case "Gear.equipment":
		if e.complexity.Gear.Equipment == nil {
			break
		}

		return e.complexity.Gear.Equipment(childComplexity), true

	case "Gear.id":
		if e.complexity.Gear.ID == nil {
			break
		}

		return e.complexity.Gear.ID(childComplexity), true

	case "Language.category":
		if e.complexity.Language.Category == nil {
			break
		}

		return e.complexity.Language.Category(childComplexity), true

	case "Language.desc":
		if e.complexity.Language.Desc == nil {
			break
		}

		return e.complexity.Language.Desc(childComplexity), true

	case "Language.id":
		if e.complexity.Language.ID == nil {
			break
		}

		return e.complexity.Language.ID(childComplexity), true

	case "Language.indx":
		if e.complexity.Language.Indx == nil {
			break
		}

		return e.complexity.Language.Indx(childComplexity), true

	case "Language.name":
		if e.complexity.Language.Name == nil {
			break
		}

		return e.complexity.Language.Name(childComplexity), true

	case "Language.script":
		if e.complexity.Language.Script == nil {
			break
		}

		return e.complexity.Language.Script(childComplexity), true

	case "Language.speakers":
		if e.complexity.Language.Speakers == nil {
			break
		}

		return e.complexity.Language.Speakers(childComplexity), true

	case "MagicItem.equipment":
		if e.complexity.MagicItem.Equipment == nil {
			break
		}

		return e.complexity.MagicItem.Equipment(childComplexity), true

	case "MagicItem.id":
		if e.complexity.MagicItem.ID == nil {
			break
		}

		return e.complexity.MagicItem.ID(childComplexity), true

	case "MagicItem.rarity":
		if e.complexity.MagicItem.Rarity == nil {
			break
		}

		return e.complexity.MagicItem.Rarity(childComplexity), true

	case "MagicSchool.desc":
		if e.complexity.MagicSchool.Desc == nil {
			break
		}

		return e.complexity.MagicSchool.Desc(childComplexity), true

	case "MagicSchool.id":
		if e.complexity.MagicSchool.ID == nil {
			break
		}

		return e.complexity.MagicSchool.ID(childComplexity), true

	case "MagicSchool.indx":
		if e.complexity.MagicSchool.Indx == nil {
			break
		}

		return e.complexity.MagicSchool.Indx(childComplexity), true

	case "MagicSchool.name":
		if e.complexity.MagicSchool.Name == nil {
			break
		}

		return e.complexity.MagicSchool.Name(childComplexity), true

	case "Pack.contents":
		if e.complexity.Pack.Contents == nil {
			break
		}

		return e.complexity.Pack.Contents(childComplexity), true

	case "Pack.equipment":
		if e.complexity.Pack.Equipment == nil {
			break
		}

		return e.complexity.Pack.Equipment(childComplexity), true

	case "Pack.id":
		if e.complexity.Pack.ID == nil {
			break
		}

		return e.complexity.Pack.ID(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Prerequisite.abilityScore":
		if e.complexity.Prerequisite.AbilityScore == nil {
			break
		}

		return e.complexity.Prerequisite.AbilityScore(childComplexity), true

	case "Prerequisite.id":
		if e.complexity.Prerequisite.ID == nil {
			break
		}

		return e.complexity.Prerequisite.ID(childComplexity), true

	case "Prerequisite.minimum":
		if e.complexity.Prerequisite.Minimum == nil {
			break
		}

		return e.complexity.Prerequisite.Minimum(childComplexity), true

	case "Proficiency.abilityScore":
		if e.complexity.Proficiency.AbilityScore == nil {
			break
		}

		return e.complexity.Proficiency.AbilityScore(childComplexity), true

	case "Proficiency.classes":
		if e.complexity.Proficiency.Classes == nil {
			break
		}

		return e.complexity.Proficiency.Classes(childComplexity), true

	case "Proficiency.desc":
		if e.complexity.Proficiency.Desc == nil {
			break
		}

		return e.complexity.Proficiency.Desc(childComplexity), true

	case "Proficiency.equipment":
		if e.complexity.Proficiency.Equipment == nil {
			break
		}

		return e.complexity.Proficiency.Equipment(childComplexity), true

	case "Proficiency.id":
		if e.complexity.Proficiency.ID == nil {
			break
		}

		return e.complexity.Proficiency.ID(childComplexity), true

	case "Proficiency.indx":
		if e.complexity.Proficiency.Indx == nil {
			break
		}

		return e.complexity.Proficiency.Indx(childComplexity), true

	case "Proficiency.name":
		if e.complexity.Proficiency.Name == nil {
			break
		}

		return e.complexity.Proficiency.Name(childComplexity), true

	case "Proficiency.races":
		if e.complexity.Proficiency.Races == nil {
			break
		}

		return e.complexity.Proficiency.Races(childComplexity), true

	case "Proficiency.skill":
		if e.complexity.Proficiency.Skill == nil {
			break
		}

		return e.complexity.Proficiency.Skill(childComplexity), true

	case "Proficiency.tier":
		if e.complexity.Proficiency.Tier == nil {
			break
		}

		return e.complexity.Proficiency.Tier(childComplexity), true

	case "Query.abilityScores":
		if e.complexity.Query.AbilityScores == nil {
			break
		}

		return e.complexity.Query.AbilityScores(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.skills":
		if e.complexity.Query.Skills == nil {
			break
		}

		return e.complexity.Query.Skills(childComplexity), true

	case "Race.abilityBonuses":
		if e.complexity.Race.AbilityBonuses == nil {
			break
		}

		return e.complexity.Race.AbilityBonuses(childComplexity), true

	case "Race.desc":
		if e.complexity.Race.Desc == nil {
			break
		}

		return e.complexity.Race.Desc(childComplexity), true

	case "Race.id":
		if e.complexity.Race.ID == nil {
			break
		}

		return e.complexity.Race.ID(childComplexity), true

	case "Race.indx":
		if e.complexity.Race.Indx == nil {
			break
		}

		return e.complexity.Race.Indx(childComplexity), true

	case "Race.languages":
		if e.complexity.Race.Languages == nil {
			break
		}

		return e.complexity.Race.Languages(childComplexity), true

	case "Race.name":
		if e.complexity.Race.Name == nil {
			break
		}

		return e.complexity.Race.Name(childComplexity), true

	case "Race.speed":
		if e.complexity.Race.Speed == nil {
			break
		}

		return e.complexity.Race.Speed(childComplexity), true

	case "Race.startingProficiencies":
		if e.complexity.Race.StartingProficiencies == nil {
			break
		}

		return e.complexity.Race.StartingProficiencies(childComplexity), true

	case "Skill.abilityScore":
		if e.complexity.Skill.AbilityScore == nil {
			break
		}

		return e.complexity.Skill.AbilityScore(childComplexity), true

	case "Skill.desc":
		if e.complexity.Skill.Desc == nil {
			break
		}

		return e.complexity.Skill.Desc(childComplexity), true

	case "Skill.id":
		if e.complexity.Skill.ID == nil {
			break
		}

		return e.complexity.Skill.ID(childComplexity), true

	case "Skill.indx":
		if e.complexity.Skill.Indx == nil {
			break
		}

		return e.complexity.Skill.Indx(childComplexity), true

	case "Skill.name":
		if e.complexity.Skill.Name == nil {
			break
		}

		return e.complexity.Skill.Name(childComplexity), true

	case "Skill.proficiencies":
		if e.complexity.Skill.Proficiencies == nil {
			break
		}

		return e.complexity.Skill.Proficiencies(childComplexity), true

	case "Vehicle.capacity":
		if e.complexity.Vehicle.Capacity == nil {
			break
		}

		return e.complexity.Vehicle.Capacity(childComplexity), true

	case "Vehicle.equipment":
		if e.complexity.Vehicle.Equipment == nil {
			break
		}

		return e.complexity.Vehicle.Equipment(childComplexity), true

	case "Vehicle.id":
		if e.complexity.Vehicle.ID == nil {
			break
		}

		return e.complexity.Vehicle.ID(childComplexity), true

	case "Vehicle.speed":
		if e.complexity.Vehicle.Speed == nil {
			break
		}

		return e.complexity.Vehicle.Speed(childComplexity), true

	case "Weapon.damage":
		if e.complexity.Weapon.Damage == nil {
			break
		}

		return e.complexity.Weapon.Damage(childComplexity), true

	case "Weapon.equipment":
		if e.complexity.Weapon.Equipment == nil {
			break
		}

		return e.complexity.Weapon.Equipment(childComplexity), true

	case "Weapon.id":
		if e.complexity.Weapon.ID == nil {
			break
		}

		return e.complexity.Weapon.ID(childComplexity), true

	case "Weapon.properties":
		if e.complexity.Weapon.Properties == nil {
			break
		}

		return e.complexity.Weapon.Properties(childComplexity), true

	case "Weapon.range":
		if e.complexity.Weapon.Range == nil {
			break
		}

		return e.complexity.Weapon.Range(childComplexity), true

	case "Weapon.twoHandedDamage":
		if e.complexity.Weapon.TwoHandedDamage == nil {
			break
		}

		return e.complexity.Weapon.TwoHandedDamage(childComplexity), true

	case "WeaponDamage.damageType":
		if e.complexity.WeaponDamage.DamageType == nil {
			break
		}

		return e.complexity.WeaponDamage.DamageType(childComplexity), true

	case "WeaponDamage.dice":
		if e.complexity.WeaponDamage.Dice == nil {
			break
		}

		return e.complexity.WeaponDamage.Dice(childComplexity), true

	case "WeaponDamage.id":
		if e.complexity.WeaponDamage.ID == nil {
			break
		}

		return e.complexity.WeaponDamage.ID(childComplexity), true

	case "WeaponDamage.weapon":
		if e.complexity.WeaponDamage.Weapon == nil {
			break
		}

		return e.complexity.WeaponDamage.Weapon(childComplexity), true

	case "WeaponRange.desc":
		if e.complexity.WeaponRange.Desc == nil {
			break
		}

		return e.complexity.WeaponRange.Desc(childComplexity), true

	case "WeaponRange.id":
		if e.complexity.WeaponRange.ID == nil {
			break
		}

		return e.complexity.WeaponRange.ID(childComplexity), true

	case "WeaponRange.long":
		if e.complexity.WeaponRange.Long == nil {
			break
		}

		return e.complexity.WeaponRange.Long(childComplexity), true

	case "WeaponRange.normal":
		if e.complexity.WeaponRange.Normal == nil {
			break
		}

		return e.complexity.WeaponRange.Normal(childComplexity), true

	case "WeaponRange.weapon":
		if e.complexity.WeaponRange.Weapon == nil {
			break
		}

		return e.complexity.WeaponRange.Weapon(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAbilityBonusOrder,
		ec.unmarshalInputAbilityBonusWhereInput,
		ec.unmarshalInputAbilityScoreWhereInput,
		ec.unmarshalInputAlignmentWhereInput,
		ec.unmarshalInputAmmunitionWhereInput,
		ec.unmarshalInputArmorWhereInput,
		ec.unmarshalInputClassWhereInput,
		ec.unmarshalInputConditionWhereInput,
		ec.unmarshalInputDamageTypeWhereInput,
		ec.unmarshalInputEquipmentCategoryWhereInput,
		ec.unmarshalInputEquipmentWhereInput,
		ec.unmarshalInputGearWhereInput,
		ec.unmarshalInputLanguageWhereInput,
		ec.unmarshalInputMagicItemWhereInput,
		ec.unmarshalInputMagicSchoolWhereInput,
		ec.unmarshalInputPackWhereInput,
		ec.unmarshalInputPrerequisiteWhereInput,
		ec.unmarshalInputProficiencyWhereInput,
		ec.unmarshalInputRaceWhereInput,
		ec.unmarshalInputSkillWhereInput,
		ec.unmarshalInputVehicleWhereInput,
		ec.unmarshalInputWeaponDamageWhereInput,
		ec.unmarshalInputWeaponRangeWhereInput,
		ec.unmarshalInputWeaponWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "gqlserver/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type AbilityBonus implements Node {
  id: ID!
  bonus: Int!
  abilityScore: [AbilityScore!]
  race: [Race!]
}
"""Ordering options for AbilityBonus connections"""
input AbilityBonusOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order AbilityBonusSlice."""
  field: AbilityBonusOrderField!
}
"""Properties by which AbilityBonus connections can be ordered."""
enum AbilityBonusOrderField {
  BONUS
}
"""
AbilityBonusWhereInput is used for filtering AbilityBonus objects.
Input was generated by ent.
"""
input AbilityBonusWhereInput {
  not: AbilityBonusWhereInput
  and: [AbilityBonusWhereInput!]
  or: [AbilityBonusWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """bonus field predicates"""
  bonus: Int
  bonusNEQ: Int
  bonusIn: [Int!]
  bonusNotIn: [Int!]
  bonusGT: Int
  bonusGTE: Int
  bonusLT: Int
  bonusLTE: Int
  """ability_score edge predicates"""
  hasAbilityScore: Boolean
  hasAbilityScoreWith: [AbilityScoreWhereInput!]
  """race edge predicates"""
  hasRace: Boolean
  hasRaceWith: [RaceWhereInput!]
}
type AbilityScore implements Node {
  id: ID!
  indx: String!
  name: String!
  desc: [String!]
  fullName: String!
  abilityBonuses: [AbilityBonus!]
  skills: [Skill!]
  proficiencies: [Proficiency!]
}
"""
AbilityScoreWhereInput is used for filtering AbilityScore objects.
Input was generated by ent.
"""
input AbilityScoreWhereInput {
  not: AbilityScoreWhereInput
  and: [AbilityScoreWhereInput!]
  or: [AbilityScoreWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """indx field predicates"""
  indx: String
  indxNEQ: String
  indxIn: [String!]
  indxNotIn: [String!]
  indxGT: String
  indxGTE: String
  indxLT: String
  indxLTE: String
  indxContains: String
  indxHasPrefix: String
  indxHasSuffix: String
  indxEqualFold: String
  indxContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """full_name field predicates"""
  fullName: String
  fullNameNEQ: String
  fullNameIn: [String!]
  fullNameNotIn: [String!]
  fullNameGT: String
  fullNameGTE: String
  fullNameLT: String
  fullNameLTE: String
  fullNameContains: String
  fullNameHasPrefix: String
  fullNameHasSuffix: String
  fullNameEqualFold: String
  fullNameContainsFold: String
  """ability_bonuses edge predicates"""
  hasAbilityBonuses: Boolean
  hasAbilityBonusesWith: [AbilityBonusWhereInput!]
  """skills edge predicates"""
  hasSkills: Boolean
  hasSkillsWith: [SkillWhereInput!]
  """proficiencies edge predicates"""
  hasProficiencies: Boolean
  hasProficienciesWith: [ProficiencyWhereInput!]
}
type Alignment implements Node {
  id: ID!
  indx: String!
  name: String!
  desc: [String!]
  abbr: String!
}
"""
AlignmentWhereInput is used for filtering Alignment objects.
Input was generated by ent.
"""
input AlignmentWhereInput {
  not: AlignmentWhereInput
  and: [AlignmentWhereInput!]
  or: [AlignmentWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """indx field predicates"""
  indx: String
  indxNEQ: String
  indxIn: [String!]
  indxNotIn: [String!]
  indxGT: String
  indxGTE: String
  indxLT: String
  indxLTE: String
  indxContains: String
  indxHasPrefix: String
  indxHasSuffix: String
  indxEqualFold: String
  indxContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """abbr field predicates"""
  abbr: String
  abbrNEQ: String
  abbrIn: [String!]
  abbrNotIn: [String!]
  abbrGT: String
  abbrGTE: String
  abbrLT: String
  abbrLTE: String
  abbrContains: String
  abbrHasPrefix: String
  abbrHasSuffix: String
  abbrEqualFold: String
  abbrContainsFold: String
}
type Ammunition implements Node {
  id: ID!
  quantity: Int!
  equipment: [Equipment!]
}
"""
AmmunitionWhereInput is used for filtering Ammunition objects.
Input was generated by ent.
"""
input AmmunitionWhereInput {
  not: AmmunitionWhereInput
  and: [AmmunitionWhereInput!]
  or: [AmmunitionWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """quantity field predicates"""
  quantity: Int
  quantityNEQ: Int
  quantityIn: [Int!]
  quantityNotIn: [Int!]
  quantityGT: Int
  quantityGTE: Int
  quantityLT: Int
  quantityLTE: Int
  """equipment edge predicates"""
  hasEquipment: Boolean
  hasEquipmentWith: [EquipmentWhereInput!]
}
type Armor implements Node {
  id: ID!
  stealthDisadvantage: Boolean!
  armorClass: String!
  minStrength: Int!
  equipment: [Equipment!]
}
"""
ArmorWhereInput is used for filtering Armor objects.
Input was generated by ent.
"""
input ArmorWhereInput {
  not: ArmorWhereInput
  and: [ArmorWhereInput!]
  or: [ArmorWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """stealth_disadvantage field predicates"""
  stealthDisadvantage: Boolean
  stealthDisadvantageNEQ: Boolean
  """armor_class field predicates"""
  armorClass: String
  armorClassNEQ: String
  armorClassIn: [String!]
  armorClassNotIn: [String!]
  armorClassGT: String
  armorClassGTE: String
  armorClassLT: String
  armorClassLTE: String
  armorClassContains: String
  armorClassHasPrefix: String
  armorClassHasSuffix: String
  armorClassEqualFold: String
  armorClassContainsFold: String
  """min_strength field predicates"""
  minStrength: Int
  minStrengthNEQ: Int
  minStrengthIn: [Int!]
  minStrengthNotIn: [Int!]
  minStrengthGT: Int
  minStrengthGTE: Int
  minStrengthLT: Int
  minStrengthLTE: Int
  """equipment edge predicates"""
  hasEquipment: Boolean
  hasEquipmentWith: [EquipmentWhereInput!]
}
type Class implements Node {
  id: ID!
  indx: String!
  name: String!
  desc: [String!]
  hitDie: Int!
  savingThrows: [AbilityScore!]
  startingProficiencies: [Proficiency!]
  startingEquipment: [Equipment!]
}
"""
ClassWhereInput is used for filtering Class objects.
Input was generated by ent.
"""
input ClassWhereInput {
  not: ClassWhereInput
  and: [ClassWhereInput!]
  or: [ClassWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """indx field predicates"""
  indx: String
  indxNEQ: String
  indxIn: [String!]
  indxNotIn: [String!]
  indxGT: String
  indxGTE: String
  indxLT: String
  indxLTE: String
  indxContains: String
  indxHasPrefix: String
  indxHasSuffix: String
  indxEqualFold: String
  indxContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """hit_die field predicates"""
  hitDie: Int
  hitDieNEQ: Int
  hitDieIn: [Int!]
  hitDieNotIn: [Int!]
  hitDieGT: Int
  hitDieGTE: Int
  hitDieLT: Int
  hitDieLTE: Int
  """saving_throws edge predicates"""
  hasSavingThrows: Boolean
  hasSavingThrowsWith: [AbilityScoreWhereInput!]
  """starting_proficiencies edge predicates"""
  hasStartingProficiencies: Boolean
  hasStartingProficienciesWith: [ProficiencyWhereInput!]
  """starting_equipment edge predicates"""
  hasStartingEquipment: Boolean
  hasStartingEquipmentWith: [EquipmentWhereInput!]
}
type Condition implements Node {
  id: ID!
  indx: String!
  name: String!
  desc: [String!]
}
"""
ConditionWhereInput is used for filtering Condition objects.
Input was generated by ent.
"""
input ConditionWhereInput {
  not: ConditionWhereInput
  and: [ConditionWhereInput!]
  or: [ConditionWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """indx field predicates"""
  indx: String
  indxNEQ: String
  indxIn: [String!]
  indxNotIn: [String!]
  indxGT: String
  indxGTE: String
  indxLT: String
  indxLTE: String
  indxContains: String
  indxHasPrefix: String
  indxHasSuffix: String
  indxEqualFold: String
  indxContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type DamageType implements Node {
  id: ID!
  indx: String!
  name: String!
  desc: [String!]
  weaponDamage: WeaponDamage
}
"""
DamageTypeWhereInput is used for filtering DamageType objects.
Input was generated by ent.
"""
input DamageTypeWhereInput {
  not: DamageTypeWhereInput
  and: [DamageTypeWhereInput!]
  or: [DamageTypeWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """indx field predicates"""
  indx: String
  indxNEQ: String
  indxIn: [String!]
  indxNotIn: [String!]
  indxGT: String
  indxGTE: String
  indxLT: String
  indxLTE: String
  indxContains: String
  indxHasPrefix: String
  indxHasSuffix: String
  indxEqualFold: String
  indxContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """weapon_damage edge predicates"""
  hasWeaponDamage: Boolean
  hasWeaponDamageWith: [WeaponDamageWhereInput!]
}
type Equipment implements Node {
  id: ID!
  indx: String!
  name: String!
  desc: [String!]
  cost: String!
  weight: String!
  weapon: [Weapon!]
  armor: [Armor!]
  gear: [Gear!]
  pack: [Pack!]
  ammunition: [Ammunition!]
  vehicle: [Vehicle!]
  magicItem: [MagicItem!]
  category: [EquipmentCategory!]
  subcategory: [EquipmentCategory!]
  proficiencies: [Proficiency!]
}
type EquipmentCategory implements Node {
  id: ID!
  indx: String!
  name: String!
  desc: [String!]
  equipment: [Equipment!]
}
"""
EquipmentCategoryWhereInput is used for filtering EquipmentCategory objects.
Input was generated by ent.
"""
input EquipmentCategoryWhereInput {
  not: EquipmentCategoryWhereInput
  and: [EquipmentCategoryWhereInput!]
  or: [EquipmentCategoryWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """indx field predicates"""
  indx: String
  indxNEQ: String
  indxIn: [String!]
  indxNotIn: [String!]
  indxGT: String
  indxGTE: String
  indxLT: String
  indxLTE: String
  indxContains: String
  indxHasPrefix: String
  indxHasSuffix: String
  indxEqualFold: String
  indxContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """equipment edge predicates"""
  hasEquipment: Boolean
  hasEquipmentWith: [EquipmentWhereInput!]
}
"""
EquipmentWhereInput is used for filtering Equipment objects.
Input was generated by ent.
"""
input EquipmentWhereInput {
  not: EquipmentWhereInput
  and: [EquipmentWhereInput!]
  or: [EquipmentWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """indx field predicates"""
  indx: String
  indxNEQ: String
  indxIn: [String!]
  indxNotIn: [String!]
  indxGT: String
  indxGTE: String
  indxLT: String
  indxLTE: String
  indxContains: String
  indxHasPrefix: String
  indxHasSuffix: String
  indxEqualFold: String
  indxContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """cost field predicates"""
  cost: String
  costNEQ: String
  costIn: [String!]
  costNotIn: [String!]
  costGT: String
  costGTE: String
  costLT: String
  costLTE: String
  costContains: String
  costHasPrefix: String
  costHasSuffix: String
  costEqualFold: String
  costContainsFold: String
  """weight field predicates"""
  weight: String
  weightNEQ: String
  weightIn: [String!]
  weightNotIn: [String!]
  weightGT: String
  weightGTE: String
  weightLT: String
  weightLTE: String
  weightContains: String
  weightHasPrefix: String
  weightHasSuffix: String
  weightEqualFold: String
  weightContainsFold: String
  """weapon edge predicates"""
  hasWeapon: Boolean
  hasWeaponWith: [WeaponWhereInput!]
  """armor edge predicates"""
  hasArmor: Boolean
  hasArmorWith: [ArmorWhereInput!]
  """gear edge predicates"""
  hasGear: Boolean
  hasGearWith: [GearWhereInput!]
  """pack edge predicates"""
  hasPack: Boolean
  hasPackWith: [PackWhereInput!]
  """ammunition edge predicates"""
  hasAmmunition: Boolean
  hasAmmunitionWith: [AmmunitionWhereInput!]
  """vehicle edge predicates"""
  hasVehicle: Boolean
  hasVehicleWith: [VehicleWhereInput!]
  """magic_item edge predicates"""
  hasMagicItem: Boolean
  hasMagicItemWith: [MagicItemWhereInput!]
  """category edge predicates"""
  hasCategory: Boolean
  hasCategoryWith: [EquipmentCategoryWhereInput!]
  """subcategory edge predicates"""
  hasSubcategory: Boolean
  hasSubcategoryWith: [EquipmentCategoryWhereInput!]
  """proficiencies edge predicates"""
  hasProficiencies: Boolean
  hasProficienciesWith: [ProficiencyWhereInput!]
}
type Gear implements Node {
  id: ID!
  equipment: [Equipment!]
}
"""
GearWhereInput is used for filtering Gear objects.
Input was generated by ent.
"""
input GearWhereInput {
  not: GearWhereInput
  and: [GearWhereInput!]
  or: [GearWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """equipment edge predicates"""
  hasEquipment: Boolean
  hasEquipmentWith: [EquipmentWhereInput!]
}
type Language implements Node {
  id: ID!
  indx: String!
  name: String!
  desc: [String!]
  category: LanguageCategory!
  script: LanguageScript
  speakers: [Race!]
}
"""LanguageCategory is enum for the field category"""
enum LanguageCategory @goModel(model: "github.com/ecshreve/dndgen/ent/language.Category") {
  standard
  exotic
}
"""LanguageScript is enum for the field script"""
enum LanguageScript @goModel(model: "github.com/ecshreve/dndgen/ent/language.Script") {
  elvish
  celestial
  infernal
  dwarvish
  draconic
  common
}
"""
LanguageWhereInput is used for filtering Language objects.
Input was generated by ent.
"""
input LanguageWhereInput {
  not: LanguageWhereInput
  and: [LanguageWhereInput!]
  or: [LanguageWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """indx field predicates"""
  indx: String
  indxNEQ: String
  indxIn: [String!]
  indxNotIn: [String!]
  indxGT: String
  indxGTE: String
  indxLT: String
  indxLTE: String
  indxContains: String
  indxHasPrefix: String
  indxHasSuffix: String
  indxEqualFold: String
  indxContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """category field predicates"""
  category: LanguageCategory
  categoryNEQ: LanguageCategory
  categoryIn: [LanguageCategory!]
  categoryNotIn: [LanguageCategory!]
  """script field predicates"""
  script: LanguageScript
  scriptNEQ: LanguageScript
  scriptIn: [LanguageScript!]
  scriptNotIn: [LanguageScript!]
  scriptIsNil: Boolean
  scriptNotNil: Boolean
  """speakers edge predicates"""
  hasSpeakers: Boolean
  hasSpeakersWith: [RaceWhereInput!]
}
type MagicItem implements Node {
  id: ID!
  rarity: String!
  equipment: [Equipment!]
}
"""
MagicItemWhereInput is used for filtering MagicItem objects.
Input was generated by ent.
"""
input MagicItemWhereInput {
  not: MagicItemWhereInput
  and: [MagicItemWhereInput!]
  or: [MagicItemWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """rarity field predicates"""
  rarity: String
  rarityNEQ: String
  rarityIn: [String!]
  rarityNotIn: [String!]
  rarityGT: String
  rarityGTE: String
  rarityLT: String
  rarityLTE: String
  rarityContains: String
  rarityHasPrefix: String
  rarityHasSuffix: String
  rarityEqualFold: String
  rarityContainsFold: String
  """equipment edge predicates"""
  hasEquipment: Boolean
  hasEquipmentWith: [EquipmentWhereInput!]
}
type MagicSchool implements Node {
  id: ID!
  indx: String!
  name: String!
  desc: [String!]
}
"""
MagicSchoolWhereInput is used for filtering MagicSchool objects.
Input was generated by ent.
"""
input MagicSchoolWhereInput {
  not: MagicSchoolWhereInput
  and: [MagicSchoolWhereInput!]
  or: [MagicSchoolWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """indx field predicates"""
  indx: String
  indxNEQ: String
  indxIn: [String!]
  indxNotIn: [String!]
  indxGT: String
  indxGTE: String
  indxLT: String
  indxLTE: String
  indxContains: String
  indxHasPrefix: String
  indxHasSuffix: String
  indxEqualFold: String
  indxContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/ecshreve/dndgen/ent.Noder") {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
type Pack implements Node {
  id: ID!
  contents: String!
  equipment: [Equipment!]
}
"""
PackWhereInput is used for filtering Pack objects.
Input was generated by ent.
"""
input PackWhereInput {
  not: PackWhereInput
  and: [PackWhereInput!]
  or: [PackWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """contents field predicates"""
  contents: String
  contentsNEQ: String
  contentsIn: [String!]
  contentsNotIn: [String!]
  contentsGT: String
  contentsGTE: String
  contentsLT: String
  contentsLTE: String
  contentsContains: String
  contentsHasPrefix: String
  contentsHasSuffix: String
  contentsEqualFold: String
  contentsContainsFold: String
  """equipment edge predicates"""
  hasEquipment: Boolean
  hasEquipmentWith: [EquipmentWhereInput!]
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Prerequisite implements Node {
  id: ID!
  minimum: Int!
  abilityScore: [AbilityScore!]
}
"""
PrerequisiteWhereInput is used for filtering Prerequisite objects.
Input was generated by ent.
"""
input PrerequisiteWhereInput {
  not: PrerequisiteWhereInput
  and: [PrerequisiteWhereInput!]
  or: [PrerequisiteWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """minimum field predicates"""
  minimum: Int
  minimumNEQ: Int
  minimumIn: [Int!]
  minimumNotIn: [Int!]
  minimumGT: Int
  minimumGTE: Int
  minimumLT: Int
  minimumLTE: Int
  """ability_score edge predicates"""
  hasAbilityScore: Boolean
  hasAbilityScoreWith: [AbilityScoreWhereInput!]
}
type Proficiency implements Node {
  id: ID!
  indx: String!
  name: String!
  desc: [String!]
  tier: String!
  races: [Race!]
  classes: [Class!]
  skill: [Skill!]
  abilityScore: [AbilityScore!]
  equipment: [Equipment!]
}
"""
ProficiencyWhereInput is used for filtering Proficiency objects.
Input was generated by ent.
"""
input ProficiencyWhereInput {
  not: ProficiencyWhereInput
  and: [ProficiencyWhereInput!]
  or: [ProficiencyWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """indx field predicates"""
  indx: String
  indxNEQ: String
  indxIn: [String!]
  indxNotIn: [String!]
  indxGT: String
  indxGTE: String
  indxLT: String
  indxLTE: String
  indxContains: String
  indxHasPrefix: String
  indxHasSuffix: String
  indxEqualFold: String
  indxContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """tier field predicates"""
  tier: String
  tierNEQ: String
  tierIn: [String!]
  tierNotIn: [String!]
  tierGT: String
  tierGTE: String
  tierLT: String
  tierLTE: String
  tierContains: String
  tierHasPrefix: String
  tierHasSuffix: String
  tierEqualFold: String
  tierContainsFold: String
  """races edge predicates"""
  hasRaces: Boolean
  hasRacesWith: [RaceWhereInput!]
  """classes edge predicates"""
  hasClasses: Boolean
  hasClassesWith: [ClassWhereInput!]
  """skill edge predicates"""
  hasSkill: Boolean
  hasSkillWith: [SkillWhereInput!]
  """ability_score edge predicates"""
  hasAbilityScore: Boolean
  hasAbilityScoreWith: [AbilityScoreWhereInput!]
  """equipment edge predicates"""
  hasEquipment: Boolean
  hasEquipmentWith: [EquipmentWhereInput!]
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  abilityScores: [AbilityScore!]!
  skills: [Skill!]!
}
type Race implements Node {
  id: ID!
  indx: String!
  name: String!
  desc: [String!]
  speed: Int!
  languages: [Language!]
  abilityBonuses: [AbilityBonus!]
  startingProficiencies: [Proficiency!]
}
"""
RaceWhereInput is used for filtering Race objects.
Input was generated by ent.
"""
input RaceWhereInput {
  not: RaceWhereInput
  and: [RaceWhereInput!]
  or: [RaceWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """indx field predicates"""
  indx: String
  indxNEQ: String
  indxIn: [String!]
  indxNotIn: [String!]
  indxGT: String
  indxGTE: String
  indxLT: String
  indxLTE: String
  indxContains: String
  indxHasPrefix: String
  indxHasSuffix: String
  indxEqualFold: String
  indxContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """speed field predicates"""
  speed: Int
  speedNEQ: Int
  speedIn: [Int!]
  speedNotIn: [Int!]
  speedGT: Int
  speedGTE: Int
  speedLT: Int
  speedLTE: Int
  """languages edge predicates"""
  hasLanguages: Boolean
  hasLanguagesWith: [LanguageWhereInput!]
  """ability_bonuses edge predicates"""
  hasAbilityBonuses: Boolean
  hasAbilityBonusesWith: [AbilityBonusWhereInput!]
  """starting_proficiencies edge predicates"""
  hasStartingProficiencies: Boolean
  hasStartingProficienciesWith: [ProficiencyWhereInput!]
}
type Skill implements Node {
  id: ID!
  indx: String!
  name: String!
  desc: [String!]
  abilityScore: AbilityScore
  proficiencies: [Proficiency!]
}
"""
SkillWhereInput is used for filtering Skill objects.
Input was generated by ent.
"""
input SkillWhereInput {
  not: SkillWhereInput
  and: [SkillWhereInput!]
  or: [SkillWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """indx field predicates"""
  indx: String
  indxNEQ: String
  indxIn: [String!]
  indxNotIn: [String!]
  indxGT: String
  indxGTE: String
  indxLT: String
  indxLTE: String
  indxContains: String
  indxHasPrefix: String
  indxHasSuffix: String
  indxEqualFold: String
  indxContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """ability_score edge predicates"""
  hasAbilityScore: Boolean
  hasAbilityScoreWith: [AbilityScoreWhereInput!]
  """proficiencies edge predicates"""
  hasProficiencies: Boolean
  hasProficienciesWith: [ProficiencyWhereInput!]
}
type Vehicle implements Node {
  id: ID!
  speed: String!
  capacity: String!
  equipment: [Equipment!]
}
"""
VehicleWhereInput is used for filtering Vehicle objects.
Input was generated by ent.
"""
input VehicleWhereInput {
  not: VehicleWhereInput
  and: [VehicleWhereInput!]
  or: [VehicleWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """speed field predicates"""
  speed: String
  speedNEQ: String
  speedIn: [String!]
  speedNotIn: [String!]
  speedGT: String
  speedGTE: String
  speedLT: String
  speedLTE: String
  speedContains: String
  speedHasPrefix: String
  speedHasSuffix: String
  speedEqualFold: String
  speedContainsFold: String
  """capacity field predicates"""
  capacity: String
  capacityNEQ: String
  capacityIn: [String!]
  capacityNotIn: [String!]
  capacityGT: String
  capacityGTE: String
  capacityLT: String
  capacityLTE: String
  capacityContains: String
  capacityHasPrefix: String
  capacityHasSuffix: String
  capacityEqualFold: String
  capacityContainsFold: String
  """equipment edge predicates"""
  hasEquipment: Boolean
  hasEquipmentWith: [EquipmentWhereInput!]
}
type Weapon implements Node {
  id: ID!
  properties: String!
  range: [WeaponRange!]
  damage: [WeaponDamage!]
  twoHandedDamage: [WeaponDamage!]
  equipment: [Equipment!]
}
type WeaponDamage implements Node {
  id: ID!
  dice: String!
  damageType: [DamageType!]
  weapon: [Weapon!]
}
"""
WeaponDamageWhereInput is used for filtering WeaponDamage objects.
Input was generated by ent.
"""
input WeaponDamageWhereInput {
  not: WeaponDamageWhereInput
  and: [WeaponDamageWhereInput!]
  or: [WeaponDamageWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """dice field predicates"""
  dice: String
  diceNEQ: String
  diceIn: [String!]
  diceNotIn: [String!]
  diceGT: String
  diceGTE: String
  diceLT: String
  diceLTE: String
  diceContains: String
  diceHasPrefix: String
  diceHasSuffix: String
  diceEqualFold: String
  diceContainsFold: String
  """damage_type edge predicates"""
  hasDamageType: Boolean
  hasDamageTypeWith: [DamageTypeWhereInput!]
  """weapon edge predicates"""
  hasWeapon: Boolean
  hasWeaponWith: [WeaponWhereInput!]
}
type WeaponRange implements Node {
  id: ID!
  desc: String!
  normal: Int!
  long: Int!
  weapon: [Weapon!]
}
"""
WeaponRangeWhereInput is used for filtering WeaponRange objects.
Input was generated by ent.
"""
input WeaponRangeWhereInput {
  not: WeaponRangeWhereInput
  and: [WeaponRangeWhereInput!]
  or: [WeaponRangeWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """desc field predicates"""
  desc: String
  descNEQ: String
  descIn: [String!]
  descNotIn: [String!]
  descGT: String
  descGTE: String
  descLT: String
  descLTE: String
  descContains: String
  descHasPrefix: String
  descHasSuffix: String
  descEqualFold: String
  descContainsFold: String
  """normal field predicates"""
  normal: Int
  normalNEQ: Int
  normalIn: [Int!]
  normalNotIn: [Int!]
  normalGT: Int
  normalGTE: Int
  normalLT: Int
  normalLTE: Int
  """long field predicates"""
  long: Int
  longNEQ: Int
  longIn: [Int!]
  longNotIn: [Int!]
  longGT: Int
  longGTE: Int
  longLT: Int
  longLTE: Int
  """weapon edge predicates"""
  hasWeapon: Boolean
  hasWeaponWith: [WeaponWhereInput!]
}
"""
WeaponWhereInput is used for filtering Weapon objects.
Input was generated by ent.
"""
input WeaponWhereInput {
  not: WeaponWhereInput
  and: [WeaponWhereInput!]
  or: [WeaponWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """properties field predicates"""
  properties: String
  propertiesNEQ: String
  propertiesIn: [String!]
  propertiesNotIn: [String!]
  propertiesGT: String
  propertiesGTE: String
  propertiesLT: String
  propertiesLTE: String
  propertiesContains: String
  propertiesHasPrefix: String
  propertiesHasSuffix: String
  propertiesEqualFold: String
  propertiesContainsFold: String
  """range edge predicates"""
  hasRange: Boolean
  hasRangeWith: [WeaponRangeWhereInput!]
  """damage edge predicates"""
  hasDamage: Boolean
  hasDamageWith: [WeaponDamageWhereInput!]
  """two_handed_damage edge predicates"""
  hasTwoHandedDamage: Boolean
  hasTwoHandedDamageWith: [WeaponDamageWhereInput!]
  """equipment edge predicates"""
  hasEquipment: Boolean
  hasEquipmentWith: [EquipmentWhereInput!]
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2ᚕintᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AbilityBonus_id(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityBonus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityBonus_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityBonus_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityBonus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityBonus_bonus(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityBonus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityBonus_bonus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bonus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityBonus_bonus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityBonus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityBonus_abilityScore(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityBonus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityBonus_abilityScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbilityScore(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AbilityScore)
	fc.Result = res
	return ec.marshalOAbilityScore2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityBonus_abilityScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityBonus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityScore_id(ctx, field)
			case "indx":
				return ec.fieldContext_AbilityScore_indx(ctx, field)
			case "name":
				return ec.fieldContext_AbilityScore_name(ctx, field)
			case "desc":
				return ec.fieldContext_AbilityScore_desc(ctx, field)
			case "fullName":
				return ec.fieldContext_AbilityScore_fullName(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_AbilityScore_abilityBonuses(ctx, field)
			case "skills":
				return ec.fieldContext_AbilityScore_skills(ctx, field)
			case "proficiencies":
				return ec.fieldContext_AbilityScore_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityBonus_race(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityBonus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityBonus_race(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Race(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Race)
	fc.Result = res
	return ec.marshalORace2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityBonus_race(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityBonus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Race_id(ctx, field)
			case "indx":
				return ec.fieldContext_Race_indx(ctx, field)
			case "name":
				return ec.fieldContext_Race_name(ctx, field)
			case "desc":
				return ec.fieldContext_Race_desc(ctx, field)
			case "speed":
				return ec.fieldContext_Race_speed(ctx, field)
			case "languages":
				return ec.fieldContext_Race_languages(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_Race_abilityBonuses(ctx, field)
			case "startingProficiencies":
				return ec.fieldContext_Race_startingProficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Race", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_id(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_indx(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_indx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_name(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_desc(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_fullName(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_fullName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FullName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_fullName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_abilityBonuses(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_abilityBonuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbilityBonuses(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AbilityBonus)
	fc.Result = res
	return ec.marshalOAbilityBonus2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_abilityBonuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityBonus_id(ctx, field)
			case "bonus":
				return ec.fieldContext_AbilityBonus_bonus(ctx, field)
			case "abilityScore":
				return ec.fieldContext_AbilityBonus_abilityScore(ctx, field)
			case "race":
				return ec.fieldContext_AbilityBonus_race(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityBonus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_skills(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_skills(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Skills(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Skill)
	fc.Result = res
	return ec.marshalOSkill2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_skills(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Skill_id(ctx, field)
			case "indx":
				return ec.fieldContext_Skill_indx(ctx, field)
			case "name":
				return ec.fieldContext_Skill_name(ctx, field)
			case "desc":
				return ec.fieldContext_Skill_desc(ctx, field)
			case "abilityScore":
				return ec.fieldContext_Skill_abilityScore(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Skill_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Skill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_proficiencies(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_proficiencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proficiencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Proficiency)
	fc.Result = res
	return ec.marshalOProficiency2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_proficiencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Proficiency_id(ctx, field)
			case "indx":
				return ec.fieldContext_Proficiency_indx(ctx, field)
			case "name":
				return ec.fieldContext_Proficiency_name(ctx, field)
			case "desc":
				return ec.fieldContext_Proficiency_desc(ctx, field)
			case "tier":
				return ec.fieldContext_Proficiency_tier(ctx, field)
			case "races":
				return ec.fieldContext_Proficiency_races(ctx, field)
			case "classes":
				return ec.fieldContext_Proficiency_classes(ctx, field)
			case "skill":
				return ec.fieldContext_Proficiency_skill(ctx, field)
			case "abilityScore":
				return ec.fieldContext_Proficiency_abilityScore(ctx, field)
			case "equipment":
				return ec.fieldContext_Proficiency_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Proficiency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alignment_id(ctx context.Context, field graphql.CollectedField, obj *ent.Alignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alignment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alignment_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alignment_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Alignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alignment_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alignment_indx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alignment_name(ctx context.Context, field graphql.CollectedField, obj *ent.Alignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alignment_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alignment_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alignment_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Alignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alignment_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alignment_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alignment_abbr(ctx context.Context, field graphql.CollectedField, obj *ent.Alignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alignment_abbr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Abbr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alignment_abbr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ammunition_id(ctx context.Context, field graphql.CollectedField, obj *ent.Ammunition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ammunition_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ammunition_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ammunition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ammunition_quantity(ctx context.Context, field graphql.CollectedField, obj *ent.Ammunition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ammunition_quantity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quantity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ammunition_quantity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ammunition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ammunition_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Ammunition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ammunition_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Equipment)
	fc.Result = res
	return ec.marshalOEquipment2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ammunition_equipment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ammunition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "desc":
				return ec.fieldContext_Equipment_desc(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "pack":
				return ec.fieldContext_Equipment_pack(ctx, field)
			case "ammunition":
				return ec.fieldContext_Equipment_ammunition(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "magicItem":
				return ec.fieldContext_Equipment_magicItem(ctx, field)
			case "category":
				return ec.fieldContext_Equipment_category(ctx, field)
			case "subcategory":
				return ec.fieldContext_Equipment_subcategory(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Equipment_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_id(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_stealthDisadvantage(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_stealthDisadvantage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StealthDisadvantage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_stealthDisadvantage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_armorClass(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_armorClass(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArmorClass, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_armorClass(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_minStrength(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_minStrength(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinStrength, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_minStrength(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Equipment)
	fc.Result = res
	return ec.marshalOEquipment2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_equipment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "desc":
				return ec.fieldContext_Equipment_desc(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "pack":
				return ec.fieldContext_Equipment_pack(ctx, field)
			case "ammunition":
				return ec.fieldContext_Equipment_ammunition(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "magicItem":
				return ec.fieldContext_Equipment_magicItem(ctx, field)
			case "category":
				return ec.fieldContext_Equipment_category(ctx, field)
			case "subcategory":
				return ec.fieldContext_Equipment_subcategory(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Equipment_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_id(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_indx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_name(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_hitDie(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_hitDie(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HitDie, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_hitDie(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_savingThrows(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_savingThrows(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SavingThrows(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AbilityScore)
	fc.Result = res
	return ec.marshalOAbilityScore2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_savingThrows(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityScore_id(ctx, field)
			case "indx":
				return ec.fieldContext_AbilityScore_indx(ctx, field)
			case "name":
				return ec.fieldContext_AbilityScore_name(ctx, field)
			case "desc":
				return ec.fieldContext_AbilityScore_desc(ctx, field)
			case "fullName":
				return ec.fieldContext_AbilityScore_fullName(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_AbilityScore_abilityBonuses(ctx, field)
			case "skills":
				return ec.fieldContext_AbilityScore_skills(ctx, field)
			case "proficiencies":
				return ec.fieldContext_AbilityScore_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_startingProficiencies(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_startingProficiencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartingProficiencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Proficiency)
	fc.Result = res
	return ec.marshalOProficiency2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_startingProficiencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Proficiency_id(ctx, field)
			case "indx":
				return ec.fieldContext_Proficiency_indx(ctx, field)
			case "name":
				return ec.fieldContext_Proficiency_name(ctx, field)
			case "desc":
				return ec.fieldContext_Proficiency_desc(ctx, field)
			case "tier":
				return ec.fieldContext_Proficiency_tier(ctx, field)
			case "races":
				return ec.fieldContext_Proficiency_races(ctx, field)
			case "classes":
				return ec.fieldContext_Proficiency_classes(ctx, field)
			case "skill":
				return ec.fieldContext_Proficiency_skill(ctx, field)
			case "abilityScore":
				return ec.fieldContext_Proficiency_abilityScore(ctx, field)
			case "equipment":
				return ec.fieldContext_Proficiency_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Proficiency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_startingEquipment(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_startingEquipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartingEquipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Equipment)
	fc.Result = res
	return ec.marshalOEquipment2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_startingEquipment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "desc":
				return ec.fieldContext_Equipment_desc(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "pack":
				return ec.fieldContext_Equipment_pack(ctx, field)
			case "ammunition":
				return ec.fieldContext_Equipment_ammunition(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "magicItem":
				return ec.fieldContext_Equipment_magicItem(ctx, field)
			case "category":
				return ec.fieldContext_Equipment_category(ctx, field)
			case "subcategory":
				return ec.fieldContext_Equipment_subcategory(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Equipment_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_id(ctx context.Context, field graphql.CollectedField, obj *ent.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_indx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_name(ctx context.Context, field graphql.CollectedField, obj *ent.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DamageType_id(ctx context.Context, field graphql.CollectedField, obj *ent.DamageType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DamageType_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DamageType_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DamageType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DamageType_indx(ctx context.Context, field graphql.CollectedField, obj *ent.DamageType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DamageType_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DamageType_indx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DamageType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DamageType_name(ctx context.Context, field graphql.CollectedField, obj *ent.DamageType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DamageType_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DamageType_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DamageType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DamageType_desc(ctx context.Context, field graphql.CollectedField, obj *ent.DamageType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DamageType_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DamageType_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DamageType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DamageType_weaponDamage(ctx context.Context, field graphql.CollectedField, obj *ent.DamageType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DamageType_weaponDamage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WeaponDamage(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.WeaponDamage)
	fc.Result = res
	return ec.marshalOWeaponDamage2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DamageType_weaponDamage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DamageType",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WeaponDamage_id(ctx, field)
			case "dice":
				return ec.fieldContext_WeaponDamage_dice(ctx, field)
			case "damageType":
				return ec.fieldContext_WeaponDamage_damageType(ctx, field)
			case "weapon":
				return ec.fieldContext_WeaponDamage_weapon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WeaponDamage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_id(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_indx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_name(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_cost(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_cost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_weight(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_weight(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_weight(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_weapon(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_weapon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weapon(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Weapon)
	fc.Result = res
	return ec.marshalOWeapon2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_weapon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Weapon_id(ctx, field)
			case "properties":
				return ec.fieldContext_Weapon_properties(ctx, field)
			case "range":
				return ec.fieldContext_Weapon_range(ctx, field)
			case "damage":
				return ec.fieldContext_Weapon_damage(ctx, field)
			case "twoHandedDamage":
				return ec.fieldContext_Weapon_twoHandedDamage(ctx, field)
			case "equipment":
				return ec.fieldContext_Weapon_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Weapon", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_armor(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_armor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Armor(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Armor)
	fc.Result = res
	return ec.marshalOArmor2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐArmorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_armor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Armor_id(ctx, field)
			case "stealthDisadvantage":
				return ec.fieldContext_Armor_stealthDisadvantage(ctx, field)
			case "armorClass":
				return ec.fieldContext_Armor_armorClass(ctx, field)
			case "minStrength":
				return ec.fieldContext_Armor_minStrength(ctx, field)
			case "equipment":
				return ec.fieldContext_Armor_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Armor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_gear(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_gear(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gear(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Gear)
	fc.Result = res
	return ec.marshalOGear2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐGearᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_gear(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Gear_id(ctx, field)
			case "equipment":
				return ec.fieldContext_Gear_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Gear", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_pack(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_pack(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pack(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Pack)
	fc.Result = res
	return ec.marshalOPack2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPackᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_pack(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Pack_id(ctx, field)
			case "contents":
				return ec.fieldContext_Pack_contents(ctx, field)
			case "equipment":
				return ec.fieldContext_Pack_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pack", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_ammunition(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_ammunition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ammunition(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Ammunition)
	fc.Result = res
	return ec.marshalOAmmunition2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAmmunitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_ammunition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Ammunition_id(ctx, field)
			case "quantity":
				return ec.fieldContext_Ammunition_quantity(ctx, field)
			case "equipment":
				return ec.fieldContext_Ammunition_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Ammunition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_vehicle(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_vehicle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vehicle(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Vehicle)
	fc.Result = res
	return ec.marshalOVehicle2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐVehicleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_vehicle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Vehicle_id(ctx, field)
			case "speed":
				return ec.fieldContext_Vehicle_speed(ctx, field)
			case "capacity":
				return ec.fieldContext_Vehicle_capacity(ctx, field)
			case "equipment":
				return ec.fieldContext_Vehicle_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Vehicle", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_magicItem(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_magicItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MagicItem(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.MagicItem)
	fc.Result = res
	return ec.marshalOMagicItem2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_magicItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MagicItem_id(ctx, field)
			case "rarity":
				return ec.fieldContext_MagicItem_rarity(ctx, field)
			case "equipment":
				return ec.fieldContext_MagicItem_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MagicItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_category(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.EquipmentCategory)
	fc.Result = res
	return ec.marshalOEquipmentCategory2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategoryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EquipmentCategory_id(ctx, field)
			case "indx":
				return ec.fieldContext_EquipmentCategory_indx(ctx, field)
			case "name":
				return ec.fieldContext_EquipmentCategory_name(ctx, field)
			case "desc":
				return ec.fieldContext_EquipmentCategory_desc(ctx, field)
			case "equipment":
				return ec.fieldContext_EquipmentCategory_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EquipmentCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_subcategory(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_subcategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subcategory(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.EquipmentCategory)
	fc.Result = res
	return ec.marshalOEquipmentCategory2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategoryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_subcategory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EquipmentCategory_id(ctx, field)
			case "indx":
				return ec.fieldContext_EquipmentCategory_indx(ctx, field)
			case "name":
				return ec.fieldContext_EquipmentCategory_name(ctx, field)
			case "desc":
				return ec.fieldContext_EquipmentCategory_desc(ctx, field)
			case "equipment":
				return ec.fieldContext_EquipmentCategory_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EquipmentCategory", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_proficiencies(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_proficiencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proficiencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Proficiency)
	fc.Result = res
	return ec.marshalOProficiency2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_proficiencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Proficiency_id(ctx, field)
			case "indx":
				return ec.fieldContext_Proficiency_indx(ctx, field)
			case "name":
				return ec.fieldContext_Proficiency_name(ctx, field)
			case "desc":
				return ec.fieldContext_Proficiency_desc(ctx, field)
			case "tier":
				return ec.fieldContext_Proficiency_tier(ctx, field)
			case "races":
				return ec.fieldContext_Proficiency_races(ctx, field)
			case "classes":
				return ec.fieldContext_Proficiency_classes(ctx, field)
			case "skill":
				return ec.fieldContext_Proficiency_skill(ctx, field)
			case "abilityScore":
				return ec.fieldContext_Proficiency_abilityScore(ctx, field)
			case "equipment":
				return ec.fieldContext_Proficiency_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Proficiency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentCategory_id(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentCategory_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentCategory_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentCategory_indx(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentCategory_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentCategory_indx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentCategory_name(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentCategory_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentCategory_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentCategory_desc(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentCategory_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentCategory_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentCategory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentCategory_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentCategory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentCategory_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Equipment)
	fc.Result = res
	return ec.marshalOEquipment2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentCategory_equipment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentCategory",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "desc":
				return ec.fieldContext_Equipment_desc(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "pack":
				return ec.fieldContext_Equipment_pack(ctx, field)
			case "ammunition":
				return ec.fieldContext_Equipment_ammunition(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "magicItem":
				return ec.fieldContext_Equipment_magicItem(ctx, field)
			case "category":
				return ec.fieldContext_Equipment_category(ctx, field)
			case "subcategory":
				return ec.fieldContext_Equipment_subcategory(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Equipment_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Gear_id(ctx context.Context, field graphql.CollectedField, obj *ent.Gear) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Gear_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Gear_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Gear",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Gear_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Gear) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Gear_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Equipment)
	fc.Result = res
	return ec.marshalOEquipment2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Gear_equipment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Gear",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "desc":
				return ec.fieldContext_Equipment_desc(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "pack":
				return ec.fieldContext_Equipment_pack(ctx, field)
			case "ammunition":
				return ec.fieldContext_Equipment_ammunition(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "magicItem":
				return ec.fieldContext_Equipment_magicItem(ctx, field)
			case "category":
				return ec.fieldContext_Equipment_category(ctx, field)
			case "subcategory":
				return ec.fieldContext_Equipment_subcategory(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Equipment_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_id(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_indx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_name(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_category(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(language.Category)
	fc.Result = res
	return ec.marshalNLanguageCategory2githubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LanguageCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_script(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(language.Script)
	fc.Result = res
	return ec.marshalOLanguageScript2githubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScript(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_script(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LanguageScript does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_speakers(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_speakers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Speakers(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Race)
	fc.Result = res
	return ec.marshalORace2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_speakers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Race_id(ctx, field)
			case "indx":
				return ec.fieldContext_Race_indx(ctx, field)
			case "name":
				return ec.fieldContext_Race_name(ctx, field)
			case "desc":
				return ec.fieldContext_Race_desc(ctx, field)
			case "speed":
				return ec.fieldContext_Race_speed(ctx, field)
			case "languages":
				return ec.fieldContext_Race_languages(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_Race_abilityBonuses(ctx, field)
			case "startingProficiencies":
				return ec.fieldContext_Race_startingProficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Race", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MagicItem_id(ctx context.Context, field graphql.CollectedField, obj *ent.MagicItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MagicItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MagicItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MagicItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MagicItem_rarity(ctx context.Context, field graphql.CollectedField, obj *ent.MagicItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MagicItem_rarity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rarity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MagicItem_rarity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MagicItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MagicItem_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.MagicItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MagicItem_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Equipment)
	fc.Result = res
	return ec.marshalOEquipment2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MagicItem_equipment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MagicItem",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "desc":
				return ec.fieldContext_Equipment_desc(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "pack":
				return ec.fieldContext_Equipment_pack(ctx, field)
			case "ammunition":
				return ec.fieldContext_Equipment_ammunition(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "magicItem":
				return ec.fieldContext_Equipment_magicItem(ctx, field)
			case "category":
				return ec.fieldContext_Equipment_category(ctx, field)
			case "subcategory":
				return ec.fieldContext_Equipment_subcategory(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Equipment_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MagicSchool_id(ctx context.Context, field graphql.CollectedField, obj *ent.MagicSchool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MagicSchool_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MagicSchool_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MagicSchool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MagicSchool_indx(ctx context.Context, field graphql.CollectedField, obj *ent.MagicSchool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MagicSchool_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MagicSchool_indx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MagicSchool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MagicSchool_name(ctx context.Context, field graphql.CollectedField, obj *ent.MagicSchool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MagicSchool_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MagicSchool_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MagicSchool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MagicSchool_desc(ctx context.Context, field graphql.CollectedField, obj *ent.MagicSchool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MagicSchool_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MagicSchool_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MagicSchool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pack_id(ctx context.Context, field graphql.CollectedField, obj *ent.Pack) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pack_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pack_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pack",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pack_contents(ctx context.Context, field graphql.CollectedField, obj *ent.Pack) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pack_contents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Contents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pack_contents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pack",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pack_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Pack) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pack_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Equipment)
	fc.Result = res
	return ec.marshalOEquipment2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pack_equipment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pack",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "desc":
				return ec.fieldContext_Equipment_desc(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "pack":
				return ec.fieldContext_Equipment_pack(ctx, field)
			case "ammunition":
				return ec.fieldContext_Equipment_ammunition(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "magicItem":
				return ec.fieldContext_Equipment_magicItem(ctx, field)
			case "category":
				return ec.fieldContext_Equipment_category(ctx, field)
			case "subcategory":
				return ec.fieldContext_Equipment_subcategory(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Equipment_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[int])
	fc.Result = res
	return ec.marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[int])
	fc.Result = res
	return ec.marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Prerequisite_id(ctx context.Context, field graphql.CollectedField, obj *ent.Prerequisite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Prerequisite_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Prerequisite_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Prerequisite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Prerequisite_minimum(ctx context.Context, field graphql.CollectedField, obj *ent.Prerequisite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Prerequisite_minimum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Minimum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Prerequisite_minimum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Prerequisite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Prerequisite_abilityScore(ctx context.Context, field graphql.CollectedField, obj *ent.Prerequisite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Prerequisite_abilityScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbilityScore(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AbilityScore)
	fc.Result = res
	return ec.marshalOAbilityScore2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Prerequisite_abilityScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Prerequisite",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityScore_id(ctx, field)
			case "indx":
				return ec.fieldContext_AbilityScore_indx(ctx, field)
			case "name":
				return ec.fieldContext_AbilityScore_name(ctx, field)
			case "desc":
				return ec.fieldContext_AbilityScore_desc(ctx, field)
			case "fullName":
				return ec.fieldContext_AbilityScore_fullName(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_AbilityScore_abilityBonuses(ctx, field)
			case "skills":
				return ec.fieldContext_AbilityScore_skills(ctx, field)
			case "proficiencies":
				return ec.fieldContext_AbilityScore_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_id(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_indx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_name(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_tier(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_tier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_tier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_races(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_races(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Races(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Race)
	fc.Result = res
	return ec.marshalORace2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_races(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Race_id(ctx, field)
			case "indx":
				return ec.fieldContext_Race_indx(ctx, field)
			case "name":
				return ec.fieldContext_Race_name(ctx, field)
			case "desc":
				return ec.fieldContext_Race_desc(ctx, field)
			case "speed":
				return ec.fieldContext_Race_speed(ctx, field)
			case "languages":
				return ec.fieldContext_Race_languages(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_Race_abilityBonuses(ctx, field)
			case "startingProficiencies":
				return ec.fieldContext_Race_startingProficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Race", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_classes(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_classes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Classes(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Class)
	fc.Result = res
	return ec.marshalOClass2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐClassᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_classes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Class_id(ctx, field)
			case "indx":
				return ec.fieldContext_Class_indx(ctx, field)
			case "name":
				return ec.fieldContext_Class_name(ctx, field)
			case "desc":
				return ec.fieldContext_Class_desc(ctx, field)
			case "hitDie":
				return ec.fieldContext_Class_hitDie(ctx, field)
			case "savingThrows":
				return ec.fieldContext_Class_savingThrows(ctx, field)
			case "startingProficiencies":
				return ec.fieldContext_Class_startingProficiencies(ctx, field)
			case "startingEquipment":
				return ec.fieldContext_Class_startingEquipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Class", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_skill(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_skill(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Skill(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Skill)
	fc.Result = res
	return ec.marshalOSkill2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_skill(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Skill_id(ctx, field)
			case "indx":
				return ec.fieldContext_Skill_indx(ctx, field)
			case "name":
				return ec.fieldContext_Skill_name(ctx, field)
			case "desc":
				return ec.fieldContext_Skill_desc(ctx, field)
			case "abilityScore":
				return ec.fieldContext_Skill_abilityScore(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Skill_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Skill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_abilityScore(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_abilityScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbilityScore(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AbilityScore)
	fc.Result = res
	return ec.marshalOAbilityScore2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_abilityScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityScore_id(ctx, field)
			case "indx":
				return ec.fieldContext_AbilityScore_indx(ctx, field)
			case "name":
				return ec.fieldContext_AbilityScore_name(ctx, field)
			case "desc":
				return ec.fieldContext_AbilityScore_desc(ctx, field)
			case "fullName":
				return ec.fieldContext_AbilityScore_fullName(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_AbilityScore_abilityBonuses(ctx, field)
			case "skills":
				return ec.fieldContext_AbilityScore_skills(ctx, field)
			case "proficiencies":
				return ec.fieldContext_AbilityScore_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Equipment)
	fc.Result = res
	return ec.marshalOEquipment2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_equipment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "desc":
				return ec.fieldContext_Equipment_desc(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "pack":
				return ec.fieldContext_Equipment_pack(ctx, field)
			case "ammunition":
				return ec.fieldContext_Equipment_ammunition(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "magicItem":
				return ec.fieldContext_Equipment_magicItem(ctx, field)
			case "category":
				return ec.fieldContext_Equipment_category(ctx, field)
			case "subcategory":
				return ec.fieldContext_Equipment_subcategory(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Equipment_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ent.Noder)
	fc.Result = res
	return ec.marshalONode2githubᚗcomᚋecshreveᚋdndgenᚋentᚐNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Nodes(rctx, fc.Args["ids"].([]int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ent.Noder)
	fc.Result = res
	return ec.marshalNNode2ᚕgithubᚗcomᚋecshreveᚋdndgenᚋentᚐNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_abilityScores(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_abilityScores(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AbilityScores(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AbilityScore)
	fc.Result = res
	return ec.marshalNAbilityScore2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_abilityScores(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityScore_id(ctx, field)
			case "indx":
				return ec.fieldContext_AbilityScore_indx(ctx, field)
			case "name":
				return ec.fieldContext_AbilityScore_name(ctx, field)
			case "desc":
				return ec.fieldContext_AbilityScore_desc(ctx, field)
			case "fullName":
				return ec.fieldContext_AbilityScore_fullName(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_AbilityScore_abilityBonuses(ctx, field)
			case "skills":
				return ec.fieldContext_AbilityScore_skills(ctx, field)
			case "proficiencies":
				return ec.fieldContext_AbilityScore_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_skills(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_skills(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Skills(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Skill)
	fc.Result = res
	return ec.marshalNSkill2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_skills(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Skill_id(ctx, field)
			case "indx":
				return ec.fieldContext_Skill_indx(ctx, field)
			case "name":
				return ec.fieldContext_Skill_name(ctx, field)
			case "desc":
				return ec.fieldContext_Skill_desc(ctx, field)
			case "abilityScore":
				return ec.fieldContext_Skill_abilityScore(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Skill_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Skill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_id(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_indx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_name(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_speed(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_speed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Speed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_speed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_languages(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_languages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Languages(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Language)
	fc.Result = res
	return ec.marshalOLanguage2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐLanguageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_languages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Language_id(ctx, field)
			case "indx":
				return ec.fieldContext_Language_indx(ctx, field)
			case "name":
				return ec.fieldContext_Language_name(ctx, field)
			case "desc":
				return ec.fieldContext_Language_desc(ctx, field)
			case "category":
				return ec.fieldContext_Language_category(ctx, field)
			case "script":
				return ec.fieldContext_Language_script(ctx, field)
			case "speakers":
				return ec.fieldContext_Language_speakers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Language", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_abilityBonuses(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_abilityBonuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbilityBonuses(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AbilityBonus)
	fc.Result = res
	return ec.marshalOAbilityBonus2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_abilityBonuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityBonus_id(ctx, field)
			case "bonus":
				return ec.fieldContext_AbilityBonus_bonus(ctx, field)
			case "abilityScore":
				return ec.fieldContext_AbilityBonus_abilityScore(ctx, field)
			case "race":
				return ec.fieldContext_AbilityBonus_race(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityBonus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_startingProficiencies(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_startingProficiencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartingProficiencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Proficiency)
	fc.Result = res
	return ec.marshalOProficiency2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_startingProficiencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Proficiency_id(ctx, field)
			case "indx":
				return ec.fieldContext_Proficiency_indx(ctx, field)
			case "name":
				return ec.fieldContext_Proficiency_name(ctx, field)
			case "desc":
				return ec.fieldContext_Proficiency_desc(ctx, field)
			case "tier":
				return ec.fieldContext_Proficiency_tier(ctx, field)
			case "races":
				return ec.fieldContext_Proficiency_races(ctx, field)
			case "classes":
				return ec.fieldContext_Proficiency_classes(ctx, field)
			case "skill":
				return ec.fieldContext_Proficiency_skill(ctx, field)
			case "abilityScore":
				return ec.fieldContext_Proficiency_abilityScore(ctx, field)
			case "equipment":
				return ec.fieldContext_Proficiency_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Proficiency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_id(ctx context.Context, field graphql.CollectedField, obj *ent.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_indx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_name(ctx context.Context, field graphql.CollectedField, obj *ent.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_abilityScore(ctx context.Context, field graphql.CollectedField, obj *ent.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_abilityScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbilityScore(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AbilityScore)
	fc.Result = res
	return ec.marshalOAbilityScore2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScore(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_abilityScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityScore_id(ctx, field)
			case "indx":
				return ec.fieldContext_AbilityScore_indx(ctx, field)
			case "name":
				return ec.fieldContext_AbilityScore_name(ctx, field)
			case "desc":
				return ec.fieldContext_AbilityScore_desc(ctx, field)
			case "fullName":
				return ec.fieldContext_AbilityScore_fullName(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_AbilityScore_abilityBonuses(ctx, field)
			case "skills":
				return ec.fieldContext_AbilityScore_skills(ctx, field)
			case "proficiencies":
				return ec.fieldContext_AbilityScore_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_proficiencies(ctx context.Context, field graphql.CollectedField, obj *ent.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_proficiencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proficiencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Proficiency)
	fc.Result = res
	return ec.marshalOProficiency2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_proficiencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Proficiency_id(ctx, field)
			case "indx":
				return ec.fieldContext_Proficiency_indx(ctx, field)
			case "name":
				return ec.fieldContext_Proficiency_name(ctx, field)
			case "desc":
				return ec.fieldContext_Proficiency_desc(ctx, field)
			case "tier":
				return ec.fieldContext_Proficiency_tier(ctx, field)
			case "races":
				return ec.fieldContext_Proficiency_races(ctx, field)
			case "classes":
				return ec.fieldContext_Proficiency_classes(ctx, field)
			case "skill":
				return ec.fieldContext_Proficiency_skill(ctx, field)
			case "abilityScore":
				return ec.fieldContext_Proficiency_abilityScore(ctx, field)
			case "equipment":
				return ec.fieldContext_Proficiency_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Proficiency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vehicle_id(ctx context.Context, field graphql.CollectedField, obj *ent.Vehicle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vehicle_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vehicle_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vehicle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vehicle_speed(ctx context.Context, field graphql.CollectedField, obj *ent.Vehicle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vehicle_speed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Speed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vehicle_speed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vehicle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vehicle_capacity(ctx context.Context, field graphql.CollectedField, obj *ent.Vehicle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vehicle_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vehicle_capacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vehicle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vehicle_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Vehicle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vehicle_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Equipment)
	fc.Result = res
	return ec.marshalOEquipment2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vehicle_equipment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vehicle",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "desc":
				return ec.fieldContext_Equipment_desc(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "pack":
				return ec.fieldContext_Equipment_pack(ctx, field)
			case "ammunition":
				return ec.fieldContext_Equipment_ammunition(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "magicItem":
				return ec.fieldContext_Equipment_magicItem(ctx, field)
			case "category":
				return ec.fieldContext_Equipment_category(ctx, field)
			case "subcategory":
				return ec.fieldContext_Equipment_subcategory(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Equipment_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_id(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_properties(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_range(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_range(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Range(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.WeaponRange)
	fc.Result = res
	return ec.marshalOWeaponRange2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponRangeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_range(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WeaponRange_id(ctx, field)
			case "desc":
				return ec.fieldContext_WeaponRange_desc(ctx, field)
			case "normal":
				return ec.fieldContext_WeaponRange_normal(ctx, field)
			case "long":
				return ec.fieldContext_WeaponRange_long(ctx, field)
			case "weapon":
				return ec.fieldContext_WeaponRange_weapon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WeaponRange", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_damage(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_damage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Damage(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.WeaponDamage)
	fc.Result = res
	return ec.marshalOWeaponDamage2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_damage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WeaponDamage_id(ctx, field)
			case "dice":
				return ec.fieldContext_WeaponDamage_dice(ctx, field)
			case "damageType":
				return ec.fieldContext_WeaponDamage_damageType(ctx, field)
			case "weapon":
				return ec.fieldContext_WeaponDamage_weapon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WeaponDamage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_twoHandedDamage(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_twoHandedDamage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TwoHandedDamage(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.WeaponDamage)
	fc.Result = res
	return ec.marshalOWeaponDamage2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_twoHandedDamage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WeaponDamage_id(ctx, field)
			case "dice":
				return ec.fieldContext_WeaponDamage_dice(ctx, field)
			case "damageType":
				return ec.fieldContext_WeaponDamage_damageType(ctx, field)
			case "weapon":
				return ec.fieldContext_WeaponDamage_weapon(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WeaponDamage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Equipment)
	fc.Result = res
	return ec.marshalOEquipment2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_equipment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "desc":
				return ec.fieldContext_Equipment_desc(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "pack":
				return ec.fieldContext_Equipment_pack(ctx, field)
			case "ammunition":
				return ec.fieldContext_Equipment_ammunition(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "magicItem":
				return ec.fieldContext_Equipment_magicItem(ctx, field)
			case "category":
				return ec.fieldContext_Equipment_category(ctx, field)
			case "subcategory":
				return ec.fieldContext_Equipment_subcategory(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Equipment_proficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeaponDamage_id(ctx context.Context, field graphql.CollectedField, obj *ent.WeaponDamage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeaponDamage_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeaponDamage_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeaponDamage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeaponDamage_dice(ctx context.Context, field graphql.CollectedField, obj *ent.WeaponDamage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeaponDamage_dice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeaponDamage_dice(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeaponDamage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeaponDamage_damageType(ctx context.Context, field graphql.CollectedField, obj *ent.WeaponDamage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeaponDamage_damageType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DamageType(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.DamageType)
	fc.Result = res
	return ec.marshalODamageType2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐDamageTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeaponDamage_damageType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeaponDamage",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DamageType_id(ctx, field)
			case "indx":
				return ec.fieldContext_DamageType_indx(ctx, field)
			case "name":
				return ec.fieldContext_DamageType_name(ctx, field)
			case "desc":
				return ec.fieldContext_DamageType_desc(ctx, field)
			case "weaponDamage":
				return ec.fieldContext_DamageType_weaponDamage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DamageType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeaponDamage_weapon(ctx context.Context, field graphql.CollectedField, obj *ent.WeaponDamage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeaponDamage_weapon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weapon(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Weapon)
	fc.Result = res
	return ec.marshalOWeapon2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeaponDamage_weapon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeaponDamage",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Weapon_id(ctx, field)
			case "properties":
				return ec.fieldContext_Weapon_properties(ctx, field)
			case "range":
				return ec.fieldContext_Weapon_range(ctx, field)
			case "damage":
				return ec.fieldContext_Weapon_damage(ctx, field)
			case "twoHandedDamage":
				return ec.fieldContext_Weapon_twoHandedDamage(ctx, field)
			case "equipment":
				return ec.fieldContext_Weapon_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Weapon", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeaponRange_id(ctx context.Context, field graphql.CollectedField, obj *ent.WeaponRange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeaponRange_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeaponRange_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeaponRange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeaponRange_desc(ctx context.Context, field graphql.CollectedField, obj *ent.WeaponRange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeaponRange_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeaponRange_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeaponRange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeaponRange_normal(ctx context.Context, field graphql.CollectedField, obj *ent.WeaponRange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeaponRange_normal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Normal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeaponRange_normal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeaponRange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeaponRange_long(ctx context.Context, field graphql.CollectedField, obj *ent.WeaponRange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeaponRange_long(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Long, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeaponRange_long(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeaponRange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WeaponRange_weapon(ctx context.Context, field graphql.CollectedField, obj *ent.WeaponRange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WeaponRange_weapon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weapon(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Weapon)
	fc.Result = res
	return ec.marshalOWeapon2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WeaponRange_weapon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WeaponRange",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Weapon_id(ctx, field)
			case "properties":
				return ec.fieldContext_Weapon_properties(ctx, field)
			case "range":
				return ec.fieldContext_Weapon_range(ctx, field)
			case "damage":
				return ec.fieldContext_Weapon_damage(ctx, field)
			case "twoHandedDamage":
				return ec.fieldContext_Weapon_twoHandedDamage(ctx, field)
			case "equipment":
				return ec.fieldContext_Weapon_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Weapon", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAbilityBonusOrder(ctx context.Context, obj interface{}) (ent.AbilityBonusOrder, error) {
	var it ent.AbilityBonusOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	for k, v := range asMap {
		switch k {
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			it.Direction, err = ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalNAbilityBonusOrderField2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusOrderField(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAbilityBonusWhereInput(ctx context.Context, obj interface{}) (ent.AbilityBonusWhereInput, error) {
	var it ent.AbilityBonusWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOAbilityBonusWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOAbilityBonusWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOAbilityBonusWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "bonus":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bonus"))
			it.Bonus, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "bonusNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bonusNEQ"))
			it.BonusNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "bonusIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bonusIn"))
			it.BonusIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "bonusNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bonusNotIn"))
			it.BonusNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "bonusGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bonusGT"))
			it.BonusGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "bonusGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bonusGTE"))
			it.BonusGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "bonusLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bonusLT"))
			it.BonusLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "bonusLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bonusLTE"))
			it.BonusLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAbilityScore":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityScore"))
			it.HasAbilityScore, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAbilityScoreWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityScoreWith"))
			it.HasAbilityScoreWith, err = ec.unmarshalOAbilityScoreWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRace":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRace"))
			it.HasRace, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRaceWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRaceWith"))
			it.HasRaceWith, err = ec.unmarshalORaceWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAbilityScoreWhereInput(ctx context.Context, obj interface{}) (ent.AbilityScoreWhereInput, error) {
	var it ent.AbilityScoreWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOAbilityScoreWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOAbilityScoreWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOAbilityScoreWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "indx":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			it.Indx, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			it.IndxNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			it.IndxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			it.IndxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			it.IndxGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			it.IndxGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			it.IndxLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			it.IndxLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			it.IndxContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			it.IndxHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			it.IndxHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			it.IndxEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			it.IndxContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullName"))
			it.FullName, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameNEQ"))
			it.FullNameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameIn"))
			it.FullNameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameNotIn"))
			it.FullNameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameGT"))
			it.FullNameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameGTE"))
			it.FullNameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameLT"))
			it.FullNameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameLTE"))
			it.FullNameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameContains"))
			it.FullNameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameHasPrefix"))
			it.FullNameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameHasSuffix"))
			it.FullNameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameEqualFold"))
			it.FullNameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "fullNameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameContainsFold"))
			it.FullNameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAbilityBonuses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityBonuses"))
			it.HasAbilityBonuses, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAbilityBonusesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityBonusesWith"))
			it.HasAbilityBonusesWith, err = ec.unmarshalOAbilityBonusWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSkills":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSkills"))
			it.HasSkills, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSkillsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSkillsWith"))
			it.HasSkillsWith, err = ec.unmarshalOSkillWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProficiencies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficiencies"))
			it.HasProficiencies, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProficienciesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficienciesWith"))
			it.HasProficienciesWith, err = ec.unmarshalOProficiencyWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAlignmentWhereInput(ctx context.Context, obj interface{}) (ent.AlignmentWhereInput, error) {
	var it ent.AlignmentWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOAlignmentWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAlignmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOAlignmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAlignmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOAlignmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAlignmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "indx":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			it.Indx, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			it.IndxNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			it.IndxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			it.IndxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			it.IndxGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			it.IndxGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			it.IndxLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			it.IndxLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			it.IndxContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			it.IndxHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			it.IndxHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			it.IndxEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			it.IndxContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbr":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbr"))
			it.Abbr, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbrNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrNEQ"))
			it.AbbrNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbrIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrIn"))
			it.AbbrIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbrNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrNotIn"))
			it.AbbrNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbrGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrGT"))
			it.AbbrGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbrGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrGTE"))
			it.AbbrGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbrLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrLT"))
			it.AbbrLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbrLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrLTE"))
			it.AbbrLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbrContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrContains"))
			it.AbbrContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbrHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrHasPrefix"))
			it.AbbrHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbrHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrHasSuffix"))
			it.AbbrHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbrEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrEqualFold"))
			it.AbbrEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "abbrContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrContainsFold"))
			it.AbbrContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAmmunitionWhereInput(ctx context.Context, obj interface{}) (ent.AmmunitionWhereInput, error) {
	var it ent.AmmunitionWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOAmmunitionWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAmmunitionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOAmmunitionWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAmmunitionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOAmmunitionWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAmmunitionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "quantity":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantity"))
			it.Quantity, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "quantityNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityNEQ"))
			it.QuantityNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "quantityIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityIn"))
			it.QuantityIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "quantityNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityNotIn"))
			it.QuantityNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "quantityGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityGT"))
			it.QuantityGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "quantityGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityGTE"))
			it.QuantityGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "quantityLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityLT"))
			it.QuantityLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "quantityLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityLTE"))
			it.QuantityLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			it.HasEquipment, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipmentWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			it.HasEquipmentWith, err = ec.unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArmorWhereInput(ctx context.Context, obj interface{}) (ent.ArmorWhereInput, error) {
	var it ent.ArmorWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOArmorWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐArmorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOArmorWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐArmorWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOArmorWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐArmorWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "stealthDisadvantage":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stealthDisadvantage"))
			it.StealthDisadvantage, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "stealthDisadvantageNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stealthDisadvantageNEQ"))
			it.StealthDisadvantageNEQ, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClass":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClass"))
			it.ArmorClass, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClassNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClassNEQ"))
			it.ArmorClassNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClassIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClassIn"))
			it.ArmorClassIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClassNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClassNotIn"))
			it.ArmorClassNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClassGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClassGT"))
			it.ArmorClassGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClassGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClassGTE"))
			it.ArmorClassGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClassLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClassLT"))
			it.ArmorClassLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClassLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClassLTE"))
			it.ArmorClassLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClassContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClassContains"))
			it.ArmorClassContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClassHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClassHasPrefix"))
			it.ArmorClassHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClassHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClassHasSuffix"))
			it.ArmorClassHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClassEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClassEqualFold"))
			it.ArmorClassEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "armorClassContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorClassContainsFold"))
			it.ArmorClassContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "minStrength":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minStrength"))
			it.MinStrength, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minStrengthNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minStrengthNEQ"))
			it.MinStrengthNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minStrengthIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minStrengthIn"))
			it.MinStrengthIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "minStrengthNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minStrengthNotIn"))
			it.MinStrengthNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "minStrengthGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minStrengthGT"))
			it.MinStrengthGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minStrengthGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minStrengthGTE"))
			it.MinStrengthGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minStrengthLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minStrengthLT"))
			it.MinStrengthLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minStrengthLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minStrengthLTE"))
			it.MinStrengthLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			it.HasEquipment, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipmentWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			it.HasEquipmentWith, err = ec.unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputClassWhereInput(ctx context.Context, obj interface{}) (ent.ClassWhereInput, error) {
	var it ent.ClassWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOClassWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐClassWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOClassWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐClassWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOClassWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐClassWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "indx":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			it.Indx, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			it.IndxNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			it.IndxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			it.IndxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			it.IndxGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			it.IndxGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			it.IndxLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			it.IndxLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			it.IndxContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			it.IndxHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			it.IndxHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			it.IndxEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			it.IndxContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hitDie":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDie"))
			it.HitDie, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hitDieNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieNEQ"))
			it.HitDieNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hitDieIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieIn"))
			it.HitDieIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hitDieNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieNotIn"))
			it.HitDieNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hitDieGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieGT"))
			it.HitDieGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hitDieGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieGTE"))
			it.HitDieGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hitDieLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieLT"))
			it.HitDieLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hitDieLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieLTE"))
			it.HitDieLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSavingThrows":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSavingThrows"))
			it.HasSavingThrows, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSavingThrowsWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSavingThrowsWith"))
			it.HasSavingThrowsWith, err = ec.unmarshalOAbilityScoreWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasStartingProficiencies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStartingProficiencies"))
			it.HasStartingProficiencies, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasStartingProficienciesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStartingProficienciesWith"))
			it.HasStartingProficienciesWith, err = ec.unmarshalOProficiencyWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasStartingEquipment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStartingEquipment"))
			it.HasStartingEquipment, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasStartingEquipmentWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStartingEquipmentWith"))
			it.HasStartingEquipmentWith, err = ec.unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputConditionWhereInput(ctx context.Context, obj interface{}) (ent.ConditionWhereInput, error) {
	var it ent.ConditionWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOConditionWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐConditionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOConditionWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐConditionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOConditionWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐConditionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "indx":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			it.Indx, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			it.IndxNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			it.IndxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			it.IndxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			it.IndxGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			it.IndxGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			it.IndxLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			it.IndxLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			it.IndxContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			it.IndxHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			it.IndxHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			it.IndxEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			it.IndxContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDamageTypeWhereInput(ctx context.Context, obj interface{}) (ent.DamageTypeWhereInput, error) {
	var it ent.DamageTypeWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalODamageTypeWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐDamageTypeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalODamageTypeWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐDamageTypeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalODamageTypeWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐDamageTypeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "indx":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			it.Indx, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			it.IndxNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			it.IndxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			it.IndxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			it.IndxGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			it.IndxGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			it.IndxLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			it.IndxLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			it.IndxContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			it.IndxHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			it.IndxHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			it.IndxEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			it.IndxContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWeaponDamage":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeaponDamage"))
			it.HasWeaponDamage, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWeaponDamageWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeaponDamageWith"))
			it.HasWeaponDamageWith, err = ec.unmarshalOWeaponDamageWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEquipmentCategoryWhereInput(ctx context.Context, obj interface{}) (ent.EquipmentCategoryWhereInput, error) {
	var it ent.EquipmentCategoryWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOEquipmentCategoryWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategoryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOEquipmentCategoryWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategoryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOEquipmentCategoryWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategoryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "indx":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			it.Indx, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			it.IndxNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			it.IndxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			it.IndxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			it.IndxGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			it.IndxGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			it.IndxLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			it.IndxLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			it.IndxContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			it.IndxHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			it.IndxHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			it.IndxEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			it.IndxContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			it.HasEquipment, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipmentWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			it.HasEquipmentWith, err = ec.unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEquipmentWhereInput(ctx context.Context, obj interface{}) (ent.EquipmentWhereInput, error) {
	var it ent.EquipmentWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOEquipmentWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "indx":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			it.Indx, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			it.IndxNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			it.IndxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			it.IndxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			it.IndxGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			it.IndxGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			it.IndxLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			it.IndxLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			it.IndxContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			it.IndxHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			it.IndxHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			it.IndxEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			it.IndxContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "cost":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cost"))
			it.Cost, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "costNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costNEQ"))
			it.CostNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "costIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costIn"))
			it.CostIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "costNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costNotIn"))
			it.CostNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "costGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costGT"))
			it.CostGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "costGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costGTE"))
			it.CostGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "costLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costLT"))
			it.CostLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "costLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costLTE"))
			it.CostLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "costContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costContains"))
			it.CostContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "costHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costHasPrefix"))
			it.CostHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "costHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costHasSuffix"))
			it.CostHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "costEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costEqualFold"))
			it.CostEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "costContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("costContainsFold"))
			it.CostContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "weight":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			it.Weight, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightNEQ"))
			it.WeightNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightIn"))
			it.WeightIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightNotIn"))
			it.WeightNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightGT"))
			it.WeightGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightGTE"))
			it.WeightGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightLT"))
			it.WeightLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightLTE"))
			it.WeightLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightContains"))
			it.WeightContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightHasPrefix"))
			it.WeightHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightHasSuffix"))
			it.WeightHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightEqualFold"))
			it.WeightEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "weightContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightContainsFold"))
			it.WeightContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWeapon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeapon"))
			it.HasWeapon, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWeaponWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeaponWith"))
			it.HasWeaponWith, err = ec.unmarshalOWeaponWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasArmor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasArmor"))
			it.HasArmor, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasArmorWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasArmorWith"))
			it.HasArmorWith, err = ec.unmarshalOArmorWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐArmorWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasGear":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGear"))
			it.HasGear, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasGearWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGearWith"))
			it.HasGearWith, err = ec.unmarshalOGearWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐGearWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPack":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPack"))
			it.HasPack, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasPackWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPackWith"))
			it.HasPackWith, err = ec.unmarshalOPackWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPackWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAmmunition":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAmmunition"))
			it.HasAmmunition, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAmmunitionWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAmmunitionWith"))
			it.HasAmmunitionWith, err = ec.unmarshalOAmmunitionWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAmmunitionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasVehicle":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVehicle"))
			it.HasVehicle, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasVehicleWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVehicleWith"))
			it.HasVehicleWith, err = ec.unmarshalOVehicleWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐVehicleWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasMagicItem":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasMagicItem"))
			it.HasMagicItem, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasMagicItemWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasMagicItemWith"))
			it.HasMagicItemWith, err = ec.unmarshalOMagicItemWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasCategory":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCategory"))
			it.HasCategory, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasCategoryWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCategoryWith"))
			it.HasCategoryWith, err = ec.unmarshalOEquipmentCategoryWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategoryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSubcategory":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSubcategory"))
			it.HasSubcategory, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSubcategoryWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSubcategoryWith"))
			it.HasSubcategoryWith, err = ec.unmarshalOEquipmentCategoryWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategoryWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProficiencies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficiencies"))
			it.HasProficiencies, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProficienciesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficienciesWith"))
			it.HasProficienciesWith, err = ec.unmarshalOProficiencyWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGearWhereInput(ctx context.Context, obj interface{}) (ent.GearWhereInput, error) {
	var it ent.GearWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOGearWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐGearWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOGearWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐGearWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOGearWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐGearWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			it.HasEquipment, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipmentWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			it.HasEquipmentWith, err = ec.unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLanguageWhereInput(ctx context.Context, obj interface{}) (ent.LanguageWhereInput, error) {
	var it ent.LanguageWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOLanguageWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐLanguageWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOLanguageWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐLanguageWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOLanguageWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐLanguageWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "indx":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			it.Indx, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			it.IndxNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			it.IndxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			it.IndxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			it.IndxGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			it.IndxGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			it.IndxLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			it.IndxLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			it.IndxContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			it.IndxHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			it.IndxHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			it.IndxEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			it.IndxContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "category":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("category"))
			it.Category, err = ec.unmarshalOLanguageCategory2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategory(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryNEQ"))
			it.CategoryNEQ, err = ec.unmarshalOLanguageCategory2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategory(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryIn"))
			it.CategoryIn, err = ec.unmarshalOLanguageCategory2ᚕgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategoryᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "categoryNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("categoryNotIn"))
			it.CategoryNotIn, err = ec.unmarshalOLanguageCategory2ᚕgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategoryᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "script":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("script"))
			it.Script, err = ec.unmarshalOLanguageScript2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScript(ctx, v)
			if err != nil {
				return it, err
			}
		case "scriptNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scriptNEQ"))
			it.ScriptNEQ, err = ec.unmarshalOLanguageScript2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScript(ctx, v)
			if err != nil {
				return it, err
			}
		case "scriptIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scriptIn"))
			it.ScriptIn, err = ec.unmarshalOLanguageScript2ᚕgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScriptᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "scriptNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scriptNotIn"))
			it.ScriptNotIn, err = ec.unmarshalOLanguageScript2ᚕgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScriptᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "scriptIsNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scriptIsNil"))
			it.ScriptIsNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "scriptNotNil":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scriptNotNil"))
			it.ScriptNotNil, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSpeakers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSpeakers"))
			it.HasSpeakers, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSpeakersWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSpeakersWith"))
			it.HasSpeakersWith, err = ec.unmarshalORaceWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMagicItemWhereInput(ctx context.Context, obj interface{}) (ent.MagicItemWhereInput, error) {
	var it ent.MagicItemWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOMagicItemWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicItemWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOMagicItemWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOMagicItemWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarity":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			it.Rarity, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarityNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarityNEQ"))
			it.RarityNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarityIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarityIn"))
			it.RarityIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarityNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarityNotIn"))
			it.RarityNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarityGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarityGT"))
			it.RarityGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarityGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarityGTE"))
			it.RarityGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarityLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarityLT"))
			it.RarityLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarityLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarityLTE"))
			it.RarityLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarityContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarityContains"))
			it.RarityContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarityHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarityHasPrefix"))
			it.RarityHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarityHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarityHasSuffix"))
			it.RarityHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarityEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarityEqualFold"))
			it.RarityEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rarityContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarityContainsFold"))
			it.RarityContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			it.HasEquipment, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipmentWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			it.HasEquipmentWith, err = ec.unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMagicSchoolWhereInput(ctx context.Context, obj interface{}) (ent.MagicSchoolWhereInput, error) {
	var it ent.MagicSchoolWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOMagicSchoolWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicSchoolWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOMagicSchoolWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicSchoolWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOMagicSchoolWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicSchoolWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "indx":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			it.Indx, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			it.IndxNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			it.IndxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			it.IndxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			it.IndxGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			it.IndxGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			it.IndxLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			it.IndxLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			it.IndxContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			it.IndxHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			it.IndxHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			it.IndxEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			it.IndxContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackWhereInput(ctx context.Context, obj interface{}) (ent.PackWhereInput, error) {
	var it ent.PackWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOPackWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPackWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOPackWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPackWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOPackWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPackWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "contents":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contents"))
			it.Contents, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentsNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentsNEQ"))
			it.ContentsNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentsIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentsIn"))
			it.ContentsIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentsNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentsNotIn"))
			it.ContentsNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentsGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentsGT"))
			it.ContentsGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentsGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentsGTE"))
			it.ContentsGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentsLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentsLT"))
			it.ContentsLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentsLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentsLTE"))
			it.ContentsLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentsContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentsContains"))
			it.ContentsContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentsHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentsHasPrefix"))
			it.ContentsHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentsHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentsHasSuffix"))
			it.ContentsHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentsEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentsEqualFold"))
			it.ContentsEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "contentsContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contentsContainsFold"))
			it.ContentsContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			it.HasEquipment, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipmentWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			it.HasEquipmentWith, err = ec.unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPrerequisiteWhereInput(ctx context.Context, obj interface{}) (ent.PrerequisiteWhereInput, error) {
	var it ent.PrerequisiteWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOPrerequisiteWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPrerequisiteWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOPrerequisiteWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPrerequisiteWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOPrerequisiteWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPrerequisiteWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minimum":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimum"))
			it.Minimum, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minimumNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumNEQ"))
			it.MinimumNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minimumIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumIn"))
			it.MinimumIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "minimumNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumNotIn"))
			it.MinimumNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "minimumGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumGT"))
			it.MinimumGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minimumGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumGTE"))
			it.MinimumGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minimumLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumLT"))
			it.MinimumLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "minimumLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumLTE"))
			it.MinimumLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAbilityScore":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityScore"))
			it.HasAbilityScore, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAbilityScoreWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityScoreWith"))
			it.HasAbilityScoreWith, err = ec.unmarshalOAbilityScoreWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProficiencyWhereInput(ctx context.Context, obj interface{}) (ent.ProficiencyWhereInput, error) {
	var it ent.ProficiencyWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOProficiencyWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOProficiencyWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOProficiencyWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "indx":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			it.Indx, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			it.IndxNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			it.IndxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			it.IndxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			it.IndxGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			it.IndxGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			it.IndxLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			it.IndxLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			it.IndxContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			it.IndxHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			it.IndxHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			it.IndxEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			it.IndxContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tier"))
			it.Tier, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierNEQ"))
			it.TierNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierIn"))
			it.TierIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierNotIn"))
			it.TierNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierGT"))
			it.TierGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierGTE"))
			it.TierGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierLT"))
			it.TierLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierLTE"))
			it.TierLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierContains"))
			it.TierContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierHasPrefix"))
			it.TierHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierHasSuffix"))
			it.TierHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierEqualFold"))
			it.TierEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tierContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierContainsFold"))
			it.TierContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRaces":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRaces"))
			it.HasRaces, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRacesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRacesWith"))
			it.HasRacesWith, err = ec.unmarshalORaceWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasClasses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClasses"))
			it.HasClasses, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasClassesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClassesWith"))
			it.HasClassesWith, err = ec.unmarshalOClassWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐClassWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSkill":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSkill"))
			it.HasSkill, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasSkillWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSkillWith"))
			it.HasSkillWith, err = ec.unmarshalOSkillWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAbilityScore":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityScore"))
			it.HasAbilityScore, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAbilityScoreWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityScoreWith"))
			it.HasAbilityScoreWith, err = ec.unmarshalOAbilityScoreWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			it.HasEquipment, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipmentWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			it.HasEquipmentWith, err = ec.unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRaceWhereInput(ctx context.Context, obj interface{}) (ent.RaceWhereInput, error) {
	var it ent.RaceWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalORaceWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalORaceWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalORaceWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "indx":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			it.Indx, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			it.IndxNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			it.IndxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			it.IndxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			it.IndxGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			it.IndxGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			it.IndxLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			it.IndxLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			it.IndxContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			it.IndxHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			it.IndxHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			it.IndxEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			it.IndxContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "speed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speed"))
			it.Speed, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedNEQ"))
			it.SpeedNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedIn"))
			it.SpeedIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedNotIn"))
			it.SpeedNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedGT"))
			it.SpeedGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedGTE"))
			it.SpeedGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedLT"))
			it.SpeedLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedLTE"))
			it.SpeedLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLanguages":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLanguages"))
			it.HasLanguages, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasLanguagesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLanguagesWith"))
			it.HasLanguagesWith, err = ec.unmarshalOLanguageWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐLanguageWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAbilityBonuses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityBonuses"))
			it.HasAbilityBonuses, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAbilityBonusesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityBonusesWith"))
			it.HasAbilityBonusesWith, err = ec.unmarshalOAbilityBonusWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasStartingProficiencies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStartingProficiencies"))
			it.HasStartingProficiencies, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasStartingProficienciesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStartingProficienciesWith"))
			it.HasStartingProficienciesWith, err = ec.unmarshalOProficiencyWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSkillWhereInput(ctx context.Context, obj interface{}) (ent.SkillWhereInput, error) {
	var it ent.SkillWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOSkillWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOSkillWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOSkillWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "indx":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			it.Indx, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			it.IndxNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			it.IndxIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			it.IndxNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			it.IndxGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			it.IndxGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			it.IndxLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			it.IndxLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			it.IndxContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			it.IndxHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			it.IndxHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			it.IndxEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "indxContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			it.IndxContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			it.NameNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			it.NameIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			it.NameNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			it.NameGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			it.NameGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			it.NameLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			it.NameLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			it.NameContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			it.NameHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			it.NameHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			it.NameEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nameContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			it.NameContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAbilityScore":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityScore"))
			it.HasAbilityScore, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasAbilityScoreWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityScoreWith"))
			it.HasAbilityScoreWith, err = ec.unmarshalOAbilityScoreWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProficiencies":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficiencies"))
			it.HasProficiencies, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasProficienciesWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficienciesWith"))
			it.HasProficienciesWith, err = ec.unmarshalOProficiencyWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVehicleWhereInput(ctx context.Context, obj interface{}) (ent.VehicleWhereInput, error) {
	var it ent.VehicleWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOVehicleWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐVehicleWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOVehicleWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐVehicleWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOVehicleWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐVehicleWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "speed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speed"))
			it.Speed, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedNEQ"))
			it.SpeedNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedIn"))
			it.SpeedIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedNotIn"))
			it.SpeedNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedGT"))
			it.SpeedGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedGTE"))
			it.SpeedGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedLT"))
			it.SpeedLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedLTE"))
			it.SpeedLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedContains"))
			it.SpeedContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedHasPrefix"))
			it.SpeedHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedHasSuffix"))
			it.SpeedHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedEqualFold"))
			it.SpeedEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "speedContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedContainsFold"))
			it.SpeedContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacity":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacity"))
			it.Capacity, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacityNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityNEQ"))
			it.CapacityNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacityIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityIn"))
			it.CapacityIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacityNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityNotIn"))
			it.CapacityNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacityGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityGT"))
			it.CapacityGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacityGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityGTE"))
			it.CapacityGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacityLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityLT"))
			it.CapacityLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacityLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityLTE"))
			it.CapacityLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacityContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityContains"))
			it.CapacityContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacityHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityHasPrefix"))
			it.CapacityHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacityHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityHasSuffix"))
			it.CapacityHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacityEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityEqualFold"))
			it.CapacityEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "capacityContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityContainsFold"))
			it.CapacityContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			it.HasEquipment, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipmentWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			it.HasEquipmentWith, err = ec.unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWeaponDamageWhereInput(ctx context.Context, obj interface{}) (ent.WeaponDamageWhereInput, error) {
	var it ent.WeaponDamageWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOWeaponDamageWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOWeaponDamageWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOWeaponDamageWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "dice":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dice"))
			it.Dice, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "diceNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diceNEQ"))
			it.DiceNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "diceIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diceIn"))
			it.DiceIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "diceNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diceNotIn"))
			it.DiceNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "diceGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diceGT"))
			it.DiceGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "diceGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diceGTE"))
			it.DiceGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "diceLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diceLT"))
			it.DiceLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "diceLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diceLTE"))
			it.DiceLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "diceContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diceContains"))
			it.DiceContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "diceHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diceHasPrefix"))
			it.DiceHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "diceHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diceHasSuffix"))
			it.DiceHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "diceEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diceEqualFold"))
			it.DiceEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "diceContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diceContainsFold"))
			it.DiceContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDamageType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDamageType"))
			it.HasDamageType, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDamageTypeWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDamageTypeWith"))
			it.HasDamageTypeWith, err = ec.unmarshalODamageTypeWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐDamageTypeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWeapon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeapon"))
			it.HasWeapon, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWeaponWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeaponWith"))
			it.HasWeaponWith, err = ec.unmarshalOWeaponWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWeaponRangeWhereInput(ctx context.Context, obj interface{}) (ent.WeaponRangeWhereInput, error) {
	var it ent.WeaponRangeWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOWeaponRangeWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponRangeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOWeaponRangeWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponRangeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOWeaponRangeWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponRangeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "desc":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("desc"))
			it.Desc, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descNEQ"))
			it.DescNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descIn"))
			it.DescIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "descNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descNotIn"))
			it.DescNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "descGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descGT"))
			it.DescGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descGTE"))
			it.DescGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descLT"))
			it.DescLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descLTE"))
			it.DescLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descContains"))
			it.DescContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descHasPrefix"))
			it.DescHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descHasSuffix"))
			it.DescHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descEqualFold"))
			it.DescEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descContainsFold"))
			it.DescContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "normal":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("normal"))
			it.Normal, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "normalNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("normalNEQ"))
			it.NormalNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "normalIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("normalIn"))
			it.NormalIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "normalNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("normalNotIn"))
			it.NormalNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "normalGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("normalGT"))
			it.NormalGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "normalGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("normalGTE"))
			it.NormalGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "normalLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("normalLT"))
			it.NormalLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "normalLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("normalLTE"))
			it.NormalLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "long":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("long"))
			it.Long, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "longNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("longNEQ"))
			it.LongNEQ, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "longIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("longIn"))
			it.LongIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "longNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("longNotIn"))
			it.LongNotIn, err = ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "longGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("longGT"))
			it.LongGT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "longGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("longGTE"))
			it.LongGTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "longLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("longLT"))
			it.LongLT, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "longLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("longLTE"))
			it.LongLTE, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWeapon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeapon"))
			it.HasWeapon, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasWeaponWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeaponWith"))
			it.HasWeaponWith, err = ec.unmarshalOWeaponWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWeaponWhereInput(ctx context.Context, obj interface{}) (ent.WeaponWhereInput, error) {
	var it ent.WeaponWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = ec.unmarshalOWeaponWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = ec.unmarshalOWeaponWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = ec.unmarshalOWeaponWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = ec.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = ec.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "properties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			it.Properties, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "propertiesNEQ":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertiesNEQ"))
			it.PropertiesNEQ, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "propertiesIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertiesIn"))
			it.PropertiesIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "propertiesNotIn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertiesNotIn"))
			it.PropertiesNotIn, err = ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "propertiesGT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertiesGT"))
			it.PropertiesGT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "propertiesGTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertiesGTE"))
			it.PropertiesGTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "propertiesLT":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertiesLT"))
			it.PropertiesLT, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "propertiesLTE":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertiesLTE"))
			it.PropertiesLTE, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "propertiesContains":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertiesContains"))
			it.PropertiesContains, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "propertiesHasPrefix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertiesHasPrefix"))
			it.PropertiesHasPrefix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "propertiesHasSuffix":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertiesHasSuffix"))
			it.PropertiesHasSuffix, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "propertiesEqualFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertiesEqualFold"))
			it.PropertiesEqualFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "propertiesContainsFold":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("propertiesContainsFold"))
			it.PropertiesContainsFold, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRange":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRange"))
			it.HasRange, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasRangeWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRangeWith"))
			it.HasRangeWith, err = ec.unmarshalOWeaponRangeWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponRangeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDamage":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDamage"))
			it.HasDamage, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasDamageWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDamageWith"))
			it.HasDamageWith, err = ec.unmarshalOWeaponDamageWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTwoHandedDamage":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTwoHandedDamage"))
			it.HasTwoHandedDamage, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTwoHandedDamageWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTwoHandedDamageWith"))
			it.HasTwoHandedDamageWith, err = ec.unmarshalOWeaponDamageWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipment":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			it.HasEquipment, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasEquipmentWith":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			it.HasEquipmentWith, err = ec.unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.AbilityBonus:
		if obj == nil {
			return graphql.Null
		}
		return ec._AbilityBonus(ctx, sel, obj)
	case *ent.AbilityScore:
		if obj == nil {
			return graphql.Null
		}
		return ec._AbilityScore(ctx, sel, obj)
	case *ent.Alignment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Alignment(ctx, sel, obj)
	case *ent.Ammunition:
		if obj == nil {
			return graphql.Null
		}
		return ec._Ammunition(ctx, sel, obj)
	case *ent.Armor:
		if obj == nil {
			return graphql.Null
		}
		return ec._Armor(ctx, sel, obj)
	case *ent.Class:
		if obj == nil {
			return graphql.Null
		}
		return ec._Class(ctx, sel, obj)
	case *ent.Condition:
		if obj == nil {
			return graphql.Null
		}
		return ec._Condition(ctx, sel, obj)
	case *ent.DamageType:
		if obj == nil {
			return graphql.Null
		}
		return ec._DamageType(ctx, sel, obj)
	case *ent.Equipment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Equipment(ctx, sel, obj)
	case *ent.EquipmentCategory:
		if obj == nil {
			return graphql.Null
		}
		return ec._EquipmentCategory(ctx, sel, obj)
	case *ent.Gear:
		if obj == nil {
			return graphql.Null
		}
		return ec._Gear(ctx, sel, obj)
	case *ent.Language:
		if obj == nil {
			return graphql.Null
		}
		return ec._Language(ctx, sel, obj)
	case *ent.MagicItem:
		if obj == nil {
			return graphql.Null
		}
		return ec._MagicItem(ctx, sel, obj)
	case *ent.MagicSchool:
		if obj == nil {
			return graphql.Null
		}
		return ec._MagicSchool(ctx, sel, obj)
	case *ent.Pack:
		if obj == nil {
			return graphql.Null
		}
		return ec._Pack(ctx, sel, obj)
	case *ent.Prerequisite:
		if obj == nil {
			return graphql.Null
		}
		return ec._Prerequisite(ctx, sel, obj)
	case *ent.Proficiency:
		if obj == nil {
			return graphql.Null
		}
		return ec._Proficiency(ctx, sel, obj)
	case *ent.Race:
		if obj == nil {
			return graphql.Null
		}
		return ec._Race(ctx, sel, obj)
	case *ent.Skill:
		if obj == nil {
			return graphql.Null
		}
		return ec._Skill(ctx, sel, obj)
	case *ent.Vehicle:
		if obj == nil {
			return graphql.Null
		}
		return ec._Vehicle(ctx, sel, obj)
	case *ent.Weapon:
		if obj == nil {
			return graphql.Null
		}
		return ec._Weapon(ctx, sel, obj)
	case *ent.WeaponDamage:
		if obj == nil {
			return graphql.Null
		}
		return ec._WeaponDamage(ctx, sel, obj)
	case *ent.WeaponRange:
		if obj == nil {
			return graphql.Null
		}
		return ec._WeaponRange(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var abilityBonusImplementors = []string{"AbilityBonus", "Node"}

func (ec *executionContext) _AbilityBonus(ctx context.Context, sel ast.SelectionSet, obj *ent.AbilityBonus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, abilityBonusImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AbilityBonus")
		case "id":

			out.Values[i] = ec._AbilityBonus_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "bonus":

			out.Values[i] = ec._AbilityBonus_bonus(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "abilityScore":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AbilityBonus_abilityScore(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "race":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AbilityBonus_race(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var abilityScoreImplementors = []string{"AbilityScore", "Node"}

func (ec *executionContext) _AbilityScore(ctx context.Context, sel ast.SelectionSet, obj *ent.AbilityScore) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, abilityScoreImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AbilityScore")
		case "id":

			out.Values[i] = ec._AbilityScore_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "indx":

			out.Values[i] = ec._AbilityScore_indx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._AbilityScore_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "desc":

			out.Values[i] = ec._AbilityScore_desc(ctx, field, obj)

		case "fullName":

			out.Values[i] = ec._AbilityScore_fullName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "abilityBonuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AbilityScore_abilityBonuses(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "skills":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AbilityScore_skills(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "proficiencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AbilityScore_proficiencies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var alignmentImplementors = []string{"Alignment", "Node"}

func (ec *executionContext) _Alignment(ctx context.Context, sel ast.SelectionSet, obj *ent.Alignment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alignmentImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Alignment")
		case "id":

			out.Values[i] = ec._Alignment_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "indx":

			out.Values[i] = ec._Alignment_indx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._Alignment_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "desc":

			out.Values[i] = ec._Alignment_desc(ctx, field, obj)

		case "abbr":

			out.Values[i] = ec._Alignment_abbr(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ammunitionImplementors = []string{"Ammunition", "Node"}

func (ec *executionContext) _Ammunition(ctx context.Context, sel ast.SelectionSet, obj *ent.Ammunition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ammunitionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Ammunition")
		case "id":

			out.Values[i] = ec._Ammunition_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "quantity":

			out.Values[i] = ec._Ammunition_quantity(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ammunition_equipment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var armorImplementors = []string{"Armor", "Node"}

func (ec *executionContext) _Armor(ctx context.Context, sel ast.SelectionSet, obj *ent.Armor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, armorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Armor")
		case "id":

			out.Values[i] = ec._Armor_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stealthDisadvantage":

			out.Values[i] = ec._Armor_stealthDisadvantage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "armorClass":

			out.Values[i] = ec._Armor_armorClass(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "minStrength":

			out.Values[i] = ec._Armor_minStrength(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Armor_equipment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var classImplementors = []string{"Class", "Node"}

func (ec *executionContext) _Class(ctx context.Context, sel ast.SelectionSet, obj *ent.Class) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, classImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Class")
		case "id":

			out.Values[i] = ec._Class_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "indx":

			out.Values[i] = ec._Class_indx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Class_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "desc":

			out.Values[i] = ec._Class_desc(ctx, field, obj)

		case "hitDie":

			out.Values[i] = ec._Class_hitDie(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "savingThrows":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Class_savingThrows(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "startingProficiencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Class_startingProficiencies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "startingEquipment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Class_startingEquipment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var conditionImplementors = []string{"Condition", "Node"}

func (ec *executionContext) _Condition(ctx context.Context, sel ast.SelectionSet, obj *ent.Condition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, conditionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Condition")
		case "id":

			out.Values[i] = ec._Condition_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "indx":

			out.Values[i] = ec._Condition_indx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._Condition_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "desc":

			out.Values[i] = ec._Condition_desc(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var damageTypeImplementors = []string{"DamageType", "Node"}

func (ec *executionContext) _DamageType(ctx context.Context, sel ast.SelectionSet, obj *ent.DamageType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, damageTypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DamageType")
		case "id":

			out.Values[i] = ec._DamageType_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "indx":

			out.Values[i] = ec._DamageType_indx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._DamageType_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "desc":

			out.Values[i] = ec._DamageType_desc(ctx, field, obj)

		case "weaponDamage":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DamageType_weaponDamage(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var equipmentImplementors = []string{"Equipment", "Node"}

func (ec *executionContext) _Equipment(ctx context.Context, sel ast.SelectionSet, obj *ent.Equipment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, equipmentImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Equipment")
		case "id":

			out.Values[i] = ec._Equipment_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "indx":

			out.Values[i] = ec._Equipment_indx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Equipment_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "desc":

			out.Values[i] = ec._Equipment_desc(ctx, field, obj)

		case "cost":

			out.Values[i] = ec._Equipment_cost(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "weight":

			out.Values[i] = ec._Equipment_weight(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "weapon":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_weapon(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "armor":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_armor(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "gear":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_gear(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "pack":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_pack(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ammunition":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_ammunition(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "vehicle":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_vehicle(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "magicItem":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_magicItem(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "category":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_category(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "subcategory":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_subcategory(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "proficiencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_proficiencies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var equipmentCategoryImplementors = []string{"EquipmentCategory", "Node"}

func (ec *executionContext) _EquipmentCategory(ctx context.Context, sel ast.SelectionSet, obj *ent.EquipmentCategory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, equipmentCategoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EquipmentCategory")
		case "id":

			out.Values[i] = ec._EquipmentCategory_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "indx":

			out.Values[i] = ec._EquipmentCategory_indx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._EquipmentCategory_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "desc":

			out.Values[i] = ec._EquipmentCategory_desc(ctx, field, obj)

		case "equipment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EquipmentCategory_equipment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gearImplementors = []string{"Gear", "Node"}

func (ec *executionContext) _Gear(ctx context.Context, sel ast.SelectionSet, obj *ent.Gear) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gearImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Gear")
		case "id":

			out.Values[i] = ec._Gear_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Gear_equipment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var languageImplementors = []string{"Language", "Node"}

func (ec *executionContext) _Language(ctx context.Context, sel ast.SelectionSet, obj *ent.Language) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, languageImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Language")
		case "id":

			out.Values[i] = ec._Language_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "indx":

			out.Values[i] = ec._Language_indx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Language_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "desc":

			out.Values[i] = ec._Language_desc(ctx, field, obj)

		case "category":

			out.Values[i] = ec._Language_category(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "script":

			out.Values[i] = ec._Language_script(ctx, field, obj)

		case "speakers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Language_speakers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var magicItemImplementors = []string{"MagicItem", "Node"}

func (ec *executionContext) _MagicItem(ctx context.Context, sel ast.SelectionSet, obj *ent.MagicItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, magicItemImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MagicItem")
		case "id":

			out.Values[i] = ec._MagicItem_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "rarity":

			out.Values[i] = ec._MagicItem_rarity(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MagicItem_equipment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var magicSchoolImplementors = []string{"MagicSchool", "Node"}

func (ec *executionContext) _MagicSchool(ctx context.Context, sel ast.SelectionSet, obj *ent.MagicSchool) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, magicSchoolImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MagicSchool")
		case "id":

			out.Values[i] = ec._MagicSchool_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "indx":

			out.Values[i] = ec._MagicSchool_indx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._MagicSchool_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "desc":

			out.Values[i] = ec._MagicSchool_desc(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var packImplementors = []string{"Pack", "Node"}

func (ec *executionContext) _Pack(ctx context.Context, sel ast.SelectionSet, obj *ent.Pack) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pack")
		case "id":

			out.Values[i] = ec._Pack_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "contents":

			out.Values[i] = ec._Pack_contents(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pack_equipment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *entgql.PageInfo[int]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":

			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasPreviousPage":

			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startCursor":

			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)

		case "endCursor":

			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var prerequisiteImplementors = []string{"Prerequisite", "Node"}

func (ec *executionContext) _Prerequisite(ctx context.Context, sel ast.SelectionSet, obj *ent.Prerequisite) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, prerequisiteImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Prerequisite")
		case "id":

			out.Values[i] = ec._Prerequisite_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "minimum":

			out.Values[i] = ec._Prerequisite_minimum(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "abilityScore":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Prerequisite_abilityScore(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proficiencyImplementors = []string{"Proficiency", "Node"}

func (ec *executionContext) _Proficiency(ctx context.Context, sel ast.SelectionSet, obj *ent.Proficiency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, proficiencyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Proficiency")
		case "id":

			out.Values[i] = ec._Proficiency_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "indx":

			out.Values[i] = ec._Proficiency_indx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Proficiency_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "desc":

			out.Values[i] = ec._Proficiency_desc(ctx, field, obj)

		case "tier":

			out.Values[i] = ec._Proficiency_tier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "races":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Proficiency_races(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "classes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Proficiency_classes(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "skill":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Proficiency_skill(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "abilityScore":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Proficiency_abilityScore(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Proficiency_equipment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "abilityScores":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_abilityScores(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "skills":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_skills(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var raceImplementors = []string{"Race", "Node"}

func (ec *executionContext) _Race(ctx context.Context, sel ast.SelectionSet, obj *ent.Race) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, raceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Race")
		case "id":

			out.Values[i] = ec._Race_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "indx":

			out.Values[i] = ec._Race_indx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Race_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "desc":

			out.Values[i] = ec._Race_desc(ctx, field, obj)

		case "speed":

			out.Values[i] = ec._Race_speed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "languages":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Race_languages(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "abilityBonuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Race_abilityBonuses(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "startingProficiencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Race_startingProficiencies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var skillImplementors = []string{"Skill", "Node"}

func (ec *executionContext) _Skill(ctx context.Context, sel ast.SelectionSet, obj *ent.Skill) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, skillImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Skill")
		case "id":

			out.Values[i] = ec._Skill_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "indx":

			out.Values[i] = ec._Skill_indx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Skill_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "desc":

			out.Values[i] = ec._Skill_desc(ctx, field, obj)

		case "abilityScore":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Skill_abilityScore(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "proficiencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Skill_proficiencies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var vehicleImplementors = []string{"Vehicle", "Node"}

func (ec *executionContext) _Vehicle(ctx context.Context, sel ast.SelectionSet, obj *ent.Vehicle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vehicleImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Vehicle")
		case "id":

			out.Values[i] = ec._Vehicle_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "speed":

			out.Values[i] = ec._Vehicle_speed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "capacity":

			out.Values[i] = ec._Vehicle_capacity(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Vehicle_equipment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var weaponImplementors = []string{"Weapon", "Node"}

func (ec *executionContext) _Weapon(ctx context.Context, sel ast.SelectionSet, obj *ent.Weapon) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, weaponImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Weapon")
		case "id":

			out.Values[i] = ec._Weapon_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "properties":

			out.Values[i] = ec._Weapon_properties(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "range":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Weapon_range(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "damage":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Weapon_damage(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "twoHandedDamage":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Weapon_twoHandedDamage(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Weapon_equipment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var weaponDamageImplementors = []string{"WeaponDamage", "Node"}

func (ec *executionContext) _WeaponDamage(ctx context.Context, sel ast.SelectionSet, obj *ent.WeaponDamage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, weaponDamageImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WeaponDamage")
		case "id":

			out.Values[i] = ec._WeaponDamage_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dice":

			out.Values[i] = ec._WeaponDamage_dice(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "damageType":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WeaponDamage_damageType(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "weapon":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WeaponDamage_weapon(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var weaponRangeImplementors = []string{"WeaponRange", "Node"}

func (ec *executionContext) _WeaponRange(ctx context.Context, sel ast.SelectionSet, obj *ent.WeaponRange) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, weaponRangeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WeaponRange")
		case "id":

			out.Values[i] = ec._WeaponRange_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "desc":

			out.Values[i] = ec._WeaponRange_desc(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "normal":

			out.Values[i] = ec._WeaponRange_normal(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "long":

			out.Values[i] = ec._WeaponRange_long(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "weapon":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WeaponRange_weapon(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAbilityBonus2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonus(ctx context.Context, sel ast.SelectionSet, v *ent.AbilityBonus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AbilityBonus(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAbilityBonusOrderField2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusOrderField(ctx context.Context, v interface{}) (*ent.AbilityBonusOrderField, error) {
	var res = new(ent.AbilityBonusOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAbilityBonusOrderField2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.AbilityBonusOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNAbilityBonusWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusWhereInput(ctx context.Context, v interface{}) (*ent.AbilityBonusWhereInput, error) {
	res, err := ec.unmarshalInputAbilityBonusWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAbilityScore2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.AbilityScore) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAbilityScore2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScore(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAbilityScore2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScore(ctx context.Context, sel ast.SelectionSet, v *ent.AbilityScore) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AbilityScore(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAbilityScoreWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreWhereInput(ctx context.Context, v interface{}) (*ent.AbilityScoreWhereInput, error) {
	res, err := ec.unmarshalInputAbilityScoreWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAlignmentWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAlignmentWhereInput(ctx context.Context, v interface{}) (*ent.AlignmentWhereInput, error) {
	res, err := ec.unmarshalInputAlignmentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAmmunition2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAmmunition(ctx context.Context, sel ast.SelectionSet, v *ent.Ammunition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Ammunition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAmmunitionWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAmmunitionWhereInput(ctx context.Context, v interface{}) (*ent.AmmunitionWhereInput, error) {
	res, err := ec.unmarshalInputAmmunitionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArmor2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐArmor(ctx context.Context, sel ast.SelectionSet, v *ent.Armor) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Armor(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArmorWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐArmorWhereInput(ctx context.Context, v interface{}) (*ent.ArmorWhereInput, error) {
	res, err := ec.unmarshalInputArmorWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNClass2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐClass(ctx context.Context, sel ast.SelectionSet, v *ent.Class) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Class(ctx, sel, v)
}

func (ec *executionContext) unmarshalNClassWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐClassWhereInput(ctx context.Context, v interface{}) (*ent.ClassWhereInput, error) {
	res, err := ec.unmarshalInputClassWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNConditionWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐConditionWhereInput(ctx context.Context, v interface{}) (*ent.ConditionWhereInput, error) {
	res, err := ec.unmarshalInputConditionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDamageType2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐDamageType(ctx context.Context, sel ast.SelectionSet, v *ent.DamageType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DamageType(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDamageTypeWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐDamageTypeWhereInput(ctx context.Context, v interface{}) (*ent.DamageTypeWhereInput, error) {
	res, err := ec.unmarshalInputDamageTypeWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEquipment2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipment(ctx context.Context, sel ast.SelectionSet, v *ent.Equipment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Equipment(ctx, sel, v)
}

func (ec *executionContext) marshalNEquipmentCategory2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategory(ctx context.Context, sel ast.SelectionSet, v *ent.EquipmentCategory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EquipmentCategory(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEquipmentCategoryWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategoryWhereInput(ctx context.Context, v interface{}) (*ent.EquipmentCategoryWhereInput, error) {
	res, err := ec.unmarshalInputEquipmentCategoryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEquipmentWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInput(ctx context.Context, v interface{}) (*ent.EquipmentWhereInput, error) {
	res, err := ec.unmarshalInputEquipmentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGear2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐGear(ctx context.Context, sel ast.SelectionSet, v *ent.Gear) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Gear(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGearWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐGearWhereInput(ctx context.Context, v interface{}) (*ent.GearWhereInput, error) {
	res, err := ec.unmarshalInputGearWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalIntID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalIntID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLanguage2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐLanguage(ctx context.Context, sel ast.SelectionSet, v *ent.Language) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Language(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLanguageCategory2githubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategory(ctx context.Context, v interface{}) (language.Category, error) {
	var res language.Category
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLanguageCategory2githubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategory(ctx context.Context, sel ast.SelectionSet, v language.Category) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNLanguageScript2githubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScript(ctx context.Context, v interface{}) (language.Script, error) {
	var res language.Script
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLanguageScript2githubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScript(ctx context.Context, sel ast.SelectionSet, v language.Script) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNLanguageWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐLanguageWhereInput(ctx context.Context, v interface{}) (*ent.LanguageWhereInput, error) {
	res, err := ec.unmarshalInputLanguageWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMagicItem2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicItem(ctx context.Context, sel ast.SelectionSet, v *ent.MagicItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MagicItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMagicItemWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicItemWhereInput(ctx context.Context, v interface{}) (*ent.MagicItemWhereInput, error) {
	res, err := ec.unmarshalInputMagicItemWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMagicSchoolWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicSchoolWhereInput(ctx context.Context, v interface{}) (*ent.MagicSchoolWhereInput, error) {
	res, err := ec.unmarshalInputMagicSchoolWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNode2ᚕgithubᚗcomᚋecshreveᚋdndgenᚋentᚐNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2githubᚗcomᚋecshreveᚋdndgenᚋentᚐNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx context.Context, v interface{}) (entgql.OrderDirection, error) {
	var res entgql.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx context.Context, sel ast.SelectionSet, v entgql.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPack2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPack(ctx context.Context, sel ast.SelectionSet, v *ent.Pack) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Pack(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPackWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPackWhereInput(ctx context.Context, v interface{}) (*ent.PackWhereInput, error) {
	res, err := ec.unmarshalInputPackWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPrerequisiteWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPrerequisiteWhereInput(ctx context.Context, v interface{}) (*ent.PrerequisiteWhereInput, error) {
	res, err := ec.unmarshalInputPrerequisiteWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProficiency2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiency(ctx context.Context, sel ast.SelectionSet, v *ent.Proficiency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Proficiency(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProficiencyWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyWhereInput(ctx context.Context, v interface{}) (*ent.ProficiencyWhereInput, error) {
	res, err := ec.unmarshalInputProficiencyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRace2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRace(ctx context.Context, sel ast.SelectionSet, v *ent.Race) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Race(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRaceWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceWhereInput(ctx context.Context, v interface{}) (*ent.RaceWhereInput, error) {
	res, err := ec.unmarshalInputRaceWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSkill2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Skill) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSkill2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkill(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSkill2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkill(ctx context.Context, sel ast.SelectionSet, v *ent.Skill) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Skill(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSkillWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillWhereInput(ctx context.Context, v interface{}) (*ent.SkillWhereInput, error) {
	res, err := ec.unmarshalInputSkillWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNVehicle2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐVehicle(ctx context.Context, sel ast.SelectionSet, v *ent.Vehicle) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Vehicle(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVehicleWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐVehicleWhereInput(ctx context.Context, v interface{}) (*ent.VehicleWhereInput, error) {
	res, err := ec.unmarshalInputVehicleWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWeapon2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeapon(ctx context.Context, sel ast.SelectionSet, v *ent.Weapon) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Weapon(ctx, sel, v)
}

func (ec *executionContext) marshalNWeaponDamage2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamage(ctx context.Context, sel ast.SelectionSet, v *ent.WeaponDamage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WeaponDamage(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWeaponDamageWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageWhereInput(ctx context.Context, v interface{}) (*ent.WeaponDamageWhereInput, error) {
	res, err := ec.unmarshalInputWeaponDamageWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWeaponRange2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponRange(ctx context.Context, sel ast.SelectionSet, v *ent.WeaponRange) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WeaponRange(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWeaponRangeWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponRangeWhereInput(ctx context.Context, v interface{}) (*ent.WeaponRangeWhereInput, error) {
	res, err := ec.unmarshalInputWeaponRangeWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWeaponWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponWhereInput(ctx context.Context, v interface{}) (*ent.WeaponWhereInput, error) {
	res, err := ec.unmarshalInputWeaponWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAbilityBonus2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.AbilityBonus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAbilityBonus2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAbilityBonusWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.AbilityBonusWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.AbilityBonusWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAbilityBonusWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAbilityBonusWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityBonusWhereInput(ctx context.Context, v interface{}) (*ent.AbilityBonusWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAbilityBonusWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAbilityScore2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.AbilityScore) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAbilityScore2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScore(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOAbilityScore2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScore(ctx context.Context, sel ast.SelectionSet, v *ent.AbilityScore) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AbilityScore(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAbilityScoreWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.AbilityScoreWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.AbilityScoreWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAbilityScoreWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAbilityScoreWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAbilityScoreWhereInput(ctx context.Context, v interface{}) (*ent.AbilityScoreWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAbilityScoreWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAlignmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAlignmentWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.AlignmentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.AlignmentWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAlignmentWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAlignmentWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAlignmentWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAlignmentWhereInput(ctx context.Context, v interface{}) (*ent.AlignmentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAlignmentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAmmunition2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAmmunitionᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Ammunition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAmmunition2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAmmunition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAmmunitionWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAmmunitionWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.AmmunitionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.AmmunitionWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAmmunitionWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAmmunitionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAmmunitionWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐAmmunitionWhereInput(ctx context.Context, v interface{}) (*ent.AmmunitionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAmmunitionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOArmor2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐArmorᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Armor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNArmor2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐArmor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOArmorWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐArmorWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.ArmorWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ArmorWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNArmorWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐArmorWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOArmorWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐArmorWhereInput(ctx context.Context, v interface{}) (*ent.ArmorWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputArmorWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOClass2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐClassᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Class) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNClass2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐClass(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOClassWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐClassWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.ClassWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ClassWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNClassWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐClassWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOClassWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐClassWhereInput(ctx context.Context, v interface{}) (*ent.ClassWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputClassWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOConditionWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐConditionWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.ConditionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ConditionWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNConditionWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐConditionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOConditionWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐConditionWhereInput(ctx context.Context, v interface{}) (*ent.ConditionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputConditionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, v interface{}) (*entgql.Cursor[int], error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entgql.Cursor[int])
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, sel ast.SelectionSet, v *entgql.Cursor[int]) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalODamageType2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐDamageTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.DamageType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDamageType2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐDamageType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalODamageTypeWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐDamageTypeWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.DamageTypeWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.DamageTypeWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDamageTypeWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐDamageTypeWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalODamageTypeWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐDamageTypeWhereInput(ctx context.Context, v interface{}) (*ent.DamageTypeWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDamageTypeWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEquipment2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Equipment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEquipment2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOEquipmentCategory2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategoryᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.EquipmentCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEquipmentCategory2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOEquipmentCategoryWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategoryWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.EquipmentCategoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.EquipmentCategoryWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEquipmentCategoryWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategoryWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOEquipmentCategoryWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentCategoryWhereInput(ctx context.Context, v interface{}) (*ent.EquipmentCategoryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEquipmentCategoryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEquipmentWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.EquipmentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.EquipmentWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEquipmentWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOEquipmentWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐEquipmentWhereInput(ctx context.Context, v interface{}) (*ent.EquipmentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEquipmentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGear2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐGearᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Gear) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGear2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐGear(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGearWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐGearWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.GearWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GearWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGearWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐGearWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGearWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐGearWhereInput(ctx context.Context, v interface{}) (*ent.GearWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGearWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOID2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalIntID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalIntID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOLanguage2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐLanguageᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Language) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLanguage2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐLanguage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOLanguageCategory2ᚕgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategoryᚄ(ctx context.Context, v interface{}) ([]language.Category, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]language.Category, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLanguageCategory2githubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategory(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOLanguageCategory2ᚕgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategoryᚄ(ctx context.Context, sel ast.SelectionSet, v []language.Category) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLanguageCategory2githubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOLanguageCategory2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategory(ctx context.Context, v interface{}) (*language.Category, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(language.Category)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLanguageCategory2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐCategory(ctx context.Context, sel ast.SelectionSet, v *language.Category) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLanguageScript2githubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScript(ctx context.Context, v interface{}) (language.Script, error) {
	var res language.Script
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLanguageScript2githubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScript(ctx context.Context, sel ast.SelectionSet, v language.Script) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOLanguageScript2ᚕgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScriptᚄ(ctx context.Context, v interface{}) ([]language.Script, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]language.Script, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLanguageScript2githubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScript(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOLanguageScript2ᚕgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScriptᚄ(ctx context.Context, sel ast.SelectionSet, v []language.Script) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLanguageScript2githubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScript(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOLanguageScript2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScript(ctx context.Context, v interface{}) (*language.Script, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(language.Script)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLanguageScript2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚋlanguageᚐScript(ctx context.Context, sel ast.SelectionSet, v *language.Script) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLanguageWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐLanguageWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.LanguageWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.LanguageWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLanguageWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐLanguageWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLanguageWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐLanguageWhereInput(ctx context.Context, v interface{}) (*ent.LanguageWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLanguageWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMagicItem2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.MagicItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMagicItem2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMagicItemWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicItemWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.MagicItemWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.MagicItemWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMagicItemWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicItemWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOMagicItemWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicItemWhereInput(ctx context.Context, v interface{}) (*ent.MagicItemWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMagicItemWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMagicSchoolWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicSchoolWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.MagicSchoolWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.MagicSchoolWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMagicSchoolWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicSchoolWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOMagicSchoolWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐMagicSchoolWhereInput(ctx context.Context, v interface{}) (*ent.MagicSchoolWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMagicSchoolWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONode2githubᚗcomᚋecshreveᚋdndgenᚋentᚐNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOPack2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPackᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Pack) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPack2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPack(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPackWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPackWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.PackWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.PackWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPackWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPackWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPackWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPackWhereInput(ctx context.Context, v interface{}) (*ent.PackWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPackWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPrerequisiteWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPrerequisiteWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.PrerequisiteWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.PrerequisiteWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPrerequisiteWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPrerequisiteWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPrerequisiteWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐPrerequisiteWhereInput(ctx context.Context, v interface{}) (*ent.PrerequisiteWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPrerequisiteWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProficiency2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Proficiency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProficiency2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOProficiencyWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.ProficiencyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ProficiencyWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProficiencyWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProficiencyWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐProficiencyWhereInput(ctx context.Context, v interface{}) (*ent.ProficiencyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProficiencyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORace2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Race) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRace2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalORaceWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.RaceWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.RaceWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRaceWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalORaceWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐRaceWhereInput(ctx context.Context, v interface{}) (*ent.RaceWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRaceWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSkill2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Skill) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSkill2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkill(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSkillWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.SkillWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.SkillWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSkillWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSkillWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐSkillWhereInput(ctx context.Context, v interface{}) (*ent.SkillWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSkillWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOVehicle2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐVehicleᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Vehicle) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVehicle2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐVehicle(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOVehicleWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐVehicleWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.VehicleWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.VehicleWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVehicleWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐVehicleWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOVehicleWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐVehicleWhereInput(ctx context.Context, v interface{}) (*ent.VehicleWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputVehicleWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWeapon2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Weapon) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWeapon2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeapon(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOWeaponDamage2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.WeaponDamage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWeaponDamage2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOWeaponDamage2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamage(ctx context.Context, sel ast.SelectionSet, v *ent.WeaponDamage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WeaponDamage(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWeaponDamageWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.WeaponDamageWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.WeaponDamageWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWeaponDamageWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWeaponDamageWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponDamageWhereInput(ctx context.Context, v interface{}) (*ent.WeaponDamageWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWeaponDamageWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWeaponRange2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponRangeᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.WeaponRange) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWeaponRange2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponRange(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWeaponRangeWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponRangeWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.WeaponRangeWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.WeaponRangeWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWeaponRangeWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponRangeWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWeaponRangeWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponRangeWhereInput(ctx context.Context, v interface{}) (*ent.WeaponRangeWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWeaponRangeWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWeaponWhereInput2ᚕᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.WeaponWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.WeaponWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWeaponWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWeaponWhereInput2ᚖgithubᚗcomᚋecshreveᚋdndgenᚋentᚐWeaponWhereInput(ctx context.Context, v interface{}) (*ent.WeaponWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWeaponWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
