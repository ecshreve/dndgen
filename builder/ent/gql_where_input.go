// Code generated by ent, DO NOT EDIT.

package ent

import (
	"builder/ent/character"
	"builder/ent/class"
	"builder/ent/predicate"
	"builder/ent/race"
	"errors"
	"fmt"
)

// CharacterWhereInput represents a where input for filtering Character queries.
type CharacterWhereInput struct {
	Predicates []predicate.Character  `json:"-"`
	Not        *CharacterWhereInput   `json:"not,omitempty"`
	Or         []*CharacterWhereInput `json:"or,omitempty"`
	And        []*CharacterWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "level" field predicates.
	Level      *int  `json:"level,omitempty"`
	LevelNEQ   *int  `json:"levelNEQ,omitempty"`
	LevelIn    []int `json:"levelIn,omitempty"`
	LevelNotIn []int `json:"levelNotIn,omitempty"`
	LevelGT    *int  `json:"levelGT,omitempty"`
	LevelGTE   *int  `json:"levelGTE,omitempty"`
	LevelLT    *int  `json:"levelLT,omitempty"`
	LevelLTE   *int  `json:"levelLTE,omitempty"`

	// "alignment" field predicates.
	Alignment             *string  `json:"alignment,omitempty"`
	AlignmentNEQ          *string  `json:"alignmentNEQ,omitempty"`
	AlignmentIn           []string `json:"alignmentIn,omitempty"`
	AlignmentNotIn        []string `json:"alignmentNotIn,omitempty"`
	AlignmentGT           *string  `json:"alignmentGT,omitempty"`
	AlignmentGTE          *string  `json:"alignmentGTE,omitempty"`
	AlignmentLT           *string  `json:"alignmentLT,omitempty"`
	AlignmentLTE          *string  `json:"alignmentLTE,omitempty"`
	AlignmentContains     *string  `json:"alignmentContains,omitempty"`
	AlignmentHasPrefix    *string  `json:"alignmentHasPrefix,omitempty"`
	AlignmentHasSuffix    *string  `json:"alignmentHasSuffix,omitempty"`
	AlignmentIsNil        bool     `json:"alignmentIsNil,omitempty"`
	AlignmentNotNil       bool     `json:"alignmentNotNil,omitempty"`
	AlignmentEqualFold    *string  `json:"alignmentEqualFold,omitempty"`
	AlignmentContainsFold *string  `json:"alignmentContainsFold,omitempty"`

	// "race" edge predicates.
	HasRace     *bool             `json:"hasRace,omitempty"`
	HasRaceWith []*RaceWhereInput `json:"hasRaceWith,omitempty"`

	// "class" edge predicates.
	HasClass     *bool              `json:"hasClass,omitempty"`
	HasClassWith []*ClassWhereInput `json:"hasClassWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CharacterWhereInput) AddPredicates(predicates ...predicate.Character) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CharacterWhereInput filter on the CharacterQuery builder.
func (i *CharacterWhereInput) Filter(q *CharacterQuery) (*CharacterQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCharacterWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCharacterWhereInput is returned in case the CharacterWhereInput is empty.
var ErrEmptyCharacterWhereInput = errors.New("ent: empty predicate CharacterWhereInput")

// P returns a predicate for filtering characters.
// An error is returned if the input is empty or invalid.
func (i *CharacterWhereInput) P() (predicate.Character, error) {
	var predicates []predicate.Character
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, character.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Character, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, character.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Character, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, character.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, character.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, character.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, character.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, character.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, character.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, character.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, character.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, character.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, character.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, character.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, character.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, character.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, character.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, character.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, character.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, character.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, character.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, character.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, character.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, character.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, character.NameContainsFold(*i.NameContainsFold))
	}
	if i.Level != nil {
		predicates = append(predicates, character.LevelEQ(*i.Level))
	}
	if i.LevelNEQ != nil {
		predicates = append(predicates, character.LevelNEQ(*i.LevelNEQ))
	}
	if len(i.LevelIn) > 0 {
		predicates = append(predicates, character.LevelIn(i.LevelIn...))
	}
	if len(i.LevelNotIn) > 0 {
		predicates = append(predicates, character.LevelNotIn(i.LevelNotIn...))
	}
	if i.LevelGT != nil {
		predicates = append(predicates, character.LevelGT(*i.LevelGT))
	}
	if i.LevelGTE != nil {
		predicates = append(predicates, character.LevelGTE(*i.LevelGTE))
	}
	if i.LevelLT != nil {
		predicates = append(predicates, character.LevelLT(*i.LevelLT))
	}
	if i.LevelLTE != nil {
		predicates = append(predicates, character.LevelLTE(*i.LevelLTE))
	}
	if i.Alignment != nil {
		predicates = append(predicates, character.AlignmentEQ(*i.Alignment))
	}
	if i.AlignmentNEQ != nil {
		predicates = append(predicates, character.AlignmentNEQ(*i.AlignmentNEQ))
	}
	if len(i.AlignmentIn) > 0 {
		predicates = append(predicates, character.AlignmentIn(i.AlignmentIn...))
	}
	if len(i.AlignmentNotIn) > 0 {
		predicates = append(predicates, character.AlignmentNotIn(i.AlignmentNotIn...))
	}
	if i.AlignmentGT != nil {
		predicates = append(predicates, character.AlignmentGT(*i.AlignmentGT))
	}
	if i.AlignmentGTE != nil {
		predicates = append(predicates, character.AlignmentGTE(*i.AlignmentGTE))
	}
	if i.AlignmentLT != nil {
		predicates = append(predicates, character.AlignmentLT(*i.AlignmentLT))
	}
	if i.AlignmentLTE != nil {
		predicates = append(predicates, character.AlignmentLTE(*i.AlignmentLTE))
	}
	if i.AlignmentContains != nil {
		predicates = append(predicates, character.AlignmentContains(*i.AlignmentContains))
	}
	if i.AlignmentHasPrefix != nil {
		predicates = append(predicates, character.AlignmentHasPrefix(*i.AlignmentHasPrefix))
	}
	if i.AlignmentHasSuffix != nil {
		predicates = append(predicates, character.AlignmentHasSuffix(*i.AlignmentHasSuffix))
	}
	if i.AlignmentIsNil {
		predicates = append(predicates, character.AlignmentIsNil())
	}
	if i.AlignmentNotNil {
		predicates = append(predicates, character.AlignmentNotNil())
	}
	if i.AlignmentEqualFold != nil {
		predicates = append(predicates, character.AlignmentEqualFold(*i.AlignmentEqualFold))
	}
	if i.AlignmentContainsFold != nil {
		predicates = append(predicates, character.AlignmentContainsFold(*i.AlignmentContainsFold))
	}

	if i.HasRace != nil {
		p := character.HasRace()
		if !*i.HasRace {
			p = character.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRaceWith) > 0 {
		with := make([]predicate.Race, 0, len(i.HasRaceWith))
		for _, w := range i.HasRaceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRaceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, character.HasRaceWith(with...))
	}
	if i.HasClass != nil {
		p := character.HasClass()
		if !*i.HasClass {
			p = character.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClassWith) > 0 {
		with := make([]predicate.Class, 0, len(i.HasClassWith))
		for _, w := range i.HasClassWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasClassWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, character.HasClassWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCharacterWhereInput
	case 1:
		return predicates[0], nil
	default:
		return character.And(predicates...), nil
	}
}

// ClassWhereInput represents a where input for filtering Class queries.
type ClassWhereInput struct {
	Predicates []predicate.Class  `json:"-"`
	Not        *ClassWhereInput   `json:"not,omitempty"`
	Or         []*ClassWhereInput `json:"or,omitempty"`
	And        []*ClassWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "characters" edge predicates.
	HasCharacters     *bool                  `json:"hasCharacters,omitempty"`
	HasCharactersWith []*CharacterWhereInput `json:"hasCharactersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ClassWhereInput) AddPredicates(predicates ...predicate.Class) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ClassWhereInput filter on the ClassQuery builder.
func (i *ClassWhereInput) Filter(q *ClassQuery) (*ClassQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyClassWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyClassWhereInput is returned in case the ClassWhereInput is empty.
var ErrEmptyClassWhereInput = errors.New("ent: empty predicate ClassWhereInput")

// P returns a predicate for filtering classes.
// An error is returned if the input is empty or invalid.
func (i *ClassWhereInput) P() (predicate.Class, error) {
	var predicates []predicate.Class
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, class.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Class, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, class.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Class, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, class.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, class.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, class.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, class.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, class.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, class.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, class.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, class.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, class.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, class.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, class.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, class.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, class.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, class.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, class.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, class.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, class.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, class.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, class.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, class.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, class.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, class.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasCharacters != nil {
		p := class.HasCharacters()
		if !*i.HasCharacters {
			p = class.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCharactersWith) > 0 {
		with := make([]predicate.Character, 0, len(i.HasCharactersWith))
		for _, w := range i.HasCharactersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCharactersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, class.HasCharactersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyClassWhereInput
	case 1:
		return predicates[0], nil
	default:
		return class.And(predicates...), nil
	}
}

// RaceWhereInput represents a where input for filtering Race queries.
type RaceWhereInput struct {
	Predicates []predicate.Race  `json:"-"`
	Not        *RaceWhereInput   `json:"not,omitempty"`
	Or         []*RaceWhereInput `json:"or,omitempty"`
	And        []*RaceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "characters" edge predicates.
	HasCharacters     *bool                  `json:"hasCharacters,omitempty"`
	HasCharactersWith []*CharacterWhereInput `json:"hasCharactersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RaceWhereInput) AddPredicates(predicates ...predicate.Race) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RaceWhereInput filter on the RaceQuery builder.
func (i *RaceWhereInput) Filter(q *RaceQuery) (*RaceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRaceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRaceWhereInput is returned in case the RaceWhereInput is empty.
var ErrEmptyRaceWhereInput = errors.New("ent: empty predicate RaceWhereInput")

// P returns a predicate for filtering races.
// An error is returned if the input is empty or invalid.
func (i *RaceWhereInput) P() (predicate.Race, error) {
	var predicates []predicate.Race
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, race.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Race, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, race.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Race, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, race.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, race.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, race.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, race.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, race.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, race.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, race.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, race.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, race.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, race.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, race.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, race.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, race.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, race.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, race.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, race.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, race.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, race.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, race.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, race.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, race.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, race.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasCharacters != nil {
		p := race.HasCharacters()
		if !*i.HasCharacters {
			p = race.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCharactersWith) > 0 {
		with := make([]predicate.Character, 0, len(i.HasCharactersWith))
		for _, w := range i.HasCharactersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCharactersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, race.HasCharactersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRaceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return race.And(predicates...), nil
	}
}
