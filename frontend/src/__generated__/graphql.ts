/* eslint-disable */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: { input: any; output: any; }
};

export type AbilityScore = Node & {
  __typename?: 'AbilityScore';
  characterAbilityScores?: Maybe<Array<CharacterAbilityScore>>;
  characters?: Maybe<Array<Character>>;
  classes?: Maybe<Array<Class>>;
  desc?: Maybe<Array<Scalars['String']['output']>>;
  fullName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
  race?: Maybe<Array<Race>>;
  skills?: Maybe<Array<Skill>>;
};

/** Ordering options for AbilityScore connections */
export type AbilityScoreOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order AbilityScores. */
  field: AbilityScoreOrderField;
};

/** Properties by which AbilityScore connections can be ordered. */
export enum AbilityScoreOrderField {
  FullName = 'FULL_NAME',
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * AbilityScoreWhereInput is used for filtering AbilityScore objects.
 * Input was generated by ent.
 */
export type AbilityScoreWhereInput = {
  and?: InputMaybe<Array<AbilityScoreWhereInput>>;
  /** full_name field predicates */
  fullName?: InputMaybe<Scalars['String']['input']>;
  fullNameContains?: InputMaybe<Scalars['String']['input']>;
  fullNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  fullNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  fullNameGT?: InputMaybe<Scalars['String']['input']>;
  fullNameGTE?: InputMaybe<Scalars['String']['input']>;
  fullNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  fullNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  fullNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  fullNameLT?: InputMaybe<Scalars['String']['input']>;
  fullNameLTE?: InputMaybe<Scalars['String']['input']>;
  fullNameNEQ?: InputMaybe<Scalars['String']['input']>;
  fullNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** character_ability_scores edge predicates */
  hasCharacterAbilityScores?: InputMaybe<Scalars['Boolean']['input']>;
  hasCharacterAbilityScoresWith?: InputMaybe<Array<CharacterAbilityScoreWhereInput>>;
  /** characters edge predicates */
  hasCharacters?: InputMaybe<Scalars['Boolean']['input']>;
  hasCharactersWith?: InputMaybe<Array<CharacterWhereInput>>;
  /** classes edge predicates */
  hasClasses?: InputMaybe<Scalars['Boolean']['input']>;
  hasClassesWith?: InputMaybe<Array<ClassWhereInput>>;
  /** race edge predicates */
  hasRace?: InputMaybe<Scalars['Boolean']['input']>;
  hasRaceWith?: InputMaybe<Array<RaceWhereInput>>;
  /** skills edge predicates */
  hasSkills?: InputMaybe<Scalars['Boolean']['input']>;
  hasSkillsWith?: InputMaybe<Array<SkillWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<AbilityScoreWhereInput>;
  or?: InputMaybe<Array<AbilityScoreWhereInput>>;
};

export type Alignment = Node & {
  __typename?: 'Alignment';
  abbr: AlignmentAbbr;
  desc?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

/** AlignmentAbbr is enum for the field abbr */
export enum AlignmentAbbr {
  Ce = 'CE',
  Cg = 'CG',
  Cn = 'CN',
  Le = 'LE',
  Lg = 'LG',
  Ln = 'LN',
  N = 'N',
  Ne = 'NE',
  Ng = 'NG'
}

/** Ordering options for Alignment connections */
export type AlignmentOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Alignments. */
  field: AlignmentOrderField;
};

/** Properties by which Alignment connections can be ordered. */
export enum AlignmentOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * AlignmentWhereInput is used for filtering Alignment objects.
 * Input was generated by ent.
 */
export type AlignmentWhereInput = {
  /** abbr field predicates */
  abbr?: InputMaybe<AlignmentAbbr>;
  abbrIn?: InputMaybe<Array<AlignmentAbbr>>;
  abbrNEQ?: InputMaybe<AlignmentAbbr>;
  abbrNotIn?: InputMaybe<Array<AlignmentAbbr>>;
  and?: InputMaybe<Array<AlignmentWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<AlignmentWhereInput>;
  or?: InputMaybe<Array<AlignmentWhereInput>>;
};

export type Armor = Node & {
  __typename?: 'Armor';
  acBase: Scalars['Int']['output'];
  acDexBonus: Scalars['Boolean']['output'];
  acMaxBonus: Scalars['Int']['output'];
  armorCategory: ArmorArmorCategory;
  equipment: Equipment;
  id: Scalars['ID']['output'];
  stealthDisadvantage: Scalars['Boolean']['output'];
  strMinimum: Scalars['Int']['output'];
};

/** ArmorArmorCategory is enum for the field armor_category */
export enum ArmorArmorCategory {
  Heavy = 'heavy',
  Light = 'light',
  Medium = 'medium',
  Shield = 'shield'
}

/**
 * ArmorWhereInput is used for filtering Armor objects.
 * Input was generated by ent.
 */
export type ArmorWhereInput = {
  /** ac_base field predicates */
  acBase?: InputMaybe<Scalars['Int']['input']>;
  acBaseGT?: InputMaybe<Scalars['Int']['input']>;
  acBaseGTE?: InputMaybe<Scalars['Int']['input']>;
  acBaseIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  acBaseLT?: InputMaybe<Scalars['Int']['input']>;
  acBaseLTE?: InputMaybe<Scalars['Int']['input']>;
  acBaseNEQ?: InputMaybe<Scalars['Int']['input']>;
  acBaseNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** ac_dex_bonus field predicates */
  acDexBonus?: InputMaybe<Scalars['Boolean']['input']>;
  acDexBonusNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** ac_max_bonus field predicates */
  acMaxBonus?: InputMaybe<Scalars['Int']['input']>;
  acMaxBonusGT?: InputMaybe<Scalars['Int']['input']>;
  acMaxBonusGTE?: InputMaybe<Scalars['Int']['input']>;
  acMaxBonusIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  acMaxBonusLT?: InputMaybe<Scalars['Int']['input']>;
  acMaxBonusLTE?: InputMaybe<Scalars['Int']['input']>;
  acMaxBonusNEQ?: InputMaybe<Scalars['Int']['input']>;
  acMaxBonusNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  and?: InputMaybe<Array<ArmorWhereInput>>;
  /** armor_category field predicates */
  armorCategory?: InputMaybe<ArmorArmorCategory>;
  armorCategoryIn?: InputMaybe<Array<ArmorArmorCategory>>;
  armorCategoryNEQ?: InputMaybe<ArmorArmorCategory>;
  armorCategoryNotIn?: InputMaybe<Array<ArmorArmorCategory>>;
  /** equipment edge predicates */
  hasEquipment?: InputMaybe<Scalars['Boolean']['input']>;
  hasEquipmentWith?: InputMaybe<Array<EquipmentWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<ArmorWhereInput>;
  or?: InputMaybe<Array<ArmorWhereInput>>;
  /** stealth_disadvantage field predicates */
  stealthDisadvantage?: InputMaybe<Scalars['Boolean']['input']>;
  stealthDisadvantageNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** str_minimum field predicates */
  strMinimum?: InputMaybe<Scalars['Int']['input']>;
  strMinimumGT?: InputMaybe<Scalars['Int']['input']>;
  strMinimumGTE?: InputMaybe<Scalars['Int']['input']>;
  strMinimumIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  strMinimumLT?: InputMaybe<Scalars['Int']['input']>;
  strMinimumLTE?: InputMaybe<Scalars['Int']['input']>;
  strMinimumNEQ?: InputMaybe<Scalars['Int']['input']>;
  strMinimumNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type Character = Node & {
  __typename?: 'Character';
  abilityScores?: Maybe<Array<AbilityScore>>;
  age: Scalars['Int']['output'];
  alignment?: Maybe<Alignment>;
  characterAbilityScores?: Maybe<Array<CharacterAbilityScore>>;
  characterSkills?: Maybe<Array<CharacterSkill>>;
  class?: Maybe<Class>;
  id: Scalars['ID']['output'];
  level: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  proficiencies?: Maybe<Array<Proficiency>>;
  proficiencyBonus: Scalars['Int']['output'];
  race?: Maybe<Race>;
  skills?: Maybe<Array<Skill>>;
};

export type CharacterAbilityScore = Node & {
  __typename?: 'CharacterAbilityScore';
  abilityScore: AbilityScore;
  abilityScoreID: Scalars['ID']['output'];
  character: Character;
  characterID: Scalars['ID']['output'];
  characterSkills?: Maybe<Array<CharacterSkill>>;
  id: Scalars['ID']['output'];
  modifier: Scalars['Int']['output'];
  score: Scalars['Int']['output'];
};

/**
 * CharacterAbilityScoreWhereInput is used for filtering CharacterAbilityScore objects.
 * Input was generated by ent.
 */
export type CharacterAbilityScoreWhereInput = {
  and?: InputMaybe<Array<CharacterAbilityScoreWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** modifier field predicates */
  modifier?: InputMaybe<Scalars['Int']['input']>;
  modifierGT?: InputMaybe<Scalars['Int']['input']>;
  modifierGTE?: InputMaybe<Scalars['Int']['input']>;
  modifierIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  modifierLT?: InputMaybe<Scalars['Int']['input']>;
  modifierLTE?: InputMaybe<Scalars['Int']['input']>;
  modifierNEQ?: InputMaybe<Scalars['Int']['input']>;
  modifierNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  not?: InputMaybe<CharacterAbilityScoreWhereInput>;
  or?: InputMaybe<Array<CharacterAbilityScoreWhereInput>>;
  /** score field predicates */
  score?: InputMaybe<Scalars['Int']['input']>;
  scoreGT?: InputMaybe<Scalars['Int']['input']>;
  scoreGTE?: InputMaybe<Scalars['Int']['input']>;
  scoreIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  scoreLT?: InputMaybe<Scalars['Int']['input']>;
  scoreLTE?: InputMaybe<Scalars['Int']['input']>;
  scoreNEQ?: InputMaybe<Scalars['Int']['input']>;
  scoreNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** A connection to a list of items. */
export type CharacterConnection = {
  __typename?: 'CharacterConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CharacterEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CharacterEdge = {
  __typename?: 'CharacterEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Character>;
};

/** Ordering options for Character connections */
export type CharacterOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Characters. */
  field: CharacterOrderField;
};

/** Properties by which Character connections can be ordered. */
export enum CharacterOrderField {
  Level = 'LEVEL',
  Name = 'NAME'
}

export type CharacterSkill = Node & {
  __typename?: 'CharacterSkill';
  character: Character;
  characterAbilityScore?: Maybe<CharacterAbilityScore>;
  characterID: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  proficient: Scalars['Boolean']['output'];
  skill: Skill;
  skillID: Scalars['ID']['output'];
};

/**
 * CharacterSkillWhereInput is used for filtering CharacterSkill objects.
 * Input was generated by ent.
 */
export type CharacterSkillWhereInput = {
  and?: InputMaybe<Array<CharacterSkillWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CharacterSkillWhereInput>;
  or?: InputMaybe<Array<CharacterSkillWhereInput>>;
  /** proficient field predicates */
  proficient?: InputMaybe<Scalars['Boolean']['input']>;
  proficientNEQ?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * CharacterWhereInput is used for filtering Character objects.
 * Input was generated by ent.
 */
export type CharacterWhereInput = {
  /** age field predicates */
  age?: InputMaybe<Scalars['Int']['input']>;
  ageGT?: InputMaybe<Scalars['Int']['input']>;
  ageGTE?: InputMaybe<Scalars['Int']['input']>;
  ageIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  ageLT?: InputMaybe<Scalars['Int']['input']>;
  ageLTE?: InputMaybe<Scalars['Int']['input']>;
  ageNEQ?: InputMaybe<Scalars['Int']['input']>;
  ageNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  and?: InputMaybe<Array<CharacterWhereInput>>;
  /** ability_scores edge predicates */
  hasAbilityScores?: InputMaybe<Scalars['Boolean']['input']>;
  hasAbilityScoresWith?: InputMaybe<Array<AbilityScoreWhereInput>>;
  /** alignment edge predicates */
  hasAlignment?: InputMaybe<Scalars['Boolean']['input']>;
  hasAlignmentWith?: InputMaybe<Array<AlignmentWhereInput>>;
  /** character_ability_scores edge predicates */
  hasCharacterAbilityScores?: InputMaybe<Scalars['Boolean']['input']>;
  hasCharacterAbilityScoresWith?: InputMaybe<Array<CharacterAbilityScoreWhereInput>>;
  /** character_skills edge predicates */
  hasCharacterSkills?: InputMaybe<Scalars['Boolean']['input']>;
  hasCharacterSkillsWith?: InputMaybe<Array<CharacterSkillWhereInput>>;
  /** class edge predicates */
  hasClass?: InputMaybe<Scalars['Boolean']['input']>;
  hasClassWith?: InputMaybe<Array<ClassWhereInput>>;
  /** proficiencies edge predicates */
  hasProficiencies?: InputMaybe<Scalars['Boolean']['input']>;
  hasProficienciesWith?: InputMaybe<Array<ProficiencyWhereInput>>;
  /** race edge predicates */
  hasRace?: InputMaybe<Scalars['Boolean']['input']>;
  hasRaceWith?: InputMaybe<Array<RaceWhereInput>>;
  /** skills edge predicates */
  hasSkills?: InputMaybe<Scalars['Boolean']['input']>;
  hasSkillsWith?: InputMaybe<Array<SkillWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** level field predicates */
  level?: InputMaybe<Scalars['Int']['input']>;
  levelGT?: InputMaybe<Scalars['Int']['input']>;
  levelGTE?: InputMaybe<Scalars['Int']['input']>;
  levelIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  levelLT?: InputMaybe<Scalars['Int']['input']>;
  levelLTE?: InputMaybe<Scalars['Int']['input']>;
  levelNEQ?: InputMaybe<Scalars['Int']['input']>;
  levelNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<CharacterWhereInput>;
  or?: InputMaybe<Array<CharacterWhereInput>>;
  /** proficiency_bonus field predicates */
  proficiencyBonus?: InputMaybe<Scalars['Int']['input']>;
  proficiencyBonusGT?: InputMaybe<Scalars['Int']['input']>;
  proficiencyBonusGTE?: InputMaybe<Scalars['Int']['input']>;
  proficiencyBonusIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  proficiencyBonusLT?: InputMaybe<Scalars['Int']['input']>;
  proficiencyBonusLTE?: InputMaybe<Scalars['Int']['input']>;
  proficiencyBonusNEQ?: InputMaybe<Scalars['Int']['input']>;
  proficiencyBonusNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type Class = Node & {
  __typename?: 'Class';
  characters?: Maybe<Array<Character>>;
  hitDie: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
  proficiencies?: Maybe<Array<Proficiency>>;
  proficiencyOptions?: Maybe<Array<ProficiencyChoice>>;
  savingThrows?: Maybe<Array<AbilityScore>>;
  startingEquipment?: Maybe<Array<EquipmentEntry>>;
};

/** Ordering options for Class connections */
export type ClassOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Classes. */
  field: ClassOrderField;
};

/** Properties by which Class connections can be ordered. */
export enum ClassOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * ClassWhereInput is used for filtering Class objects.
 * Input was generated by ent.
 */
export type ClassWhereInput = {
  and?: InputMaybe<Array<ClassWhereInput>>;
  /** characters edge predicates */
  hasCharacters?: InputMaybe<Scalars['Boolean']['input']>;
  hasCharactersWith?: InputMaybe<Array<CharacterWhereInput>>;
  /** proficiencies edge predicates */
  hasProficiencies?: InputMaybe<Scalars['Boolean']['input']>;
  hasProficienciesWith?: InputMaybe<Array<ProficiencyWhereInput>>;
  /** proficiency_options edge predicates */
  hasProficiencyOptions?: InputMaybe<Scalars['Boolean']['input']>;
  hasProficiencyOptionsWith?: InputMaybe<Array<ProficiencyChoiceWhereInput>>;
  /** saving_throws edge predicates */
  hasSavingThrows?: InputMaybe<Scalars['Boolean']['input']>;
  hasSavingThrowsWith?: InputMaybe<Array<AbilityScoreWhereInput>>;
  /** starting_equipment edge predicates */
  hasStartingEquipment?: InputMaybe<Scalars['Boolean']['input']>;
  hasStartingEquipmentWith?: InputMaybe<Array<EquipmentEntryWhereInput>>;
  /** hit_die field predicates */
  hitDie?: InputMaybe<Scalars['Int']['input']>;
  hitDieGT?: InputMaybe<Scalars['Int']['input']>;
  hitDieGTE?: InputMaybe<Scalars['Int']['input']>;
  hitDieIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  hitDieLT?: InputMaybe<Scalars['Int']['input']>;
  hitDieLTE?: InputMaybe<Scalars['Int']['input']>;
  hitDieNEQ?: InputMaybe<Scalars['Int']['input']>;
  hitDieNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ClassWhereInput>;
  or?: InputMaybe<Array<ClassWhereInput>>;
};

export type Coin = Node & {
  __typename?: 'Coin';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  goldConversionRate: Scalars['Float']['output'];
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

/** Ordering options for Coin connections */
export type CoinOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Coins. */
  field: CoinOrderField;
};

/** Properties by which Coin connections can be ordered. */
export enum CoinOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * CoinWhereInput is used for filtering Coin objects.
 * Input was generated by ent.
 */
export type CoinWhereInput = {
  and?: InputMaybe<Array<CoinWhereInput>>;
  /** gold_conversion_rate field predicates */
  goldConversionRate?: InputMaybe<Scalars['Float']['input']>;
  goldConversionRateGT?: InputMaybe<Scalars['Float']['input']>;
  goldConversionRateGTE?: InputMaybe<Scalars['Float']['input']>;
  goldConversionRateIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  goldConversionRateLT?: InputMaybe<Scalars['Float']['input']>;
  goldConversionRateLTE?: InputMaybe<Scalars['Float']['input']>;
  goldConversionRateNEQ?: InputMaybe<Scalars['Float']['input']>;
  goldConversionRateNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<CoinWhereInput>;
  or?: InputMaybe<Array<CoinWhereInput>>;
};

export type Condition = Node & {
  __typename?: 'Condition';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

/** Ordering options for Condition connections */
export type ConditionOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Conditions. */
  field: ConditionOrderField;
};

/** Properties by which Condition connections can be ordered. */
export enum ConditionOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * ConditionWhereInput is used for filtering Condition objects.
 * Input was generated by ent.
 */
export type ConditionWhereInput = {
  and?: InputMaybe<Array<ConditionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ConditionWhereInput>;
  or?: InputMaybe<Array<ConditionWhereInput>>;
};

export type Cost = Node & {
  __typename?: 'Cost';
  coin: Coin;
  equipment?: Maybe<Equipment>;
  id: Scalars['ID']['output'];
  quantity: Scalars['Int']['output'];
};

/**
 * CostWhereInput is used for filtering Cost objects.
 * Input was generated by ent.
 */
export type CostWhereInput = {
  and?: InputMaybe<Array<CostWhereInput>>;
  /** coin edge predicates */
  hasCoin?: InputMaybe<Scalars['Boolean']['input']>;
  hasCoinWith?: InputMaybe<Array<CoinWhereInput>>;
  /** equipment edge predicates */
  hasEquipment?: InputMaybe<Scalars['Boolean']['input']>;
  hasEquipmentWith?: InputMaybe<Array<EquipmentWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CostWhereInput>;
  or?: InputMaybe<Array<CostWhereInput>>;
  /** quantity field predicates */
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quantityGT?: InputMaybe<Scalars['Int']['input']>;
  quantityGTE?: InputMaybe<Scalars['Int']['input']>;
  quantityIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  quantityLT?: InputMaybe<Scalars['Int']['input']>;
  quantityLTE?: InputMaybe<Scalars['Int']['input']>;
  quantityNEQ?: InputMaybe<Scalars['Int']['input']>;
  quantityNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/**
 * CreateCharacterInput is used for create Character object.
 * Input was generated by ent.
 */
export type CreateCharacterInput = {
  abilityScoreIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  age?: InputMaybe<Scalars['Int']['input']>;
  alignmentID?: InputMaybe<Scalars['ID']['input']>;
  classID?: InputMaybe<Scalars['ID']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  proficiencyBonus?: InputMaybe<Scalars['Int']['input']>;
  proficiencyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  raceID?: InputMaybe<Scalars['ID']['input']>;
  skillIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type DamageType = Node & {
  __typename?: 'DamageType';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
  weapons?: Maybe<Array<Weapon>>;
};

/** Ordering options for DamageType connections */
export type DamageTypeOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order DamageTypes. */
  field: DamageTypeOrderField;
};

/** Properties by which DamageType connections can be ordered. */
export enum DamageTypeOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * DamageTypeWhereInput is used for filtering DamageType objects.
 * Input was generated by ent.
 */
export type DamageTypeWhereInput = {
  and?: InputMaybe<Array<DamageTypeWhereInput>>;
  /** weapons edge predicates */
  hasWeapons?: InputMaybe<Scalars['Boolean']['input']>;
  hasWeaponsWith?: InputMaybe<Array<WeaponWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<DamageTypeWhereInput>;
  or?: InputMaybe<Array<DamageTypeWhereInput>>;
};

export type Equipment = Node & {
  __typename?: 'Equipment';
  armor?: Maybe<Armor>;
  cost?: Maybe<Cost>;
  equipmentCategory: EquipmentEquipmentCategory;
  equipmentEntries?: Maybe<Array<EquipmentEntry>>;
  gear?: Maybe<Gear>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
  tool?: Maybe<Tool>;
  vehicle?: Maybe<Vehicle>;
  weapon?: Maybe<Weapon>;
  weight?: Maybe<Scalars['Float']['output']>;
};

/** A connection to a list of items. */
export type EquipmentConnection = {
  __typename?: 'EquipmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EquipmentEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EquipmentEdge = {
  __typename?: 'EquipmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Equipment>;
};

export type EquipmentEntry = Node & {
  __typename?: 'EquipmentEntry';
  class?: Maybe<Array<Class>>;
  equipment: Equipment;
  id: Scalars['ID']['output'];
  quantity: Scalars['Int']['output'];
};

/**
 * EquipmentEntryWhereInput is used for filtering EquipmentEntry objects.
 * Input was generated by ent.
 */
export type EquipmentEntryWhereInput = {
  and?: InputMaybe<Array<EquipmentEntryWhereInput>>;
  /** class edge predicates */
  hasClass?: InputMaybe<Scalars['Boolean']['input']>;
  hasClassWith?: InputMaybe<Array<ClassWhereInput>>;
  /** equipment edge predicates */
  hasEquipment?: InputMaybe<Scalars['Boolean']['input']>;
  hasEquipmentWith?: InputMaybe<Array<EquipmentWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<EquipmentEntryWhereInput>;
  or?: InputMaybe<Array<EquipmentEntryWhereInput>>;
  /** quantity field predicates */
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quantityGT?: InputMaybe<Scalars['Int']['input']>;
  quantityGTE?: InputMaybe<Scalars['Int']['input']>;
  quantityIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  quantityLT?: InputMaybe<Scalars['Int']['input']>;
  quantityLTE?: InputMaybe<Scalars['Int']['input']>;
  quantityNEQ?: InputMaybe<Scalars['Int']['input']>;
  quantityNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** EquipmentEquipmentCategory is enum for the field equipment_category */
export enum EquipmentEquipmentCategory {
  Armor = 'ARMOR',
  Gear = 'GEAR',
  Tool = 'TOOL',
  Vehicle = 'VEHICLE',
  Weapon = 'WEAPON'
}

/** Ordering options for Equipment connections */
export type EquipmentOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order EquipmentSlice. */
  field: EquipmentOrderField;
};

/** Properties by which Equipment connections can be ordered. */
export enum EquipmentOrderField {
  EquipmentCategory = 'EQUIPMENT_CATEGORY',
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * EquipmentWhereInput is used for filtering Equipment objects.
 * Input was generated by ent.
 */
export type EquipmentWhereInput = {
  and?: InputMaybe<Array<EquipmentWhereInput>>;
  /** equipment_category field predicates */
  equipmentCategory?: InputMaybe<EquipmentEquipmentCategory>;
  equipmentCategoryIn?: InputMaybe<Array<EquipmentEquipmentCategory>>;
  equipmentCategoryNEQ?: InputMaybe<EquipmentEquipmentCategory>;
  equipmentCategoryNotIn?: InputMaybe<Array<EquipmentEquipmentCategory>>;
  /** armor edge predicates */
  hasArmor?: InputMaybe<Scalars['Boolean']['input']>;
  hasArmorWith?: InputMaybe<Array<ArmorWhereInput>>;
  /** cost edge predicates */
  hasCost?: InputMaybe<Scalars['Boolean']['input']>;
  hasCostWith?: InputMaybe<Array<CostWhereInput>>;
  /** equipment_entries edge predicates */
  hasEquipmentEntries?: InputMaybe<Scalars['Boolean']['input']>;
  hasEquipmentEntriesWith?: InputMaybe<Array<EquipmentEntryWhereInput>>;
  /** gear edge predicates */
  hasGear?: InputMaybe<Scalars['Boolean']['input']>;
  hasGearWith?: InputMaybe<Array<GearWhereInput>>;
  /** tool edge predicates */
  hasTool?: InputMaybe<Scalars['Boolean']['input']>;
  hasToolWith?: InputMaybe<Array<ToolWhereInput>>;
  /** vehicle edge predicates */
  hasVehicle?: InputMaybe<Scalars['Boolean']['input']>;
  hasVehicleWith?: InputMaybe<Array<VehicleWhereInput>>;
  /** weapon edge predicates */
  hasWeapon?: InputMaybe<Scalars['Boolean']['input']>;
  hasWeaponWith?: InputMaybe<Array<WeaponWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<EquipmentWhereInput>;
  or?: InputMaybe<Array<EquipmentWhereInput>>;
  /** weight field predicates */
  weight?: InputMaybe<Scalars['Float']['input']>;
  weightGT?: InputMaybe<Scalars['Float']['input']>;
  weightGTE?: InputMaybe<Scalars['Float']['input']>;
  weightIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  weightIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  weightLT?: InputMaybe<Scalars['Float']['input']>;
  weightLTE?: InputMaybe<Scalars['Float']['input']>;
  weightNEQ?: InputMaybe<Scalars['Float']['input']>;
  weightNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  weightNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Feat = Node & {
  __typename?: 'Feat';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

/** Ordering options for Feat connections */
export type FeatOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Feats. */
  field: FeatOrderField;
};

/** Properties by which Feat connections can be ordered. */
export enum FeatOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * FeatWhereInput is used for filtering Feat objects.
 * Input was generated by ent.
 */
export type FeatWhereInput = {
  and?: InputMaybe<Array<FeatWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<FeatWhereInput>;
  or?: InputMaybe<Array<FeatWhereInput>>;
};

export type Feature = Node & {
  __typename?: 'Feature';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  level: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  prerequisites?: Maybe<Array<Prerequisite>>;
};

/** Ordering options for Feature connections */
export type FeatureOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Features. */
  field: FeatureOrderField;
};

/** Properties by which Feature connections can be ordered. */
export enum FeatureOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * FeatureWhereInput is used for filtering Feature objects.
 * Input was generated by ent.
 */
export type FeatureWhereInput = {
  and?: InputMaybe<Array<FeatureWhereInput>>;
  /** prerequisites edge predicates */
  hasPrerequisites?: InputMaybe<Scalars['Boolean']['input']>;
  hasPrerequisitesWith?: InputMaybe<Array<PrerequisiteWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** level field predicates */
  level?: InputMaybe<Scalars['Int']['input']>;
  levelGT?: InputMaybe<Scalars['Int']['input']>;
  levelGTE?: InputMaybe<Scalars['Int']['input']>;
  levelIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  levelLT?: InputMaybe<Scalars['Int']['input']>;
  levelLTE?: InputMaybe<Scalars['Int']['input']>;
  levelNEQ?: InputMaybe<Scalars['Int']['input']>;
  levelNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<FeatureWhereInput>;
  or?: InputMaybe<Array<FeatureWhereInput>>;
};

export type Gear = Node & {
  __typename?: 'Gear';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  equipment: Equipment;
  gearCategory: Scalars['String']['output'];
  id: Scalars['ID']['output'];
};

/**
 * GearWhereInput is used for filtering Gear objects.
 * Input was generated by ent.
 */
export type GearWhereInput = {
  and?: InputMaybe<Array<GearWhereInput>>;
  /** gear_category field predicates */
  gearCategory?: InputMaybe<Scalars['String']['input']>;
  gearCategoryContains?: InputMaybe<Scalars['String']['input']>;
  gearCategoryContainsFold?: InputMaybe<Scalars['String']['input']>;
  gearCategoryEqualFold?: InputMaybe<Scalars['String']['input']>;
  gearCategoryGT?: InputMaybe<Scalars['String']['input']>;
  gearCategoryGTE?: InputMaybe<Scalars['String']['input']>;
  gearCategoryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  gearCategoryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  gearCategoryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  gearCategoryLT?: InputMaybe<Scalars['String']['input']>;
  gearCategoryLTE?: InputMaybe<Scalars['String']['input']>;
  gearCategoryNEQ?: InputMaybe<Scalars['String']['input']>;
  gearCategoryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** equipment edge predicates */
  hasEquipment?: InputMaybe<Scalars['Boolean']['input']>;
  hasEquipmentWith?: InputMaybe<Array<EquipmentWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<GearWhereInput>;
  or?: InputMaybe<Array<GearWhereInput>>;
};

export type Language = Node & {
  __typename?: 'Language';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  languageType: LanguageLanguageType;
  name: Scalars['String']['output'];
  options?: Maybe<Array<LanguageChoice>>;
  race?: Maybe<Array<Race>>;
  script: LanguageScript;
};

export type LanguageChoice = Node & {
  __typename?: 'LanguageChoice';
  choose: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  languages?: Maybe<Array<Language>>;
  race?: Maybe<Race>;
};

/**
 * LanguageChoiceWhereInput is used for filtering LanguageChoice objects.
 * Input was generated by ent.
 */
export type LanguageChoiceWhereInput = {
  and?: InputMaybe<Array<LanguageChoiceWhereInput>>;
  /** choose field predicates */
  choose?: InputMaybe<Scalars['Int']['input']>;
  chooseGT?: InputMaybe<Scalars['Int']['input']>;
  chooseGTE?: InputMaybe<Scalars['Int']['input']>;
  chooseIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  chooseLT?: InputMaybe<Scalars['Int']['input']>;
  chooseLTE?: InputMaybe<Scalars['Int']['input']>;
  chooseNEQ?: InputMaybe<Scalars['Int']['input']>;
  chooseNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** languages edge predicates */
  hasLanguages?: InputMaybe<Scalars['Boolean']['input']>;
  hasLanguagesWith?: InputMaybe<Array<LanguageWhereInput>>;
  /** race edge predicates */
  hasRace?: InputMaybe<Scalars['Boolean']['input']>;
  hasRaceWith?: InputMaybe<Array<RaceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<LanguageChoiceWhereInput>;
  or?: InputMaybe<Array<LanguageChoiceWhereInput>>;
};

/** LanguageLanguageType is enum for the field language_type */
export enum LanguageLanguageType {
  Exotic = 'EXOTIC',
  Standard = 'STANDARD'
}

/** Ordering options for Language connections */
export type LanguageOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Languages. */
  field: LanguageOrderField;
};

/** Properties by which Language connections can be ordered. */
export enum LanguageOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/** LanguageScript is enum for the field script */
export enum LanguageScript {
  Abyssal = 'Abyssal',
  Celestial = 'Celestial',
  Common = 'Common',
  Draconic = 'Draconic',
  Dwarvish = 'Dwarvish',
  Elvish = 'Elvish',
  Giant = 'Giant',
  Gnomish = 'Gnomish',
  Goblin = 'Goblin',
  Halfling = 'Halfling',
  Infernal = 'Infernal',
  Orc = 'Orc',
  Other = 'Other'
}

/**
 * LanguageWhereInput is used for filtering Language objects.
 * Input was generated by ent.
 */
export type LanguageWhereInput = {
  and?: InputMaybe<Array<LanguageWhereInput>>;
  /** options edge predicates */
  hasOptions?: InputMaybe<Scalars['Boolean']['input']>;
  hasOptionsWith?: InputMaybe<Array<LanguageChoiceWhereInput>>;
  /** race edge predicates */
  hasRace?: InputMaybe<Scalars['Boolean']['input']>;
  hasRaceWith?: InputMaybe<Array<RaceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** language_type field predicates */
  languageType?: InputMaybe<LanguageLanguageType>;
  languageTypeIn?: InputMaybe<Array<LanguageLanguageType>>;
  languageTypeNEQ?: InputMaybe<LanguageLanguageType>;
  languageTypeNotIn?: InputMaybe<Array<LanguageLanguageType>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<LanguageWhereInput>;
  or?: InputMaybe<Array<LanguageWhereInput>>;
  /** script field predicates */
  script?: InputMaybe<LanguageScript>;
  scriptIn?: InputMaybe<Array<LanguageScript>>;
  scriptNEQ?: InputMaybe<LanguageScript>;
  scriptNotIn?: InputMaybe<Array<LanguageScript>>;
};

export type MagicSchool = Node & {
  __typename?: 'MagicSchool';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

/** Ordering options for MagicSchool connections */
export type MagicSchoolOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order MagicSchools. */
  field: MagicSchoolOrderField;
};

/** Properties by which MagicSchool connections can be ordered. */
export enum MagicSchoolOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * MagicSchoolWhereInput is used for filtering MagicSchool objects.
 * Input was generated by ent.
 */
export type MagicSchoolWhereInput = {
  and?: InputMaybe<Array<MagicSchoolWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<MagicSchoolWhereInput>;
  or?: InputMaybe<Array<MagicSchoolWhereInput>>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createCharacter: Character;
  updateCharacter: Character;
};


export type MutationCreateCharacterArgs = {
  input: CreateCharacterInput;
};


export type MutationUpdateCharacterArgs = {
  id: Scalars['ID']['input'];
  input: UpdateCharacterInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Prerequisite = Node & {
  __typename?: 'Prerequisite';
  feature?: Maybe<Feature>;
  featureValue?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  levelValue?: Maybe<Scalars['Int']['output']>;
  prerequisiteType: PrerequisitePrerequisiteType;
  spellValue?: Maybe<Scalars['String']['output']>;
};

/** PrerequisitePrerequisiteType is enum for the field prerequisite_type */
export enum PrerequisitePrerequisiteType {
  Feature = 'feature',
  Level = 'level',
  Spell = 'spell'
}

/**
 * PrerequisiteWhereInput is used for filtering Prerequisite objects.
 * Input was generated by ent.
 */
export type PrerequisiteWhereInput = {
  and?: InputMaybe<Array<PrerequisiteWhereInput>>;
  /** feature_value field predicates */
  featureValue?: InputMaybe<Scalars['String']['input']>;
  featureValueContains?: InputMaybe<Scalars['String']['input']>;
  featureValueContainsFold?: InputMaybe<Scalars['String']['input']>;
  featureValueEqualFold?: InputMaybe<Scalars['String']['input']>;
  featureValueGT?: InputMaybe<Scalars['String']['input']>;
  featureValueGTE?: InputMaybe<Scalars['String']['input']>;
  featureValueHasPrefix?: InputMaybe<Scalars['String']['input']>;
  featureValueHasSuffix?: InputMaybe<Scalars['String']['input']>;
  featureValueIn?: InputMaybe<Array<Scalars['String']['input']>>;
  featureValueIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  featureValueLT?: InputMaybe<Scalars['String']['input']>;
  featureValueLTE?: InputMaybe<Scalars['String']['input']>;
  featureValueNEQ?: InputMaybe<Scalars['String']['input']>;
  featureValueNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  featureValueNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** feature edge predicates */
  hasFeature?: InputMaybe<Scalars['Boolean']['input']>;
  hasFeatureWith?: InputMaybe<Array<FeatureWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** level_value field predicates */
  levelValue?: InputMaybe<Scalars['Int']['input']>;
  levelValueGT?: InputMaybe<Scalars['Int']['input']>;
  levelValueGTE?: InputMaybe<Scalars['Int']['input']>;
  levelValueIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  levelValueIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  levelValueLT?: InputMaybe<Scalars['Int']['input']>;
  levelValueLTE?: InputMaybe<Scalars['Int']['input']>;
  levelValueNEQ?: InputMaybe<Scalars['Int']['input']>;
  levelValueNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  levelValueNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<PrerequisiteWhereInput>;
  or?: InputMaybe<Array<PrerequisiteWhereInput>>;
  /** prerequisite_type field predicates */
  prerequisiteType?: InputMaybe<PrerequisitePrerequisiteType>;
  prerequisiteTypeIn?: InputMaybe<Array<PrerequisitePrerequisiteType>>;
  prerequisiteTypeNEQ?: InputMaybe<PrerequisitePrerequisiteType>;
  prerequisiteTypeNotIn?: InputMaybe<Array<PrerequisitePrerequisiteType>>;
  /** spell_value field predicates */
  spellValue?: InputMaybe<Scalars['String']['input']>;
  spellValueContains?: InputMaybe<Scalars['String']['input']>;
  spellValueContainsFold?: InputMaybe<Scalars['String']['input']>;
  spellValueEqualFold?: InputMaybe<Scalars['String']['input']>;
  spellValueGT?: InputMaybe<Scalars['String']['input']>;
  spellValueGTE?: InputMaybe<Scalars['String']['input']>;
  spellValueHasPrefix?: InputMaybe<Scalars['String']['input']>;
  spellValueHasSuffix?: InputMaybe<Scalars['String']['input']>;
  spellValueIn?: InputMaybe<Array<Scalars['String']['input']>>;
  spellValueIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  spellValueLT?: InputMaybe<Scalars['String']['input']>;
  spellValueLTE?: InputMaybe<Scalars['String']['input']>;
  spellValueNEQ?: InputMaybe<Scalars['String']['input']>;
  spellValueNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  spellValueNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Proficiency = Node & {
  __typename?: 'Proficiency';
  character?: Maybe<Array<Character>>;
  class?: Maybe<Array<Class>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
  options?: Maybe<Array<ProficiencyChoice>>;
  race?: Maybe<Array<Race>>;
  reference: Scalars['String']['output'];
};

export type ProficiencyChoice = Node & {
  __typename?: 'ProficiencyChoice';
  choose: Scalars['Int']['output'];
  class?: Maybe<Class>;
  desc: Array<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  proficiencies?: Maybe<Array<Proficiency>>;
  race?: Maybe<Race>;
};

/**
 * ProficiencyChoiceWhereInput is used for filtering ProficiencyChoice objects.
 * Input was generated by ent.
 */
export type ProficiencyChoiceWhereInput = {
  and?: InputMaybe<Array<ProficiencyChoiceWhereInput>>;
  /** choose field predicates */
  choose?: InputMaybe<Scalars['Int']['input']>;
  chooseGT?: InputMaybe<Scalars['Int']['input']>;
  chooseGTE?: InputMaybe<Scalars['Int']['input']>;
  chooseIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  chooseLT?: InputMaybe<Scalars['Int']['input']>;
  chooseLTE?: InputMaybe<Scalars['Int']['input']>;
  chooseNEQ?: InputMaybe<Scalars['Int']['input']>;
  chooseNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** class edge predicates */
  hasClass?: InputMaybe<Scalars['Boolean']['input']>;
  hasClassWith?: InputMaybe<Array<ClassWhereInput>>;
  /** proficiencies edge predicates */
  hasProficiencies?: InputMaybe<Scalars['Boolean']['input']>;
  hasProficienciesWith?: InputMaybe<Array<ProficiencyWhereInput>>;
  /** race edge predicates */
  hasRace?: InputMaybe<Scalars['Boolean']['input']>;
  hasRaceWith?: InputMaybe<Array<RaceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<ProficiencyChoiceWhereInput>;
  or?: InputMaybe<Array<ProficiencyChoiceWhereInput>>;
};

/** Ordering options for Proficiency connections */
export type ProficiencyOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Proficiencies. */
  field: ProficiencyOrderField;
};

/** Properties by which Proficiency connections can be ordered. */
export enum ProficiencyOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * ProficiencyWhereInput is used for filtering Proficiency objects.
 * Input was generated by ent.
 */
export type ProficiencyWhereInput = {
  and?: InputMaybe<Array<ProficiencyWhereInput>>;
  /** character edge predicates */
  hasCharacter?: InputMaybe<Scalars['Boolean']['input']>;
  hasCharacterWith?: InputMaybe<Array<CharacterWhereInput>>;
  /** class edge predicates */
  hasClass?: InputMaybe<Scalars['Boolean']['input']>;
  hasClassWith?: InputMaybe<Array<ClassWhereInput>>;
  /** options edge predicates */
  hasOptions?: InputMaybe<Scalars['Boolean']['input']>;
  hasOptionsWith?: InputMaybe<Array<ProficiencyChoiceWhereInput>>;
  /** race edge predicates */
  hasRace?: InputMaybe<Scalars['Boolean']['input']>;
  hasRaceWith?: InputMaybe<Array<RaceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ProficiencyWhereInput>;
  or?: InputMaybe<Array<ProficiencyWhereInput>>;
  /** reference field predicates */
  reference?: InputMaybe<Scalars['String']['input']>;
  referenceContains?: InputMaybe<Scalars['String']['input']>;
  referenceContainsFold?: InputMaybe<Scalars['String']['input']>;
  referenceEqualFold?: InputMaybe<Scalars['String']['input']>;
  referenceGT?: InputMaybe<Scalars['String']['input']>;
  referenceGTE?: InputMaybe<Scalars['String']['input']>;
  referenceHasPrefix?: InputMaybe<Scalars['String']['input']>;
  referenceHasSuffix?: InputMaybe<Scalars['String']['input']>;
  referenceIn?: InputMaybe<Array<Scalars['String']['input']>>;
  referenceLT?: InputMaybe<Scalars['String']['input']>;
  referenceLTE?: InputMaybe<Scalars['String']['input']>;
  referenceNEQ?: InputMaybe<Scalars['String']['input']>;
  referenceNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Property = Node & {
  __typename?: 'Property';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
  weapons?: Maybe<Array<Weapon>>;
};

/** Ordering options for Property connections */
export type PropertyOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Properties. */
  field: PropertyOrderField;
};

/** Properties by which Property connections can be ordered. */
export enum PropertyOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * PropertyWhereInput is used for filtering Property objects.
 * Input was generated by ent.
 */
export type PropertyWhereInput = {
  and?: InputMaybe<Array<PropertyWhereInput>>;
  /** weapons edge predicates */
  hasWeapons?: InputMaybe<Scalars['Boolean']['input']>;
  hasWeaponsWith?: InputMaybe<Array<WeaponWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<PropertyWhereInput>;
  or?: InputMaybe<Array<PropertyWhereInput>>;
};

export type Query = {
  __typename?: 'Query';
  abilityScores: Array<AbilityScore>;
  alignments: Array<Alignment>;
  characters: CharacterConnection;
  classes: Array<Class>;
  coins: Array<Coin>;
  conditions: Array<Condition>;
  damageTypes: Array<DamageType>;
  equipments: EquipmentConnection;
  feats: Array<Feat>;
  features: Array<Feature>;
  languages: Array<Language>;
  magicSchools: Array<MagicSchool>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  properties: Array<Property>;
  races: Array<Race>;
  ruleSections: Array<RuleSection>;
  rules: Array<Rule>;
  skills: Array<Skill>;
};


export type QueryCharactersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<CharacterOrder>;
  where?: InputMaybe<CharacterWhereInput>;
};


export type QueryEquipmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EquipmentOrder>;
  where?: InputMaybe<EquipmentWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};

export type Race = Node & {
  __typename?: 'Race';
  abilityBonuses?: Maybe<Array<AbilityScore>>;
  ageDesc: Scalars['String']['output'];
  alignmentDesc: Scalars['String']['output'];
  characters?: Maybe<Array<Character>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  languageDesc: Scalars['String']['output'];
  languageOptions?: Maybe<LanguageChoice>;
  languages?: Maybe<Array<Language>>;
  name: Scalars['String']['output'];
  size: RaceSize;
  sizeDesc: Scalars['String']['output'];
  speed: Scalars['Int']['output'];
  startingProficiencies?: Maybe<Array<Proficiency>>;
  startingProficiencyOptions?: Maybe<ProficiencyChoice>;
  traits?: Maybe<Array<Trait>>;
};

/** Ordering options for Race connections */
export type RaceOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Races. */
  field: RaceOrderField;
};

/** Properties by which Race connections can be ordered. */
export enum RaceOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/** RaceSize is enum for the field size */
export enum RaceSize {
  Large = 'Large',
  Medium = 'Medium',
  Small = 'Small'
}

/**
 * RaceWhereInput is used for filtering Race objects.
 * Input was generated by ent.
 */
export type RaceWhereInput = {
  /** age_desc field predicates */
  ageDesc?: InputMaybe<Scalars['String']['input']>;
  ageDescContains?: InputMaybe<Scalars['String']['input']>;
  ageDescContainsFold?: InputMaybe<Scalars['String']['input']>;
  ageDescEqualFold?: InputMaybe<Scalars['String']['input']>;
  ageDescGT?: InputMaybe<Scalars['String']['input']>;
  ageDescGTE?: InputMaybe<Scalars['String']['input']>;
  ageDescHasPrefix?: InputMaybe<Scalars['String']['input']>;
  ageDescHasSuffix?: InputMaybe<Scalars['String']['input']>;
  ageDescIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ageDescLT?: InputMaybe<Scalars['String']['input']>;
  ageDescLTE?: InputMaybe<Scalars['String']['input']>;
  ageDescNEQ?: InputMaybe<Scalars['String']['input']>;
  ageDescNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** alignment_desc field predicates */
  alignmentDesc?: InputMaybe<Scalars['String']['input']>;
  alignmentDescContains?: InputMaybe<Scalars['String']['input']>;
  alignmentDescContainsFold?: InputMaybe<Scalars['String']['input']>;
  alignmentDescEqualFold?: InputMaybe<Scalars['String']['input']>;
  alignmentDescGT?: InputMaybe<Scalars['String']['input']>;
  alignmentDescGTE?: InputMaybe<Scalars['String']['input']>;
  alignmentDescHasPrefix?: InputMaybe<Scalars['String']['input']>;
  alignmentDescHasSuffix?: InputMaybe<Scalars['String']['input']>;
  alignmentDescIn?: InputMaybe<Array<Scalars['String']['input']>>;
  alignmentDescLT?: InputMaybe<Scalars['String']['input']>;
  alignmentDescLTE?: InputMaybe<Scalars['String']['input']>;
  alignmentDescNEQ?: InputMaybe<Scalars['String']['input']>;
  alignmentDescNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  and?: InputMaybe<Array<RaceWhereInput>>;
  /** ability_bonuses edge predicates */
  hasAbilityBonuses?: InputMaybe<Scalars['Boolean']['input']>;
  hasAbilityBonusesWith?: InputMaybe<Array<AbilityScoreWhereInput>>;
  /** characters edge predicates */
  hasCharacters?: InputMaybe<Scalars['Boolean']['input']>;
  hasCharactersWith?: InputMaybe<Array<CharacterWhereInput>>;
  /** language_options edge predicates */
  hasLanguageOptions?: InputMaybe<Scalars['Boolean']['input']>;
  hasLanguageOptionsWith?: InputMaybe<Array<LanguageChoiceWhereInput>>;
  /** languages edge predicates */
  hasLanguages?: InputMaybe<Scalars['Boolean']['input']>;
  hasLanguagesWith?: InputMaybe<Array<LanguageWhereInput>>;
  /** starting_proficiencies edge predicates */
  hasStartingProficiencies?: InputMaybe<Scalars['Boolean']['input']>;
  hasStartingProficienciesWith?: InputMaybe<Array<ProficiencyWhereInput>>;
  /** starting_proficiency_options edge predicates */
  hasStartingProficiencyOptions?: InputMaybe<Scalars['Boolean']['input']>;
  hasStartingProficiencyOptionsWith?: InputMaybe<Array<ProficiencyChoiceWhereInput>>;
  /** traits edge predicates */
  hasTraits?: InputMaybe<Scalars['Boolean']['input']>;
  hasTraitsWith?: InputMaybe<Array<TraitWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** language_desc field predicates */
  languageDesc?: InputMaybe<Scalars['String']['input']>;
  languageDescContains?: InputMaybe<Scalars['String']['input']>;
  languageDescContainsFold?: InputMaybe<Scalars['String']['input']>;
  languageDescEqualFold?: InputMaybe<Scalars['String']['input']>;
  languageDescGT?: InputMaybe<Scalars['String']['input']>;
  languageDescGTE?: InputMaybe<Scalars['String']['input']>;
  languageDescHasPrefix?: InputMaybe<Scalars['String']['input']>;
  languageDescHasSuffix?: InputMaybe<Scalars['String']['input']>;
  languageDescIn?: InputMaybe<Array<Scalars['String']['input']>>;
  languageDescLT?: InputMaybe<Scalars['String']['input']>;
  languageDescLTE?: InputMaybe<Scalars['String']['input']>;
  languageDescNEQ?: InputMaybe<Scalars['String']['input']>;
  languageDescNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<RaceWhereInput>;
  or?: InputMaybe<Array<RaceWhereInput>>;
  /** size field predicates */
  size?: InputMaybe<RaceSize>;
  /** size_desc field predicates */
  sizeDesc?: InputMaybe<Scalars['String']['input']>;
  sizeDescContains?: InputMaybe<Scalars['String']['input']>;
  sizeDescContainsFold?: InputMaybe<Scalars['String']['input']>;
  sizeDescEqualFold?: InputMaybe<Scalars['String']['input']>;
  sizeDescGT?: InputMaybe<Scalars['String']['input']>;
  sizeDescGTE?: InputMaybe<Scalars['String']['input']>;
  sizeDescHasPrefix?: InputMaybe<Scalars['String']['input']>;
  sizeDescHasSuffix?: InputMaybe<Scalars['String']['input']>;
  sizeDescIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sizeDescLT?: InputMaybe<Scalars['String']['input']>;
  sizeDescLTE?: InputMaybe<Scalars['String']['input']>;
  sizeDescNEQ?: InputMaybe<Scalars['String']['input']>;
  sizeDescNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sizeIn?: InputMaybe<Array<RaceSize>>;
  sizeNEQ?: InputMaybe<RaceSize>;
  sizeNotIn?: InputMaybe<Array<RaceSize>>;
  /** speed field predicates */
  speed?: InputMaybe<Scalars['Int']['input']>;
  speedGT?: InputMaybe<Scalars['Int']['input']>;
  speedGTE?: InputMaybe<Scalars['Int']['input']>;
  speedIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  speedLT?: InputMaybe<Scalars['Int']['input']>;
  speedLTE?: InputMaybe<Scalars['Int']['input']>;
  speedNEQ?: InputMaybe<Scalars['Int']['input']>;
  speedNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type Rule = Node & {
  __typename?: 'Rule';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
  sections?: Maybe<Array<RuleSection>>;
};

/** Ordering options for Rule connections */
export type RuleOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Rules. */
  field: RuleOrderField;
};

/** Properties by which Rule connections can be ordered. */
export enum RuleOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

export type RuleSection = Node & {
  __typename?: 'RuleSection';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
  rule?: Maybe<Rule>;
};

/** Ordering options for RuleSection connections */
export type RuleSectionOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order RuleSections. */
  field: RuleSectionOrderField;
};

/** Properties by which RuleSection connections can be ordered. */
export enum RuleSectionOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * RuleSectionWhereInput is used for filtering RuleSection objects.
 * Input was generated by ent.
 */
export type RuleSectionWhereInput = {
  and?: InputMaybe<Array<RuleSectionWhereInput>>;
  /** rule edge predicates */
  hasRule?: InputMaybe<Scalars['Boolean']['input']>;
  hasRuleWith?: InputMaybe<Array<RuleWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<RuleSectionWhereInput>;
  or?: InputMaybe<Array<RuleSectionWhereInput>>;
};

/**
 * RuleWhereInput is used for filtering Rule objects.
 * Input was generated by ent.
 */
export type RuleWhereInput = {
  and?: InputMaybe<Array<RuleWhereInput>>;
  /** sections edge predicates */
  hasSections?: InputMaybe<Scalars['Boolean']['input']>;
  hasSectionsWith?: InputMaybe<Array<RuleSectionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<RuleWhereInput>;
  or?: InputMaybe<Array<RuleWhereInput>>;
};

export type Skill = Node & {
  __typename?: 'Skill';
  abilityScore?: Maybe<AbilityScore>;
  characterSkills?: Maybe<Array<CharacterSkill>>;
  characters?: Maybe<Array<Character>>;
  desc?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

/** Ordering options for Skill connections */
export type SkillOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Skills. */
  field: SkillOrderField;
};

/** Properties by which Skill connections can be ordered. */
export enum SkillOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * SkillWhereInput is used for filtering Skill objects.
 * Input was generated by ent.
 */
export type SkillWhereInput = {
  and?: InputMaybe<Array<SkillWhereInput>>;
  /** ability_score edge predicates */
  hasAbilityScore?: InputMaybe<Scalars['Boolean']['input']>;
  hasAbilityScoreWith?: InputMaybe<Array<AbilityScoreWhereInput>>;
  /** character_skills edge predicates */
  hasCharacterSkills?: InputMaybe<Scalars['Boolean']['input']>;
  hasCharacterSkillsWith?: InputMaybe<Array<CharacterSkillWhereInput>>;
  /** characters edge predicates */
  hasCharacters?: InputMaybe<Scalars['Boolean']['input']>;
  hasCharactersWith?: InputMaybe<Array<CharacterWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<SkillWhereInput>;
  or?: InputMaybe<Array<SkillWhereInput>>;
};

export type Tool = Node & {
  __typename?: 'Tool';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  equipment: Equipment;
  id: Scalars['ID']['output'];
  toolCategory: Scalars['String']['output'];
};

/**
 * ToolWhereInput is used for filtering Tool objects.
 * Input was generated by ent.
 */
export type ToolWhereInput = {
  and?: InputMaybe<Array<ToolWhereInput>>;
  /** equipment edge predicates */
  hasEquipment?: InputMaybe<Scalars['Boolean']['input']>;
  hasEquipmentWith?: InputMaybe<Array<EquipmentWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<ToolWhereInput>;
  or?: InputMaybe<Array<ToolWhereInput>>;
  /** tool_category field predicates */
  toolCategory?: InputMaybe<Scalars['String']['input']>;
  toolCategoryContains?: InputMaybe<Scalars['String']['input']>;
  toolCategoryContainsFold?: InputMaybe<Scalars['String']['input']>;
  toolCategoryEqualFold?: InputMaybe<Scalars['String']['input']>;
  toolCategoryGT?: InputMaybe<Scalars['String']['input']>;
  toolCategoryGTE?: InputMaybe<Scalars['String']['input']>;
  toolCategoryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  toolCategoryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  toolCategoryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  toolCategoryLT?: InputMaybe<Scalars['String']['input']>;
  toolCategoryLTE?: InputMaybe<Scalars['String']['input']>;
  toolCategoryNEQ?: InputMaybe<Scalars['String']['input']>;
  toolCategoryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Trait = Node & {
  __typename?: 'Trait';
  desc?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['ID']['output'];
  indx: Scalars['String']['output'];
  name: Scalars['String']['output'];
  race?: Maybe<Array<Race>>;
};

/** Ordering options for Trait connections */
export type TraitOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Traits. */
  field: TraitOrderField;
};

/** Properties by which Trait connections can be ordered. */
export enum TraitOrderField {
  Indx = 'INDX',
  Name = 'NAME'
}

/**
 * TraitWhereInput is used for filtering Trait objects.
 * Input was generated by ent.
 */
export type TraitWhereInput = {
  and?: InputMaybe<Array<TraitWhereInput>>;
  /** race edge predicates */
  hasRace?: InputMaybe<Scalars['Boolean']['input']>;
  hasRaceWith?: InputMaybe<Array<RaceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** indx field predicates */
  indx?: InputMaybe<Scalars['String']['input']>;
  indxContains?: InputMaybe<Scalars['String']['input']>;
  indxContainsFold?: InputMaybe<Scalars['String']['input']>;
  indxEqualFold?: InputMaybe<Scalars['String']['input']>;
  indxGT?: InputMaybe<Scalars['String']['input']>;
  indxGTE?: InputMaybe<Scalars['String']['input']>;
  indxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  indxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  indxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  indxLT?: InputMaybe<Scalars['String']['input']>;
  indxLTE?: InputMaybe<Scalars['String']['input']>;
  indxNEQ?: InputMaybe<Scalars['String']['input']>;
  indxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<TraitWhereInput>;
  or?: InputMaybe<Array<TraitWhereInput>>;
};

/**
 * UpdateCharacterInput is used for update Character object.
 * Input was generated by ent.
 */
export type UpdateCharacterInput = {
  addAbilityScoreIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addProficiencyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addSkillIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  age?: InputMaybe<Scalars['Int']['input']>;
  alignmentID?: InputMaybe<Scalars['ID']['input']>;
  classID?: InputMaybe<Scalars['ID']['input']>;
  clearAbilityScores?: InputMaybe<Scalars['Boolean']['input']>;
  clearAlignment?: InputMaybe<Scalars['Boolean']['input']>;
  clearClass?: InputMaybe<Scalars['Boolean']['input']>;
  clearProficiencies?: InputMaybe<Scalars['Boolean']['input']>;
  clearRace?: InputMaybe<Scalars['Boolean']['input']>;
  clearSkills?: InputMaybe<Scalars['Boolean']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  proficiencyBonus?: InputMaybe<Scalars['Int']['input']>;
  raceID?: InputMaybe<Scalars['ID']['input']>;
  removeAbilityScoreIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeProficiencyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeSkillIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type Vehicle = Node & {
  __typename?: 'Vehicle';
  capacity?: Maybe<Scalars['String']['output']>;
  desc?: Maybe<Array<Scalars['String']['output']>>;
  equipment: Equipment;
  id: Scalars['ID']['output'];
  speedQuantity?: Maybe<Scalars['Float']['output']>;
  speedUnits?: Maybe<VehicleSpeedUnits>;
  vehicleCategory: VehicleVehicleCategory;
};

/** VehicleSpeedUnits is enum for the field speed_units */
export enum VehicleSpeedUnits {
  FeetPerRound = 'feet_per_round',
  MilesPerHour = 'miles_per_hour'
}

/** VehicleVehicleCategory is enum for the field vehicle_category */
export enum VehicleVehicleCategory {
  MountsAndOtherAnimals = 'mounts_and_other_animals',
  TackHarnessAndDrawnVehicles = 'tack_harness_and_drawn_vehicles',
  Waterborne = 'waterborne'
}

/**
 * VehicleWhereInput is used for filtering Vehicle objects.
 * Input was generated by ent.
 */
export type VehicleWhereInput = {
  and?: InputMaybe<Array<VehicleWhereInput>>;
  /** capacity field predicates */
  capacity?: InputMaybe<Scalars['String']['input']>;
  capacityContains?: InputMaybe<Scalars['String']['input']>;
  capacityContainsFold?: InputMaybe<Scalars['String']['input']>;
  capacityEqualFold?: InputMaybe<Scalars['String']['input']>;
  capacityGT?: InputMaybe<Scalars['String']['input']>;
  capacityGTE?: InputMaybe<Scalars['String']['input']>;
  capacityHasPrefix?: InputMaybe<Scalars['String']['input']>;
  capacityHasSuffix?: InputMaybe<Scalars['String']['input']>;
  capacityIn?: InputMaybe<Array<Scalars['String']['input']>>;
  capacityIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  capacityLT?: InputMaybe<Scalars['String']['input']>;
  capacityLTE?: InputMaybe<Scalars['String']['input']>;
  capacityNEQ?: InputMaybe<Scalars['String']['input']>;
  capacityNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  capacityNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** equipment edge predicates */
  hasEquipment?: InputMaybe<Scalars['Boolean']['input']>;
  hasEquipmentWith?: InputMaybe<Array<EquipmentWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<VehicleWhereInput>;
  or?: InputMaybe<Array<VehicleWhereInput>>;
  /** speed_quantity field predicates */
  speedQuantity?: InputMaybe<Scalars['Float']['input']>;
  speedQuantityGT?: InputMaybe<Scalars['Float']['input']>;
  speedQuantityGTE?: InputMaybe<Scalars['Float']['input']>;
  speedQuantityIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  speedQuantityIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  speedQuantityLT?: InputMaybe<Scalars['Float']['input']>;
  speedQuantityLTE?: InputMaybe<Scalars['Float']['input']>;
  speedQuantityNEQ?: InputMaybe<Scalars['Float']['input']>;
  speedQuantityNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  speedQuantityNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** speed_units field predicates */
  speedUnits?: InputMaybe<VehicleSpeedUnits>;
  speedUnitsIn?: InputMaybe<Array<VehicleSpeedUnits>>;
  speedUnitsIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  speedUnitsNEQ?: InputMaybe<VehicleSpeedUnits>;
  speedUnitsNotIn?: InputMaybe<Array<VehicleSpeedUnits>>;
  speedUnitsNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** vehicle_category field predicates */
  vehicleCategory?: InputMaybe<VehicleVehicleCategory>;
  vehicleCategoryIn?: InputMaybe<Array<VehicleVehicleCategory>>;
  vehicleCategoryNEQ?: InputMaybe<VehicleVehicleCategory>;
  vehicleCategoryNotIn?: InputMaybe<Array<VehicleVehicleCategory>>;
};

export type Weapon = Node & {
  __typename?: 'Weapon';
  damageDice?: Maybe<Scalars['String']['output']>;
  damageType?: Maybe<DamageType>;
  equipment: Equipment;
  id: Scalars['ID']['output'];
  properties?: Maybe<Array<Property>>;
  rangeLong?: Maybe<Scalars['Int']['output']>;
  rangeNormal?: Maybe<Scalars['Int']['output']>;
  throwRangeLong?: Maybe<Scalars['Int']['output']>;
  throwRangeNormal?: Maybe<Scalars['Int']['output']>;
  weaponCategory: WeaponWeaponCategory;
  weaponSubcategory: WeaponWeaponSubcategory;
};

/** WeaponWeaponCategory is enum for the field weapon_category */
export enum WeaponWeaponCategory {
  Exotic = 'exotic',
  Martial = 'martial',
  Other = 'other',
  Simple = 'simple'
}

/** WeaponWeaponSubcategory is enum for the field weapon_subcategory */
export enum WeaponWeaponSubcategory {
  Melee = 'melee',
  Other = 'other',
  Ranged = 'ranged'
}

/**
 * WeaponWhereInput is used for filtering Weapon objects.
 * Input was generated by ent.
 */
export type WeaponWhereInput = {
  and?: InputMaybe<Array<WeaponWhereInput>>;
  /** damage_dice field predicates */
  damageDice?: InputMaybe<Scalars['String']['input']>;
  damageDiceContains?: InputMaybe<Scalars['String']['input']>;
  damageDiceContainsFold?: InputMaybe<Scalars['String']['input']>;
  damageDiceEqualFold?: InputMaybe<Scalars['String']['input']>;
  damageDiceGT?: InputMaybe<Scalars['String']['input']>;
  damageDiceGTE?: InputMaybe<Scalars['String']['input']>;
  damageDiceHasPrefix?: InputMaybe<Scalars['String']['input']>;
  damageDiceHasSuffix?: InputMaybe<Scalars['String']['input']>;
  damageDiceIn?: InputMaybe<Array<Scalars['String']['input']>>;
  damageDiceIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  damageDiceLT?: InputMaybe<Scalars['String']['input']>;
  damageDiceLTE?: InputMaybe<Scalars['String']['input']>;
  damageDiceNEQ?: InputMaybe<Scalars['String']['input']>;
  damageDiceNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  damageDiceNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** damage_type edge predicates */
  hasDamageType?: InputMaybe<Scalars['Boolean']['input']>;
  hasDamageTypeWith?: InputMaybe<Array<DamageTypeWhereInput>>;
  /** equipment edge predicates */
  hasEquipment?: InputMaybe<Scalars['Boolean']['input']>;
  hasEquipmentWith?: InputMaybe<Array<EquipmentWhereInput>>;
  /** properties edge predicates */
  hasProperties?: InputMaybe<Scalars['Boolean']['input']>;
  hasPropertiesWith?: InputMaybe<Array<PropertyWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<WeaponWhereInput>;
  or?: InputMaybe<Array<WeaponWhereInput>>;
  /** range_long field predicates */
  rangeLong?: InputMaybe<Scalars['Int']['input']>;
  rangeLongGT?: InputMaybe<Scalars['Int']['input']>;
  rangeLongGTE?: InputMaybe<Scalars['Int']['input']>;
  rangeLongIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  rangeLongIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  rangeLongLT?: InputMaybe<Scalars['Int']['input']>;
  rangeLongLTE?: InputMaybe<Scalars['Int']['input']>;
  rangeLongNEQ?: InputMaybe<Scalars['Int']['input']>;
  rangeLongNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  rangeLongNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** range_normal field predicates */
  rangeNormal?: InputMaybe<Scalars['Int']['input']>;
  rangeNormalGT?: InputMaybe<Scalars['Int']['input']>;
  rangeNormalGTE?: InputMaybe<Scalars['Int']['input']>;
  rangeNormalIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  rangeNormalIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  rangeNormalLT?: InputMaybe<Scalars['Int']['input']>;
  rangeNormalLTE?: InputMaybe<Scalars['Int']['input']>;
  rangeNormalNEQ?: InputMaybe<Scalars['Int']['input']>;
  rangeNormalNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  rangeNormalNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** throw_range_long field predicates */
  throwRangeLong?: InputMaybe<Scalars['Int']['input']>;
  throwRangeLongGT?: InputMaybe<Scalars['Int']['input']>;
  throwRangeLongGTE?: InputMaybe<Scalars['Int']['input']>;
  throwRangeLongIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  throwRangeLongIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  throwRangeLongLT?: InputMaybe<Scalars['Int']['input']>;
  throwRangeLongLTE?: InputMaybe<Scalars['Int']['input']>;
  throwRangeLongNEQ?: InputMaybe<Scalars['Int']['input']>;
  throwRangeLongNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  throwRangeLongNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** throw_range_normal field predicates */
  throwRangeNormal?: InputMaybe<Scalars['Int']['input']>;
  throwRangeNormalGT?: InputMaybe<Scalars['Int']['input']>;
  throwRangeNormalGTE?: InputMaybe<Scalars['Int']['input']>;
  throwRangeNormalIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  throwRangeNormalIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  throwRangeNormalLT?: InputMaybe<Scalars['Int']['input']>;
  throwRangeNormalLTE?: InputMaybe<Scalars['Int']['input']>;
  throwRangeNormalNEQ?: InputMaybe<Scalars['Int']['input']>;
  throwRangeNormalNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  throwRangeNormalNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** weapon_category field predicates */
  weaponCategory?: InputMaybe<WeaponWeaponCategory>;
  weaponCategoryIn?: InputMaybe<Array<WeaponWeaponCategory>>;
  weaponCategoryNEQ?: InputMaybe<WeaponWeaponCategory>;
  weaponCategoryNotIn?: InputMaybe<Array<WeaponWeaponCategory>>;
  /** weapon_subcategory field predicates */
  weaponSubcategory?: InputMaybe<WeaponWeaponSubcategory>;
  weaponSubcategoryIn?: InputMaybe<Array<WeaponWeaponSubcategory>>;
  weaponSubcategoryNEQ?: InputMaybe<WeaponWeaponSubcategory>;
  weaponSubcategoryNotIn?: InputMaybe<Array<WeaponWeaponSubcategory>>;
};

export type GetAbilityScoresQueryVariables = Exact<{
  characterId: Scalars['ID']['input'];
}>;


export type GetAbilityScoresQuery = { __typename?: 'Query', characters: { __typename?: 'CharacterConnection', edges?: Array<{ __typename?: 'CharacterEdge', node?: { __typename?: 'Character', id: string, characterAbilityScores?: Array<{ __typename?: 'CharacterAbilityScore', id: string, score: number, modifier: number, abilityScore: { __typename?: 'AbilityScore', id: string, indx: string, name: string }, characterSkills?: Array<{ __typename?: 'CharacterSkill', id: string, proficient: boolean, skill: { __typename?: 'Skill', id: string, indx: string, name: string } }> | null }> | null } | null } | null> | null } };

export type GetCharactersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCharactersQuery = { __typename?: 'Query', characters: { __typename?: 'CharacterConnection', edges?: Array<{ __typename?: 'CharacterEdge', node?: { __typename?: 'Character', id: string, name: string, age: number, level: number, proficiencyBonus: number, class?: { __typename?: 'Class', id: string, indx: string, name: string } | null, race?: { __typename?: 'Race', id: string, indx: string, name: string } | null, alignment?: { __typename?: 'Alignment', id: string, indx: string, name: string } | null, characterAbilityScores?: Array<{ __typename?: 'CharacterAbilityScore', id: string, score: number, modifier: number, abilityScore: { __typename?: 'AbilityScore', id: string, indx: string, name: string } }> | null, characterSkills?: Array<{ __typename?: 'CharacterSkill', id: string, proficient: boolean, skill: { __typename?: 'Skill', id: string, indx: string, name: string }, characterAbilityScore?: { __typename?: 'CharacterAbilityScore', id: string, score: number, modifier: number, abilityScore: { __typename?: 'AbilityScore', id: string, indx: string, name: string } } | null }> | null } | null } | null> | null } };

export type GetClassesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetClassesQuery = { __typename?: 'Query', classes: Array<{ __typename?: 'Class', id: string, indx: string, name: string }> };

export type GetRacesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetRacesQuery = { __typename?: 'Query', races: Array<{ __typename?: 'Race', id: string, indx: string, name: string }> };

export type UpdateCharacterMutationVariables = Exact<{
  updateCharacterId: Scalars['ID']['input'];
  input: UpdateCharacterInput;
}>;


export type UpdateCharacterMutation = { __typename?: 'Mutation', updateCharacter: { __typename?: 'Character', id: string, name: string, age: number, level: number, race?: { __typename?: 'Race', id: string, indx: string, name: string } | null, class?: { __typename?: 'Class', id: string, indx: string, name: string } | null } };


export const GetAbilityScoresDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetAbilityScores"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"characterId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"characters"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"characterId"}}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"characterAbilityScores"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"score"}},{"kind":"Field","name":{"kind":"Name","value":"modifier"}},{"kind":"Field","name":{"kind":"Name","value":"abilityScore"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"indx"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","name":{"kind":"Name","value":"characterSkills"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"proficient"}},{"kind":"Field","name":{"kind":"Name","value":"skill"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"indx"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<GetAbilityScoresQuery, GetAbilityScoresQueryVariables>;
export const GetCharactersDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetCharacters"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"characters"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"age"}},{"kind":"Field","name":{"kind":"Name","value":"level"}},{"kind":"Field","name":{"kind":"Name","value":"proficiencyBonus"}},{"kind":"Field","name":{"kind":"Name","value":"class"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"indx"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","name":{"kind":"Name","value":"race"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"indx"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","name":{"kind":"Name","value":"alignment"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"indx"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","name":{"kind":"Name","value":"characterAbilityScores"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"score"}},{"kind":"Field","name":{"kind":"Name","value":"modifier"}},{"kind":"Field","name":{"kind":"Name","value":"abilityScore"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"indx"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}},{"kind":"Field","name":{"kind":"Name","value":"characterSkills"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"proficient"}},{"kind":"Field","name":{"kind":"Name","value":"skill"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"indx"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","name":{"kind":"Name","value":"characterAbilityScore"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"score"}},{"kind":"Field","name":{"kind":"Name","value":"modifier"}},{"kind":"Field","name":{"kind":"Name","value":"abilityScore"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"indx"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<GetCharactersQuery, GetCharactersQueryVariables>;
export const GetClassesDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetClasses"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"classes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"indx"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]} as unknown as DocumentNode<GetClassesQuery, GetClassesQueryVariables>;
export const GetRacesDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetRaces"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"races"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"indx"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]} as unknown as DocumentNode<GetRacesQuery, GetRacesQueryVariables>;
export const UpdateCharacterDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"UpdateCharacter"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"updateCharacterId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"UpdateCharacterInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"updateCharacter"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"updateCharacterId"}}},{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"age"}},{"kind":"Field","name":{"kind":"Name","value":"level"}},{"kind":"Field","name":{"kind":"Name","value":"race"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"indx"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","name":{"kind":"Name","value":"class"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"indx"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]}}]}}]} as unknown as DocumentNode<UpdateCharacterMutation, UpdateCharacterMutationVariables>;