// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/ecshreve/dndgen/ent"
	"github.com/ecshreve/dndgen/ent/alignment"
	"github.com/ecshreve/dndgen/ent/armor"
	"github.com/ecshreve/dndgen/ent/characterproficiency"
	"github.com/ecshreve/dndgen/ent/equipment"
	"github.com/ecshreve/dndgen/ent/language"
	"github.com/ecshreve/dndgen/ent/prerequisite"
	"github.com/ecshreve/dndgen/ent/race"
	"github.com/ecshreve/dndgen/ent/vehicle"
	"github.com/ecshreve/dndgen/ent/weapon"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AbilityScore struct {
		Desc     func(childComplexity int) int
		FullName func(childComplexity int) int
		ID       func(childComplexity int) int
		Indx     func(childComplexity int) int
		Name     func(childComplexity int) int
		Skills   func(childComplexity int) int
	}

	Alignment struct {
		Abbr func(childComplexity int) int
		Desc func(childComplexity int) int
		ID   func(childComplexity int) int
		Indx func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Armor struct {
		AcBase              func(childComplexity int) int
		AcDexBonus          func(childComplexity int) int
		AcMaxBonus          func(childComplexity int) int
		ArmorCategory       func(childComplexity int) int
		Equipment           func(childComplexity int) int
		ID                  func(childComplexity int) int
		StealthDisadvantage func(childComplexity int) int
		StrMinimum          func(childComplexity int) int
	}

	Character struct {
		Age                    func(childComplexity int) int
		Alignment              func(childComplexity int) int
		CharacterAbilityScores func(childComplexity int) int
		CharacterProficiencies func(childComplexity int) int
		CharacterSkills        func(childComplexity int) int
		Class                  func(childComplexity int) int
		ID                     func(childComplexity int) int
		Level                  func(childComplexity int) int
		Name                   func(childComplexity int) int
		ProficiencyBonus       func(childComplexity int) int
		Race                   func(childComplexity int) int
	}

	CharacterAbilityScore struct {
		AbilityScore    func(childComplexity int) int
		Character       func(childComplexity int) int
		CharacterSkills func(childComplexity int) int
		ID              func(childComplexity int) int
		Modifier        func(childComplexity int) int
		Score           func(childComplexity int) int
	}

	CharacterConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CharacterEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	CharacterProficiency struct {
		Character         func(childComplexity int) int
		CharacterSkill    func(childComplexity int) int
		ID                func(childComplexity int) int
		Proficiency       func(childComplexity int) int
		ProficiencySource func(childComplexity int) int
		ProficiencyType   func(childComplexity int) int
	}

	CharacterSkill struct {
		Character             func(childComplexity int) int
		CharacterAbilityScore func(childComplexity int) int
		CharacterProficiency  func(childComplexity int) int
		ID                    func(childComplexity int) int
		Proficient            func(childComplexity int) int
		Skill                 func(childComplexity int) int
	}

	Class struct {
		Characters         func(childComplexity int) int
		HitDie             func(childComplexity int) int
		ID                 func(childComplexity int) int
		Indx               func(childComplexity int) int
		Name               func(childComplexity int) int
		Proficiencies      func(childComplexity int) int
		ProficiencyOptions func(childComplexity int) int
		SavingThrows       func(childComplexity int) int
		StartingEquipment  func(childComplexity int) int
	}

	Coin struct {
		Desc               func(childComplexity int) int
		GoldConversionRate func(childComplexity int) int
		ID                 func(childComplexity int) int
		Indx               func(childComplexity int) int
		Name               func(childComplexity int) int
	}

	Condition struct {
		Desc func(childComplexity int) int
		ID   func(childComplexity int) int
		Indx func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Cost struct {
		Coin      func(childComplexity int) int
		Equipment func(childComplexity int) int
		ID        func(childComplexity int) int
		Quantity  func(childComplexity int) int
	}

	DamageType struct {
		Desc    func(childComplexity int) int
		ID      func(childComplexity int) int
		Indx    func(childComplexity int) int
		Name    func(childComplexity int) int
		Weapons func(childComplexity int) int
	}

	Equipment struct {
		Armor             func(childComplexity int) int
		Cost              func(childComplexity int) int
		EquipmentCategory func(childComplexity int) int
		EquipmentEntries  func(childComplexity int) int
		Gear              func(childComplexity int) int
		ID                func(childComplexity int) int
		Indx              func(childComplexity int) int
		Name              func(childComplexity int) int
		Tool              func(childComplexity int) int
		Vehicle           func(childComplexity int) int
		Weapon            func(childComplexity int) int
		Weight            func(childComplexity int) int
	}

	EquipmentConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	EquipmentEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	EquipmentEntry struct {
		Class     func(childComplexity int) int
		Equipment func(childComplexity int) int
		ID        func(childComplexity int) int
		Quantity  func(childComplexity int) int
	}

	Feat struct {
		Desc func(childComplexity int) int
		ID   func(childComplexity int) int
		Indx func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Feature struct {
		Desc          func(childComplexity int) int
		ID            func(childComplexity int) int
		Indx          func(childComplexity int) int
		Level         func(childComplexity int) int
		Name          func(childComplexity int) int
		Prerequisites func(childComplexity int) int
	}

	Gear struct {
		Desc         func(childComplexity int) int
		Equipment    func(childComplexity int) int
		GearCategory func(childComplexity int) int
		ID           func(childComplexity int) int
	}

	Language struct {
		Desc         func(childComplexity int) int
		ID           func(childComplexity int) int
		Indx         func(childComplexity int) int
		LanguageType func(childComplexity int) int
		Name         func(childComplexity int) int
		Options      func(childComplexity int) int
		Race         func(childComplexity int) int
		Script       func(childComplexity int) int
	}

	LanguageChoice struct {
		Choose    func(childComplexity int) int
		ID        func(childComplexity int) int
		Languages func(childComplexity int) int
		Race      func(childComplexity int) int
	}

	MagicSchool struct {
		Desc func(childComplexity int) int
		ID   func(childComplexity int) int
		Indx func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Mutation struct {
		CreateCharacter func(childComplexity int, input ent.CreateCharacterInput) int
		UpdateCharacter func(childComplexity int, id int, input ent.UpdateCharacterInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Prerequisite struct {
		Feature          func(childComplexity int) int
		FeatureValue     func(childComplexity int) int
		ID               func(childComplexity int) int
		LevelValue       func(childComplexity int) int
		PrerequisiteType func(childComplexity int) int
		SpellValue       func(childComplexity int) int
	}

	Proficiency struct {
		Class     func(childComplexity int) int
		ID        func(childComplexity int) int
		Indx      func(childComplexity int) int
		Name      func(childComplexity int) int
		Race      func(childComplexity int) int
		Reference func(childComplexity int) int
	}

	ProficiencyChoice struct {
		Choose        func(childComplexity int) int
		Class         func(childComplexity int) int
		Desc          func(childComplexity int) int
		ID            func(childComplexity int) int
		Proficiencies func(childComplexity int) int
		Race          func(childComplexity int) int
	}

	Property struct {
		Desc    func(childComplexity int) int
		ID      func(childComplexity int) int
		Indx    func(childComplexity int) int
		Name    func(childComplexity int) int
		Weapons func(childComplexity int) int
	}

	Query struct {
		AbilityScores func(childComplexity int) int
		Alignments    func(childComplexity int) int
		Characters    func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy *ent.CharacterOrder, where *ent.CharacterWhereInput) int
		Classes       func(childComplexity int) int
		Coins         func(childComplexity int) int
		Conditions    func(childComplexity int) int
		DamageTypes   func(childComplexity int) int
		Equipments    func(childComplexity int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy *ent.EquipmentOrder, where *ent.EquipmentWhereInput) int
		Feats         func(childComplexity int) int
		Features      func(childComplexity int) int
		Languages     func(childComplexity int) int
		MagicSchools  func(childComplexity int) int
		Node          func(childComplexity int, id int) int
		Nodes         func(childComplexity int, ids []int) int
		Properties    func(childComplexity int) int
		Races         func(childComplexity int) int
		RuleSections  func(childComplexity int) int
		Rules         func(childComplexity int) int
		Skills        func(childComplexity int) int
	}

	Race struct {
		AbilityBonuses             func(childComplexity int) int
		AgeDesc                    func(childComplexity int) int
		AlignmentDesc              func(childComplexity int) int
		Characters                 func(childComplexity int) int
		ID                         func(childComplexity int) int
		Indx                       func(childComplexity int) int
		LanguageDesc               func(childComplexity int) int
		LanguageOptions            func(childComplexity int) int
		Languages                  func(childComplexity int) int
		Name                       func(childComplexity int) int
		Size                       func(childComplexity int) int
		SizeDesc                   func(childComplexity int) int
		Speed                      func(childComplexity int) int
		StartingProficiencies      func(childComplexity int) int
		StartingProficiencyOptions func(childComplexity int) int
		Traits                     func(childComplexity int) int
	}

	Rule struct {
		Desc     func(childComplexity int) int
		ID       func(childComplexity int) int
		Indx     func(childComplexity int) int
		Name     func(childComplexity int) int
		Sections func(childComplexity int) int
	}

	RuleSection struct {
		Desc func(childComplexity int) int
		ID   func(childComplexity int) int
		Indx func(childComplexity int) int
		Name func(childComplexity int) int
		Rule func(childComplexity int) int
	}

	Skill struct {
		AbilityScore func(childComplexity int) int
		Desc         func(childComplexity int) int
		ID           func(childComplexity int) int
		Indx         func(childComplexity int) int
		Name         func(childComplexity int) int
	}

	Tool struct {
		Desc         func(childComplexity int) int
		Equipment    func(childComplexity int) int
		ID           func(childComplexity int) int
		ToolCategory func(childComplexity int) int
	}

	Trait struct {
		Desc func(childComplexity int) int
		ID   func(childComplexity int) int
		Indx func(childComplexity int) int
		Name func(childComplexity int) int
		Race func(childComplexity int) int
	}

	Vehicle struct {
		Capacity        func(childComplexity int) int
		Desc            func(childComplexity int) int
		Equipment       func(childComplexity int) int
		ID              func(childComplexity int) int
		SpeedQuantity   func(childComplexity int) int
		SpeedUnits      func(childComplexity int) int
		VehicleCategory func(childComplexity int) int
	}

	Weapon struct {
		DamageDice        func(childComplexity int) int
		DamageType        func(childComplexity int) int
		Equipment         func(childComplexity int) int
		ID                func(childComplexity int) int
		Properties        func(childComplexity int) int
		RangeLong         func(childComplexity int) int
		RangeNormal       func(childComplexity int) int
		ThrowRangeLong    func(childComplexity int) int
		ThrowRangeNormal  func(childComplexity int) int
		WeaponCategory    func(childComplexity int) int
		WeaponSubcategory func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateCharacter(ctx context.Context, input ent.CreateCharacterInput) (*ent.Character, error)
	UpdateCharacter(ctx context.Context, id int, input ent.UpdateCharacterInput) (*ent.Character, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id int) (ent.Noder, error)
	Nodes(ctx context.Context, ids []int) ([]ent.Noder, error)
	AbilityScores(ctx context.Context) ([]*ent.AbilityScore, error)
	Alignments(ctx context.Context) ([]*ent.Alignment, error)
	Characters(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy *ent.CharacterOrder, where *ent.CharacterWhereInput) (*ent.CharacterConnection, error)
	Classes(ctx context.Context) ([]*ent.Class, error)
	Coins(ctx context.Context) ([]*ent.Coin, error)
	Conditions(ctx context.Context) ([]*ent.Condition, error)
	DamageTypes(ctx context.Context) ([]*ent.DamageType, error)
	Equipments(ctx context.Context, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, orderBy *ent.EquipmentOrder, where *ent.EquipmentWhereInput) (*ent.EquipmentConnection, error)
	Feats(ctx context.Context) ([]*ent.Feat, error)
	Features(ctx context.Context) ([]*ent.Feature, error)
	Languages(ctx context.Context) ([]*ent.Language, error)
	MagicSchools(ctx context.Context) ([]*ent.MagicSchool, error)
	Properties(ctx context.Context) ([]*ent.Property, error)
	Races(ctx context.Context) ([]*ent.Race, error)
	Rules(ctx context.Context) ([]*ent.Rule, error)
	RuleSections(ctx context.Context) ([]*ent.RuleSection, error)
	Skills(ctx context.Context) ([]*ent.Skill, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AbilityScore.desc":
		if e.complexity.AbilityScore.Desc == nil {
			break
		}

		return e.complexity.AbilityScore.Desc(childComplexity), true

	case "AbilityScore.fullName":
		if e.complexity.AbilityScore.FullName == nil {
			break
		}

		return e.complexity.AbilityScore.FullName(childComplexity), true

	case "AbilityScore.id":
		if e.complexity.AbilityScore.ID == nil {
			break
		}

		return e.complexity.AbilityScore.ID(childComplexity), true

	case "AbilityScore.indx":
		if e.complexity.AbilityScore.Indx == nil {
			break
		}

		return e.complexity.AbilityScore.Indx(childComplexity), true

	case "AbilityScore.name":
		if e.complexity.AbilityScore.Name == nil {
			break
		}

		return e.complexity.AbilityScore.Name(childComplexity), true

	case "AbilityScore.skills":
		if e.complexity.AbilityScore.Skills == nil {
			break
		}

		return e.complexity.AbilityScore.Skills(childComplexity), true

	case "Alignment.abbr":
		if e.complexity.Alignment.Abbr == nil {
			break
		}

		return e.complexity.Alignment.Abbr(childComplexity), true

	case "Alignment.desc":
		if e.complexity.Alignment.Desc == nil {
			break
		}

		return e.complexity.Alignment.Desc(childComplexity), true

	case "Alignment.id":
		if e.complexity.Alignment.ID == nil {
			break
		}

		return e.complexity.Alignment.ID(childComplexity), true

	case "Alignment.indx":
		if e.complexity.Alignment.Indx == nil {
			break
		}

		return e.complexity.Alignment.Indx(childComplexity), true

	case "Alignment.name":
		if e.complexity.Alignment.Name == nil {
			break
		}

		return e.complexity.Alignment.Name(childComplexity), true

	case "Armor.acBase":
		if e.complexity.Armor.AcBase == nil {
			break
		}

		return e.complexity.Armor.AcBase(childComplexity), true

	case "Armor.acDexBonus":
		if e.complexity.Armor.AcDexBonus == nil {
			break
		}

		return e.complexity.Armor.AcDexBonus(childComplexity), true

	case "Armor.acMaxBonus":
		if e.complexity.Armor.AcMaxBonus == nil {
			break
		}

		return e.complexity.Armor.AcMaxBonus(childComplexity), true

	case "Armor.armorCategory":
		if e.complexity.Armor.ArmorCategory == nil {
			break
		}

		return e.complexity.Armor.ArmorCategory(childComplexity), true

	case "Armor.equipment":
		if e.complexity.Armor.Equipment == nil {
			break
		}

		return e.complexity.Armor.Equipment(childComplexity), true

	case "Armor.id":
		if e.complexity.Armor.ID == nil {
			break
		}

		return e.complexity.Armor.ID(childComplexity), true

	case "Armor.stealthDisadvantage":
		if e.complexity.Armor.StealthDisadvantage == nil {
			break
		}

		return e.complexity.Armor.StealthDisadvantage(childComplexity), true

	case "Armor.strMinimum":
		if e.complexity.Armor.StrMinimum == nil {
			break
		}

		return e.complexity.Armor.StrMinimum(childComplexity), true

	case "Character.age":
		if e.complexity.Character.Age == nil {
			break
		}

		return e.complexity.Character.Age(childComplexity), true

	case "Character.alignment":
		if e.complexity.Character.Alignment == nil {
			break
		}

		return e.complexity.Character.Alignment(childComplexity), true

	case "Character.characterAbilityScores":
		if e.complexity.Character.CharacterAbilityScores == nil {
			break
		}

		return e.complexity.Character.CharacterAbilityScores(childComplexity), true

	case "Character.characterProficiencies":
		if e.complexity.Character.CharacterProficiencies == nil {
			break
		}

		return e.complexity.Character.CharacterProficiencies(childComplexity), true

	case "Character.characterSkills":
		if e.complexity.Character.CharacterSkills == nil {
			break
		}

		return e.complexity.Character.CharacterSkills(childComplexity), true

	case "Character.class":
		if e.complexity.Character.Class == nil {
			break
		}

		return e.complexity.Character.Class(childComplexity), true

	case "Character.id":
		if e.complexity.Character.ID == nil {
			break
		}

		return e.complexity.Character.ID(childComplexity), true

	case "Character.level":
		if e.complexity.Character.Level == nil {
			break
		}

		return e.complexity.Character.Level(childComplexity), true

	case "Character.name":
		if e.complexity.Character.Name == nil {
			break
		}

		return e.complexity.Character.Name(childComplexity), true

	case "Character.proficiencyBonus":
		if e.complexity.Character.ProficiencyBonus == nil {
			break
		}

		return e.complexity.Character.ProficiencyBonus(childComplexity), true

	case "Character.race":
		if e.complexity.Character.Race == nil {
			break
		}

		return e.complexity.Character.Race(childComplexity), true

	case "CharacterAbilityScore.abilityScore":
		if e.complexity.CharacterAbilityScore.AbilityScore == nil {
			break
		}

		return e.complexity.CharacterAbilityScore.AbilityScore(childComplexity), true

	case "CharacterAbilityScore.character":
		if e.complexity.CharacterAbilityScore.Character == nil {
			break
		}

		return e.complexity.CharacterAbilityScore.Character(childComplexity), true

	case "CharacterAbilityScore.characterSkills":
		if e.complexity.CharacterAbilityScore.CharacterSkills == nil {
			break
		}

		return e.complexity.CharacterAbilityScore.CharacterSkills(childComplexity), true

	case "CharacterAbilityScore.id":
		if e.complexity.CharacterAbilityScore.ID == nil {
			break
		}

		return e.complexity.CharacterAbilityScore.ID(childComplexity), true

	case "CharacterAbilityScore.modifier":
		if e.complexity.CharacterAbilityScore.Modifier == nil {
			break
		}

		return e.complexity.CharacterAbilityScore.Modifier(childComplexity), true

	case "CharacterAbilityScore.score":
		if e.complexity.CharacterAbilityScore.Score == nil {
			break
		}

		return e.complexity.CharacterAbilityScore.Score(childComplexity), true

	case "CharacterConnection.edges":
		if e.complexity.CharacterConnection.Edges == nil {
			break
		}

		return e.complexity.CharacterConnection.Edges(childComplexity), true

	case "CharacterConnection.pageInfo":
		if e.complexity.CharacterConnection.PageInfo == nil {
			break
		}

		return e.complexity.CharacterConnection.PageInfo(childComplexity), true

	case "CharacterConnection.totalCount":
		if e.complexity.CharacterConnection.TotalCount == nil {
			break
		}

		return e.complexity.CharacterConnection.TotalCount(childComplexity), true

	case "CharacterEdge.cursor":
		if e.complexity.CharacterEdge.Cursor == nil {
			break
		}

		return e.complexity.CharacterEdge.Cursor(childComplexity), true

	case "CharacterEdge.node":
		if e.complexity.CharacterEdge.Node == nil {
			break
		}

		return e.complexity.CharacterEdge.Node(childComplexity), true

	case "CharacterProficiency.character":
		if e.complexity.CharacterProficiency.Character == nil {
			break
		}

		return e.complexity.CharacterProficiency.Character(childComplexity), true

	case "CharacterProficiency.characterSkill":
		if e.complexity.CharacterProficiency.CharacterSkill == nil {
			break
		}

		return e.complexity.CharacterProficiency.CharacterSkill(childComplexity), true

	case "CharacterProficiency.id":
		if e.complexity.CharacterProficiency.ID == nil {
			break
		}

		return e.complexity.CharacterProficiency.ID(childComplexity), true

	case "CharacterProficiency.proficiency":
		if e.complexity.CharacterProficiency.Proficiency == nil {
			break
		}

		return e.complexity.CharacterProficiency.Proficiency(childComplexity), true

	case "CharacterProficiency.proficiencySource":
		if e.complexity.CharacterProficiency.ProficiencySource == nil {
			break
		}

		return e.complexity.CharacterProficiency.ProficiencySource(childComplexity), true

	case "CharacterProficiency.proficiencyType":
		if e.complexity.CharacterProficiency.ProficiencyType == nil {
			break
		}

		return e.complexity.CharacterProficiency.ProficiencyType(childComplexity), true

	case "CharacterSkill.character":
		if e.complexity.CharacterSkill.Character == nil {
			break
		}

		return e.complexity.CharacterSkill.Character(childComplexity), true

	case "CharacterSkill.characterAbilityScore":
		if e.complexity.CharacterSkill.CharacterAbilityScore == nil {
			break
		}

		return e.complexity.CharacterSkill.CharacterAbilityScore(childComplexity), true

	case "CharacterSkill.characterProficiency":
		if e.complexity.CharacterSkill.CharacterProficiency == nil {
			break
		}

		return e.complexity.CharacterSkill.CharacterProficiency(childComplexity), true

	case "CharacterSkill.id":
		if e.complexity.CharacterSkill.ID == nil {
			break
		}

		return e.complexity.CharacterSkill.ID(childComplexity), true

	case "CharacterSkill.proficient":
		if e.complexity.CharacterSkill.Proficient == nil {
			break
		}

		return e.complexity.CharacterSkill.Proficient(childComplexity), true

	case "CharacterSkill.skill":
		if e.complexity.CharacterSkill.Skill == nil {
			break
		}

		return e.complexity.CharacterSkill.Skill(childComplexity), true

	case "Class.characters":
		if e.complexity.Class.Characters == nil {
			break
		}

		return e.complexity.Class.Characters(childComplexity), true

	case "Class.hitDie":
		if e.complexity.Class.HitDie == nil {
			break
		}

		return e.complexity.Class.HitDie(childComplexity), true

	case "Class.id":
		if e.complexity.Class.ID == nil {
			break
		}

		return e.complexity.Class.ID(childComplexity), true

	case "Class.indx":
		if e.complexity.Class.Indx == nil {
			break
		}

		return e.complexity.Class.Indx(childComplexity), true

	case "Class.name":
		if e.complexity.Class.Name == nil {
			break
		}

		return e.complexity.Class.Name(childComplexity), true

	case "Class.proficiencies":
		if e.complexity.Class.Proficiencies == nil {
			break
		}

		return e.complexity.Class.Proficiencies(childComplexity), true

	case "Class.proficiencyOptions":
		if e.complexity.Class.ProficiencyOptions == nil {
			break
		}

		return e.complexity.Class.ProficiencyOptions(childComplexity), true

	case "Class.savingThrows":
		if e.complexity.Class.SavingThrows == nil {
			break
		}

		return e.complexity.Class.SavingThrows(childComplexity), true

	case "Class.startingEquipment":
		if e.complexity.Class.StartingEquipment == nil {
			break
		}

		return e.complexity.Class.StartingEquipment(childComplexity), true

	case "Coin.desc":
		if e.complexity.Coin.Desc == nil {
			break
		}

		return e.complexity.Coin.Desc(childComplexity), true

	case "Coin.goldConversionRate":
		if e.complexity.Coin.GoldConversionRate == nil {
			break
		}

		return e.complexity.Coin.GoldConversionRate(childComplexity), true

	case "Coin.id":
		if e.complexity.Coin.ID == nil {
			break
		}

		return e.complexity.Coin.ID(childComplexity), true

	case "Coin.indx":
		if e.complexity.Coin.Indx == nil {
			break
		}

		return e.complexity.Coin.Indx(childComplexity), true

	case "Coin.name":
		if e.complexity.Coin.Name == nil {
			break
		}

		return e.complexity.Coin.Name(childComplexity), true

	case "Condition.desc":
		if e.complexity.Condition.Desc == nil {
			break
		}

		return e.complexity.Condition.Desc(childComplexity), true

	case "Condition.id":
		if e.complexity.Condition.ID == nil {
			break
		}

		return e.complexity.Condition.ID(childComplexity), true

	case "Condition.indx":
		if e.complexity.Condition.Indx == nil {
			break
		}

		return e.complexity.Condition.Indx(childComplexity), true

	case "Condition.name":
		if e.complexity.Condition.Name == nil {
			break
		}

		return e.complexity.Condition.Name(childComplexity), true

	case "Cost.coin":
		if e.complexity.Cost.Coin == nil {
			break
		}

		return e.complexity.Cost.Coin(childComplexity), true

	case "Cost.equipment":
		if e.complexity.Cost.Equipment == nil {
			break
		}

		return e.complexity.Cost.Equipment(childComplexity), true

	case "Cost.id":
		if e.complexity.Cost.ID == nil {
			break
		}

		return e.complexity.Cost.ID(childComplexity), true

	case "Cost.quantity":
		if e.complexity.Cost.Quantity == nil {
			break
		}

		return e.complexity.Cost.Quantity(childComplexity), true

	case "DamageType.desc":
		if e.complexity.DamageType.Desc == nil {
			break
		}

		return e.complexity.DamageType.Desc(childComplexity), true

	case "DamageType.id":
		if e.complexity.DamageType.ID == nil {
			break
		}

		return e.complexity.DamageType.ID(childComplexity), true

	case "DamageType.indx":
		if e.complexity.DamageType.Indx == nil {
			break
		}

		return e.complexity.DamageType.Indx(childComplexity), true

	case "DamageType.name":
		if e.complexity.DamageType.Name == nil {
			break
		}

		return e.complexity.DamageType.Name(childComplexity), true

	case "DamageType.weapons":
		if e.complexity.DamageType.Weapons == nil {
			break
		}

		return e.complexity.DamageType.Weapons(childComplexity), true

	case "Equipment.armor":
		if e.complexity.Equipment.Armor == nil {
			break
		}

		return e.complexity.Equipment.Armor(childComplexity), true

	case "Equipment.cost":
		if e.complexity.Equipment.Cost == nil {
			break
		}

		return e.complexity.Equipment.Cost(childComplexity), true

	case "Equipment.equipmentCategory":
		if e.complexity.Equipment.EquipmentCategory == nil {
			break
		}

		return e.complexity.Equipment.EquipmentCategory(childComplexity), true

	case "Equipment.equipmentEntries":
		if e.complexity.Equipment.EquipmentEntries == nil {
			break
		}

		return e.complexity.Equipment.EquipmentEntries(childComplexity), true

	case "Equipment.gear":
		if e.complexity.Equipment.Gear == nil {
			break
		}

		return e.complexity.Equipment.Gear(childComplexity), true

	case "Equipment.id":
		if e.complexity.Equipment.ID == nil {
			break
		}

		return e.complexity.Equipment.ID(childComplexity), true

	case "Equipment.indx":
		if e.complexity.Equipment.Indx == nil {
			break
		}

		return e.complexity.Equipment.Indx(childComplexity), true

	case "Equipment.name":
		if e.complexity.Equipment.Name == nil {
			break
		}

		return e.complexity.Equipment.Name(childComplexity), true

	case "Equipment.tool":
		if e.complexity.Equipment.Tool == nil {
			break
		}

		return e.complexity.Equipment.Tool(childComplexity), true

	case "Equipment.vehicle":
		if e.complexity.Equipment.Vehicle == nil {
			break
		}

		return e.complexity.Equipment.Vehicle(childComplexity), true

	case "Equipment.weapon":
		if e.complexity.Equipment.Weapon == nil {
			break
		}

		return e.complexity.Equipment.Weapon(childComplexity), true

	case "Equipment.weight":
		if e.complexity.Equipment.Weight == nil {
			break
		}

		return e.complexity.Equipment.Weight(childComplexity), true

	case "EquipmentConnection.edges":
		if e.complexity.EquipmentConnection.Edges == nil {
			break
		}

		return e.complexity.EquipmentConnection.Edges(childComplexity), true

	case "EquipmentConnection.pageInfo":
		if e.complexity.EquipmentConnection.PageInfo == nil {
			break
		}

		return e.complexity.EquipmentConnection.PageInfo(childComplexity), true

	case "EquipmentConnection.totalCount":
		if e.complexity.EquipmentConnection.TotalCount == nil {
			break
		}

		return e.complexity.EquipmentConnection.TotalCount(childComplexity), true

	case "EquipmentEdge.cursor":
		if e.complexity.EquipmentEdge.Cursor == nil {
			break
		}

		return e.complexity.EquipmentEdge.Cursor(childComplexity), true

	case "EquipmentEdge.node":
		if e.complexity.EquipmentEdge.Node == nil {
			break
		}

		return e.complexity.EquipmentEdge.Node(childComplexity), true

	case "EquipmentEntry.class":
		if e.complexity.EquipmentEntry.Class == nil {
			break
		}

		return e.complexity.EquipmentEntry.Class(childComplexity), true

	case "EquipmentEntry.equipment":
		if e.complexity.EquipmentEntry.Equipment == nil {
			break
		}

		return e.complexity.EquipmentEntry.Equipment(childComplexity), true

	case "EquipmentEntry.id":
		if e.complexity.EquipmentEntry.ID == nil {
			break
		}

		return e.complexity.EquipmentEntry.ID(childComplexity), true

	case "EquipmentEntry.quantity":
		if e.complexity.EquipmentEntry.Quantity == nil {
			break
		}

		return e.complexity.EquipmentEntry.Quantity(childComplexity), true

	case "Feat.desc":
		if e.complexity.Feat.Desc == nil {
			break
		}

		return e.complexity.Feat.Desc(childComplexity), true

	case "Feat.id":
		if e.complexity.Feat.ID == nil {
			break
		}

		return e.complexity.Feat.ID(childComplexity), true

	case "Feat.indx":
		if e.complexity.Feat.Indx == nil {
			break
		}

		return e.complexity.Feat.Indx(childComplexity), true

	case "Feat.name":
		if e.complexity.Feat.Name == nil {
			break
		}

		return e.complexity.Feat.Name(childComplexity), true

	case "Feature.desc":
		if e.complexity.Feature.Desc == nil {
			break
		}

		return e.complexity.Feature.Desc(childComplexity), true

	case "Feature.id":
		if e.complexity.Feature.ID == nil {
			break
		}

		return e.complexity.Feature.ID(childComplexity), true

	case "Feature.indx":
		if e.complexity.Feature.Indx == nil {
			break
		}

		return e.complexity.Feature.Indx(childComplexity), true

	case "Feature.level":
		if e.complexity.Feature.Level == nil {
			break
		}

		return e.complexity.Feature.Level(childComplexity), true

	case "Feature.name":
		if e.complexity.Feature.Name == nil {
			break
		}

		return e.complexity.Feature.Name(childComplexity), true

	case "Feature.prerequisites":
		if e.complexity.Feature.Prerequisites == nil {
			break
		}

		return e.complexity.Feature.Prerequisites(childComplexity), true

	case "Gear.desc":
		if e.complexity.Gear.Desc == nil {
			break
		}

		return e.complexity.Gear.Desc(childComplexity), true

	case "Gear.equipment":
		if e.complexity.Gear.Equipment == nil {
			break
		}

		return e.complexity.Gear.Equipment(childComplexity), true

	case "Gear.gearCategory":
		if e.complexity.Gear.GearCategory == nil {
			break
		}

		return e.complexity.Gear.GearCategory(childComplexity), true

	case "Gear.id":
		if e.complexity.Gear.ID == nil {
			break
		}

		return e.complexity.Gear.ID(childComplexity), true

	case "Language.desc":
		if e.complexity.Language.Desc == nil {
			break
		}

		return e.complexity.Language.Desc(childComplexity), true

	case "Language.id":
		if e.complexity.Language.ID == nil {
			break
		}

		return e.complexity.Language.ID(childComplexity), true

	case "Language.indx":
		if e.complexity.Language.Indx == nil {
			break
		}

		return e.complexity.Language.Indx(childComplexity), true

	case "Language.languageType":
		if e.complexity.Language.LanguageType == nil {
			break
		}

		return e.complexity.Language.LanguageType(childComplexity), true

	case "Language.name":
		if e.complexity.Language.Name == nil {
			break
		}

		return e.complexity.Language.Name(childComplexity), true

	case "Language.options":
		if e.complexity.Language.Options == nil {
			break
		}

		return e.complexity.Language.Options(childComplexity), true

	case "Language.race":
		if e.complexity.Language.Race == nil {
			break
		}

		return e.complexity.Language.Race(childComplexity), true

	case "Language.script":
		if e.complexity.Language.Script == nil {
			break
		}

		return e.complexity.Language.Script(childComplexity), true

	case "LanguageChoice.choose":
		if e.complexity.LanguageChoice.Choose == nil {
			break
		}

		return e.complexity.LanguageChoice.Choose(childComplexity), true

	case "LanguageChoice.id":
		if e.complexity.LanguageChoice.ID == nil {
			break
		}

		return e.complexity.LanguageChoice.ID(childComplexity), true

	case "LanguageChoice.languages":
		if e.complexity.LanguageChoice.Languages == nil {
			break
		}

		return e.complexity.LanguageChoice.Languages(childComplexity), true

	case "LanguageChoice.race":
		if e.complexity.LanguageChoice.Race == nil {
			break
		}

		return e.complexity.LanguageChoice.Race(childComplexity), true

	case "MagicSchool.desc":
		if e.complexity.MagicSchool.Desc == nil {
			break
		}

		return e.complexity.MagicSchool.Desc(childComplexity), true

	case "MagicSchool.id":
		if e.complexity.MagicSchool.ID == nil {
			break
		}

		return e.complexity.MagicSchool.ID(childComplexity), true

	case "MagicSchool.indx":
		if e.complexity.MagicSchool.Indx == nil {
			break
		}

		return e.complexity.MagicSchool.Indx(childComplexity), true

	case "MagicSchool.name":
		if e.complexity.MagicSchool.Name == nil {
			break
		}

		return e.complexity.MagicSchool.Name(childComplexity), true

	case "Mutation.createCharacter":
		if e.complexity.Mutation.CreateCharacter == nil {
			break
		}

		args, err := ec.field_Mutation_createCharacter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCharacter(childComplexity, args["input"].(ent.CreateCharacterInput)), true

	case "Mutation.updateCharacter":
		if e.complexity.Mutation.UpdateCharacter == nil {
			break
		}

		args, err := ec.field_Mutation_updateCharacter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCharacter(childComplexity, args["id"].(int), args["input"].(ent.UpdateCharacterInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Prerequisite.feature":
		if e.complexity.Prerequisite.Feature == nil {
			break
		}

		return e.complexity.Prerequisite.Feature(childComplexity), true

	case "Prerequisite.featureValue":
		if e.complexity.Prerequisite.FeatureValue == nil {
			break
		}

		return e.complexity.Prerequisite.FeatureValue(childComplexity), true

	case "Prerequisite.id":
		if e.complexity.Prerequisite.ID == nil {
			break
		}

		return e.complexity.Prerequisite.ID(childComplexity), true

	case "Prerequisite.levelValue":
		if e.complexity.Prerequisite.LevelValue == nil {
			break
		}

		return e.complexity.Prerequisite.LevelValue(childComplexity), true

	case "Prerequisite.prerequisiteType":
		if e.complexity.Prerequisite.PrerequisiteType == nil {
			break
		}

		return e.complexity.Prerequisite.PrerequisiteType(childComplexity), true

	case "Prerequisite.spellValue":
		if e.complexity.Prerequisite.SpellValue == nil {
			break
		}

		return e.complexity.Prerequisite.SpellValue(childComplexity), true

	case "Proficiency.class":
		if e.complexity.Proficiency.Class == nil {
			break
		}

		return e.complexity.Proficiency.Class(childComplexity), true

	case "Proficiency.id":
		if e.complexity.Proficiency.ID == nil {
			break
		}

		return e.complexity.Proficiency.ID(childComplexity), true

	case "Proficiency.indx":
		if e.complexity.Proficiency.Indx == nil {
			break
		}

		return e.complexity.Proficiency.Indx(childComplexity), true

	case "Proficiency.name":
		if e.complexity.Proficiency.Name == nil {
			break
		}

		return e.complexity.Proficiency.Name(childComplexity), true

	case "Proficiency.race":
		if e.complexity.Proficiency.Race == nil {
			break
		}

		return e.complexity.Proficiency.Race(childComplexity), true

	case "Proficiency.reference":
		if e.complexity.Proficiency.Reference == nil {
			break
		}

		return e.complexity.Proficiency.Reference(childComplexity), true

	case "ProficiencyChoice.choose":
		if e.complexity.ProficiencyChoice.Choose == nil {
			break
		}

		return e.complexity.ProficiencyChoice.Choose(childComplexity), true

	case "ProficiencyChoice.class":
		if e.complexity.ProficiencyChoice.Class == nil {
			break
		}

		return e.complexity.ProficiencyChoice.Class(childComplexity), true

	case "ProficiencyChoice.desc":
		if e.complexity.ProficiencyChoice.Desc == nil {
			break
		}

		return e.complexity.ProficiencyChoice.Desc(childComplexity), true

	case "ProficiencyChoice.id":
		if e.complexity.ProficiencyChoice.ID == nil {
			break
		}

		return e.complexity.ProficiencyChoice.ID(childComplexity), true

	case "ProficiencyChoice.proficiencies":
		if e.complexity.ProficiencyChoice.Proficiencies == nil {
			break
		}

		return e.complexity.ProficiencyChoice.Proficiencies(childComplexity), true

	case "ProficiencyChoice.race":
		if e.complexity.ProficiencyChoice.Race == nil {
			break
		}

		return e.complexity.ProficiencyChoice.Race(childComplexity), true

	case "Property.desc":
		if e.complexity.Property.Desc == nil {
			break
		}

		return e.complexity.Property.Desc(childComplexity), true

	case "Property.id":
		if e.complexity.Property.ID == nil {
			break
		}

		return e.complexity.Property.ID(childComplexity), true

	case "Property.indx":
		if e.complexity.Property.Indx == nil {
			break
		}

		return e.complexity.Property.Indx(childComplexity), true

	case "Property.name":
		if e.complexity.Property.Name == nil {
			break
		}

		return e.complexity.Property.Name(childComplexity), true

	case "Property.weapons":
		if e.complexity.Property.Weapons == nil {
			break
		}

		return e.complexity.Property.Weapons(childComplexity), true

	case "Query.abilityScores":
		if e.complexity.Query.AbilityScores == nil {
			break
		}

		return e.complexity.Query.AbilityScores(childComplexity), true

	case "Query.alignments":
		if e.complexity.Query.Alignments == nil {
			break
		}

		return e.complexity.Query.Alignments(childComplexity), true

	case "Query.characters":
		if e.complexity.Query.Characters == nil {
			break
		}

		args, err := ec.field_Query_characters_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Characters(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].(*ent.CharacterOrder), args["where"].(*ent.CharacterWhereInput)), true

	case "Query.classes":
		if e.complexity.Query.Classes == nil {
			break
		}

		return e.complexity.Query.Classes(childComplexity), true

	case "Query.coins":
		if e.complexity.Query.Coins == nil {
			break
		}

		return e.complexity.Query.Coins(childComplexity), true

	case "Query.conditions":
		if e.complexity.Query.Conditions == nil {
			break
		}

		return e.complexity.Query.Conditions(childComplexity), true

	case "Query.damageTypes":
		if e.complexity.Query.DamageTypes == nil {
			break
		}

		return e.complexity.Query.DamageTypes(childComplexity), true

	case "Query.equipments":
		if e.complexity.Query.Equipments == nil {
			break
		}

		args, err := ec.field_Query_equipments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Equipments(childComplexity, args["after"].(*entgql.Cursor[int]), args["first"].(*int), args["before"].(*entgql.Cursor[int]), args["last"].(*int), args["orderBy"].(*ent.EquipmentOrder), args["where"].(*ent.EquipmentWhereInput)), true

	case "Query.feats":
		if e.complexity.Query.Feats == nil {
			break
		}

		return e.complexity.Query.Feats(childComplexity), true

	case "Query.features":
		if e.complexity.Query.Features == nil {
			break
		}

		return e.complexity.Query.Features(childComplexity), true

	case "Query.languages":
		if e.complexity.Query.Languages == nil {
			break
		}

		return e.complexity.Query.Languages(childComplexity), true

	case "Query.magicSchools":
		if e.complexity.Query.MagicSchools == nil {
			break
		}

		return e.complexity.Query.MagicSchools(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]int)), true

	case "Query.properties":
		if e.complexity.Query.Properties == nil {
			break
		}

		return e.complexity.Query.Properties(childComplexity), true

	case "Query.races":
		if e.complexity.Query.Races == nil {
			break
		}

		return e.complexity.Query.Races(childComplexity), true

	case "Query.ruleSections":
		if e.complexity.Query.RuleSections == nil {
			break
		}

		return e.complexity.Query.RuleSections(childComplexity), true

	case "Query.rules":
		if e.complexity.Query.Rules == nil {
			break
		}

		return e.complexity.Query.Rules(childComplexity), true

	case "Query.skills":
		if e.complexity.Query.Skills == nil {
			break
		}

		return e.complexity.Query.Skills(childComplexity), true

	case "Race.abilityBonuses":
		if e.complexity.Race.AbilityBonuses == nil {
			break
		}

		return e.complexity.Race.AbilityBonuses(childComplexity), true

	case "Race.ageDesc":
		if e.complexity.Race.AgeDesc == nil {
			break
		}

		return e.complexity.Race.AgeDesc(childComplexity), true

	case "Race.alignmentDesc":
		if e.complexity.Race.AlignmentDesc == nil {
			break
		}

		return e.complexity.Race.AlignmentDesc(childComplexity), true

	case "Race.characters":
		if e.complexity.Race.Characters == nil {
			break
		}

		return e.complexity.Race.Characters(childComplexity), true

	case "Race.id":
		if e.complexity.Race.ID == nil {
			break
		}

		return e.complexity.Race.ID(childComplexity), true

	case "Race.indx":
		if e.complexity.Race.Indx == nil {
			break
		}

		return e.complexity.Race.Indx(childComplexity), true

	case "Race.languageDesc":
		if e.complexity.Race.LanguageDesc == nil {
			break
		}

		return e.complexity.Race.LanguageDesc(childComplexity), true

	case "Race.languageOptions":
		if e.complexity.Race.LanguageOptions == nil {
			break
		}

		return e.complexity.Race.LanguageOptions(childComplexity), true

	case "Race.languages":
		if e.complexity.Race.Languages == nil {
			break
		}

		return e.complexity.Race.Languages(childComplexity), true

	case "Race.name":
		if e.complexity.Race.Name == nil {
			break
		}

		return e.complexity.Race.Name(childComplexity), true

	case "Race.size":
		if e.complexity.Race.Size == nil {
			break
		}

		return e.complexity.Race.Size(childComplexity), true

	case "Race.sizeDesc":
		if e.complexity.Race.SizeDesc == nil {
			break
		}

		return e.complexity.Race.SizeDesc(childComplexity), true

	case "Race.speed":
		if e.complexity.Race.Speed == nil {
			break
		}

		return e.complexity.Race.Speed(childComplexity), true

	case "Race.startingProficiencies":
		if e.complexity.Race.StartingProficiencies == nil {
			break
		}

		return e.complexity.Race.StartingProficiencies(childComplexity), true

	case "Race.startingProficiencyOptions":
		if e.complexity.Race.StartingProficiencyOptions == nil {
			break
		}

		return e.complexity.Race.StartingProficiencyOptions(childComplexity), true

	case "Race.traits":
		if e.complexity.Race.Traits == nil {
			break
		}

		return e.complexity.Race.Traits(childComplexity), true

	case "Rule.desc":
		if e.complexity.Rule.Desc == nil {
			break
		}

		return e.complexity.Rule.Desc(childComplexity), true

	case "Rule.id":
		if e.complexity.Rule.ID == nil {
			break
		}

		return e.complexity.Rule.ID(childComplexity), true

	case "Rule.indx":
		if e.complexity.Rule.Indx == nil {
			break
		}

		return e.complexity.Rule.Indx(childComplexity), true

	case "Rule.name":
		if e.complexity.Rule.Name == nil {
			break
		}

		return e.complexity.Rule.Name(childComplexity), true

	case "Rule.sections":
		if e.complexity.Rule.Sections == nil {
			break
		}

		return e.complexity.Rule.Sections(childComplexity), true

	case "RuleSection.desc":
		if e.complexity.RuleSection.Desc == nil {
			break
		}

		return e.complexity.RuleSection.Desc(childComplexity), true

	case "RuleSection.id":
		if e.complexity.RuleSection.ID == nil {
			break
		}

		return e.complexity.RuleSection.ID(childComplexity), true

	case "RuleSection.indx":
		if e.complexity.RuleSection.Indx == nil {
			break
		}

		return e.complexity.RuleSection.Indx(childComplexity), true

	case "RuleSection.name":
		if e.complexity.RuleSection.Name == nil {
			break
		}

		return e.complexity.RuleSection.Name(childComplexity), true

	case "RuleSection.rule":
		if e.complexity.RuleSection.Rule == nil {
			break
		}

		return e.complexity.RuleSection.Rule(childComplexity), true

	case "Skill.abilityScore":
		if e.complexity.Skill.AbilityScore == nil {
			break
		}

		return e.complexity.Skill.AbilityScore(childComplexity), true

	case "Skill.desc":
		if e.complexity.Skill.Desc == nil {
			break
		}

		return e.complexity.Skill.Desc(childComplexity), true

	case "Skill.id":
		if e.complexity.Skill.ID == nil {
			break
		}

		return e.complexity.Skill.ID(childComplexity), true

	case "Skill.indx":
		if e.complexity.Skill.Indx == nil {
			break
		}

		return e.complexity.Skill.Indx(childComplexity), true

	case "Skill.name":
		if e.complexity.Skill.Name == nil {
			break
		}

		return e.complexity.Skill.Name(childComplexity), true

	case "Tool.desc":
		if e.complexity.Tool.Desc == nil {
			break
		}

		return e.complexity.Tool.Desc(childComplexity), true

	case "Tool.equipment":
		if e.complexity.Tool.Equipment == nil {
			break
		}

		return e.complexity.Tool.Equipment(childComplexity), true

	case "Tool.id":
		if e.complexity.Tool.ID == nil {
			break
		}

		return e.complexity.Tool.ID(childComplexity), true

	case "Tool.toolCategory":
		if e.complexity.Tool.ToolCategory == nil {
			break
		}

		return e.complexity.Tool.ToolCategory(childComplexity), true

	case "Trait.desc":
		if e.complexity.Trait.Desc == nil {
			break
		}

		return e.complexity.Trait.Desc(childComplexity), true

	case "Trait.id":
		if e.complexity.Trait.ID == nil {
			break
		}

		return e.complexity.Trait.ID(childComplexity), true

	case "Trait.indx":
		if e.complexity.Trait.Indx == nil {
			break
		}

		return e.complexity.Trait.Indx(childComplexity), true

	case "Trait.name":
		if e.complexity.Trait.Name == nil {
			break
		}

		return e.complexity.Trait.Name(childComplexity), true

	case "Trait.race":
		if e.complexity.Trait.Race == nil {
			break
		}

		return e.complexity.Trait.Race(childComplexity), true

	case "Vehicle.capacity":
		if e.complexity.Vehicle.Capacity == nil {
			break
		}

		return e.complexity.Vehicle.Capacity(childComplexity), true

	case "Vehicle.desc":
		if e.complexity.Vehicle.Desc == nil {
			break
		}

		return e.complexity.Vehicle.Desc(childComplexity), true

	case "Vehicle.equipment":
		if e.complexity.Vehicle.Equipment == nil {
			break
		}

		return e.complexity.Vehicle.Equipment(childComplexity), true

	case "Vehicle.id":
		if e.complexity.Vehicle.ID == nil {
			break
		}

		return e.complexity.Vehicle.ID(childComplexity), true

	case "Vehicle.speedQuantity":
		if e.complexity.Vehicle.SpeedQuantity == nil {
			break
		}

		return e.complexity.Vehicle.SpeedQuantity(childComplexity), true

	case "Vehicle.speedUnits":
		if e.complexity.Vehicle.SpeedUnits == nil {
			break
		}

		return e.complexity.Vehicle.SpeedUnits(childComplexity), true

	case "Vehicle.vehicleCategory":
		if e.complexity.Vehicle.VehicleCategory == nil {
			break
		}

		return e.complexity.Vehicle.VehicleCategory(childComplexity), true

	case "Weapon.damageDice":
		if e.complexity.Weapon.DamageDice == nil {
			break
		}

		return e.complexity.Weapon.DamageDice(childComplexity), true

	case "Weapon.damageType":
		if e.complexity.Weapon.DamageType == nil {
			break
		}

		return e.complexity.Weapon.DamageType(childComplexity), true

	case "Weapon.equipment":
		if e.complexity.Weapon.Equipment == nil {
			break
		}

		return e.complexity.Weapon.Equipment(childComplexity), true

	case "Weapon.id":
		if e.complexity.Weapon.ID == nil {
			break
		}

		return e.complexity.Weapon.ID(childComplexity), true

	case "Weapon.properties":
		if e.complexity.Weapon.Properties == nil {
			break
		}

		return e.complexity.Weapon.Properties(childComplexity), true

	case "Weapon.rangeLong":
		if e.complexity.Weapon.RangeLong == nil {
			break
		}

		return e.complexity.Weapon.RangeLong(childComplexity), true

	case "Weapon.rangeNormal":
		if e.complexity.Weapon.RangeNormal == nil {
			break
		}

		return e.complexity.Weapon.RangeNormal(childComplexity), true

	case "Weapon.throwRangeLong":
		if e.complexity.Weapon.ThrowRangeLong == nil {
			break
		}

		return e.complexity.Weapon.ThrowRangeLong(childComplexity), true

	case "Weapon.throwRangeNormal":
		if e.complexity.Weapon.ThrowRangeNormal == nil {
			break
		}

		return e.complexity.Weapon.ThrowRangeNormal(childComplexity), true

	case "Weapon.weaponCategory":
		if e.complexity.Weapon.WeaponCategory == nil {
			break
		}

		return e.complexity.Weapon.WeaponCategory(childComplexity), true

	case "Weapon.weaponSubcategory":
		if e.complexity.Weapon.WeaponSubcategory == nil {
			break
		}

		return e.complexity.Weapon.WeaponSubcategory(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAbilityScoreOrder,
		ec.unmarshalInputAbilityScoreWhereInput,
		ec.unmarshalInputAlignmentOrder,
		ec.unmarshalInputAlignmentWhereInput,
		ec.unmarshalInputArmorWhereInput,
		ec.unmarshalInputCharacterAbilityScoreWhereInput,
		ec.unmarshalInputCharacterOrder,
		ec.unmarshalInputCharacterProficiencyWhereInput,
		ec.unmarshalInputCharacterSkillWhereInput,
		ec.unmarshalInputCharacterWhereInput,
		ec.unmarshalInputClassOrder,
		ec.unmarshalInputClassWhereInput,
		ec.unmarshalInputCoinOrder,
		ec.unmarshalInputCoinWhereInput,
		ec.unmarshalInputConditionOrder,
		ec.unmarshalInputConditionWhereInput,
		ec.unmarshalInputCostWhereInput,
		ec.unmarshalInputCreateCharacterAbilityScoreInput,
		ec.unmarshalInputCreateCharacterInput,
		ec.unmarshalInputCreateCharacterProficiencyInput,
		ec.unmarshalInputCreateCharacterSkillInput,
		ec.unmarshalInputDamageTypeOrder,
		ec.unmarshalInputDamageTypeWhereInput,
		ec.unmarshalInputEquipmentEntryWhereInput,
		ec.unmarshalInputEquipmentOrder,
		ec.unmarshalInputEquipmentWhereInput,
		ec.unmarshalInputFeatOrder,
		ec.unmarshalInputFeatWhereInput,
		ec.unmarshalInputFeatureOrder,
		ec.unmarshalInputFeatureWhereInput,
		ec.unmarshalInputGearWhereInput,
		ec.unmarshalInputLanguageChoiceWhereInput,
		ec.unmarshalInputLanguageOrder,
		ec.unmarshalInputLanguageWhereInput,
		ec.unmarshalInputMagicSchoolOrder,
		ec.unmarshalInputMagicSchoolWhereInput,
		ec.unmarshalInputPrerequisiteWhereInput,
		ec.unmarshalInputProficiencyChoiceWhereInput,
		ec.unmarshalInputProficiencyOrder,
		ec.unmarshalInputProficiencyWhereInput,
		ec.unmarshalInputPropertyOrder,
		ec.unmarshalInputPropertyWhereInput,
		ec.unmarshalInputRaceOrder,
		ec.unmarshalInputRaceWhereInput,
		ec.unmarshalInputRuleOrder,
		ec.unmarshalInputRuleSectionOrder,
		ec.unmarshalInputRuleSectionWhereInput,
		ec.unmarshalInputRuleWhereInput,
		ec.unmarshalInputSkillOrder,
		ec.unmarshalInputSkillWhereInput,
		ec.unmarshalInputToolWhereInput,
		ec.unmarshalInputTraitOrder,
		ec.unmarshalInputTraitWhereInput,
		ec.unmarshalInputUpdateCharacterAbilityScoreInput,
		ec.unmarshalInputUpdateCharacterInput,
		ec.unmarshalInputUpdateCharacterProficiencyInput,
		ec.unmarshalInputUpdateCharacterSkillInput,
		ec.unmarshalInputVehicleWhereInput,
		ec.unmarshalInputWeaponWhereInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "ent.graphql" "mutations.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "ent.graphql", Input: sourceData("ent.graphql"), BuiltIn: false},
	{Name: "mutations.graphql", Input: sourceData("mutations.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createCharacter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_createCharacter_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createCharacter_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (ent.CreateCharacterInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal ent.CreateCharacterInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNCreateCharacterInput2githubcomecshrevedndgenentCreateCharacterInput(ctx, tmp)
	}

	var zeroVal ent.CreateCharacterInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateCharacter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Mutation_updateCharacter_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	arg1, err := ec.field_Mutation_updateCharacter_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updateCharacter_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateCharacter_argsInput(
	ctx context.Context,
	rawArgs map[string]interface{},
) (ent.UpdateCharacterInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["input"]
	if !ok {
		var zeroVal ent.UpdateCharacterInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateCharacterInput2githubcomecshrevedndgenentUpdateCharacterInput(ctx, tmp)
	}

	var zeroVal ent.UpdateCharacterInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_characters_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_characters_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg0
	arg1, err := ec.field_Query_characters_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg1
	arg2, err := ec.field_Query_characters_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	arg3, err := ec.field_Query_characters_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg3
	arg4, err := ec.field_Query_characters_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	arg5, err := ec.field_Query_characters_argsWhere(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["where"] = arg5
	return args, nil
}
func (ec *executionContext) field_Query_characters_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*entgql.Cursor[int], error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *entgql.Cursor[int]
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
	}

	var zeroVal *entgql.Cursor[int]
	return zeroVal, nil
}

func (ec *executionContext) field_Query_characters_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_characters_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*entgql.Cursor[int], error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *entgql.Cursor[int]
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
	}

	var zeroVal *entgql.Cursor[int]
	return zeroVal, nil
}

func (ec *executionContext) field_Query_characters_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_characters_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*ent.CharacterOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *ent.CharacterOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOCharacterOrder2githubcomecshrevedndgenentCharacterOrder(ctx, tmp)
	}

	var zeroVal *ent.CharacterOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Query_characters_argsWhere(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*ent.CharacterWhereInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["where"]
	if !ok {
		var zeroVal *ent.CharacterWhereInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
	if tmp, ok := rawArgs["where"]; ok {
		return ec.unmarshalOCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx, tmp)
	}

	var zeroVal *ent.CharacterWhereInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_equipments_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_equipments_argsAfter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["after"] = arg0
	arg1, err := ec.field_Query_equipments_argsFirst(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["first"] = arg1
	arg2, err := ec.field_Query_equipments_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	arg3, err := ec.field_Query_equipments_argsLast(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["last"] = arg3
	arg4, err := ec.field_Query_equipments_argsOrderBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg4
	arg5, err := ec.field_Query_equipments_argsWhere(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["where"] = arg5
	return args, nil
}
func (ec *executionContext) field_Query_equipments_argsAfter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*entgql.Cursor[int], error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["after"]
	if !ok {
		var zeroVal *entgql.Cursor[int]
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
	if tmp, ok := rawArgs["after"]; ok {
		return ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
	}

	var zeroVal *entgql.Cursor[int]
	return zeroVal, nil
}

func (ec *executionContext) field_Query_equipments_argsFirst(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["first"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
	if tmp, ok := rawArgs["first"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_equipments_argsBefore(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*entgql.Cursor[int], error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["before"]
	if !ok {
		var zeroVal *entgql.Cursor[int]
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
	}

	var zeroVal *entgql.Cursor[int]
	return zeroVal, nil
}

func (ec *executionContext) field_Query_equipments_argsLast(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["last"]
	if !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
	if tmp, ok := rawArgs["last"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_equipments_argsOrderBy(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*ent.EquipmentOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["orderBy"]
	if !ok {
		var zeroVal *ent.EquipmentOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
	if tmp, ok := rawArgs["orderBy"]; ok {
		return ec.unmarshalOEquipmentOrder2githubcomecshrevedndgenentEquipmentOrder(ctx, tmp)
	}

	var zeroVal *ent.EquipmentOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Query_equipments_argsWhere(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*ent.EquipmentWhereInput, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["where"]
	if !ok {
		var zeroVal *ent.EquipmentWhereInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
	if tmp, ok := rawArgs["where"]; ok {
		return ec.unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx, tmp)
	}

	var zeroVal *ent.EquipmentWhereInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_node_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_node_argsID(
	ctx context.Context,
	rawArgs map[string]interface{},
) (int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["id"]
	if !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_nodes_argsIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_nodes_argsIds(
	ctx context.Context,
	rawArgs map[string]interface{},
) ([]int, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["ids"]
	if !ok {
		var zeroVal []int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
	if tmp, ok := rawArgs["ids"]; ok {
		return ec.unmarshalNID2int(ctx, tmp)
	}

	var zeroVal []int
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]interface{},
) (bool, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["includeDeprecated"]
	if !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]interface{},
) (bool, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["includeDeprecated"]
	if !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AbilityScore_id(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_indx(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_name(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_desc(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_fullName(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_fullName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FullName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_fullName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbilityScore_skills(ctx context.Context, field graphql.CollectedField, obj *ent.AbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbilityScore_skills(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Skills(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Skill)
	fc.Result = res
	return ec.marshalOSkill2githubcomecshrevedndgenentSkill(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbilityScore_skills(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbilityScore",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Skill_id(ctx, field)
			case "indx":
				return ec.fieldContext_Skill_indx(ctx, field)
			case "name":
				return ec.fieldContext_Skill_name(ctx, field)
			case "desc":
				return ec.fieldContext_Skill_desc(ctx, field)
			case "abilityScore":
				return ec.fieldContext_Skill_abilityScore(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Skill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alignment_id(ctx context.Context, field graphql.CollectedField, obj *ent.Alignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alignment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alignment_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alignment_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Alignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alignment_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alignment_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alignment_name(ctx context.Context, field graphql.CollectedField, obj *ent.Alignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alignment_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alignment_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alignment_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Alignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alignment_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alignment_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alignment_abbr(ctx context.Context, field graphql.CollectedField, obj *ent.Alignment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alignment_abbr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Abbr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(alignment.Abbr)
	fc.Result = res
	return ec.marshalNAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alignment_abbr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alignment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AlignmentAbbr does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_id(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_armorCategory(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_armorCategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArmorCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(armor.ArmorCategory)
	fc.Result = res
	return ec.marshalNArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_armorCategory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ArmorArmorCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_strMinimum(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_strMinimum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StrMinimum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_strMinimum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_stealthDisadvantage(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_stealthDisadvantage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StealthDisadvantage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_stealthDisadvantage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_acBase(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_acBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcBase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_acBase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_acDexBonus(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_acDexBonus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcDexBonus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_acDexBonus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_acMaxBonus(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_acMaxBonus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcMaxBonus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_acMaxBonus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Armor_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Armor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Armor_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Equipment)
	fc.Result = res
	return ec.marshalNEquipment2githubcomecshrevedndgenentEquipment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Armor_equipment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Armor",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "equipmentCategory":
				return ec.fieldContext_Equipment_equipmentCategory(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "tool":
				return ec.fieldContext_Equipment_tool(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "equipmentEntries":
				return ec.fieldContext_Equipment_equipmentEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_id(ctx context.Context, field graphql.CollectedField, obj *ent.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_name(ctx context.Context, field graphql.CollectedField, obj *ent.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_age(ctx context.Context, field graphql.CollectedField, obj *ent.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_age(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Age, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_age(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_level(ctx context.Context, field graphql.CollectedField, obj *ent.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_proficiencyBonus(ctx context.Context, field graphql.CollectedField, obj *ent.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_proficiencyBonus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProficiencyBonus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_proficiencyBonus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_race(ctx context.Context, field graphql.CollectedField, obj *ent.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_race(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Race(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Race)
	fc.Result = res
	return ec.marshalORace2githubcomecshrevedndgenentRace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_race(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Race_id(ctx, field)
			case "indx":
				return ec.fieldContext_Race_indx(ctx, field)
			case "name":
				return ec.fieldContext_Race_name(ctx, field)
			case "speed":
				return ec.fieldContext_Race_speed(ctx, field)
			case "size":
				return ec.fieldContext_Race_size(ctx, field)
			case "sizeDesc":
				return ec.fieldContext_Race_sizeDesc(ctx, field)
			case "alignmentDesc":
				return ec.fieldContext_Race_alignmentDesc(ctx, field)
			case "ageDesc":
				return ec.fieldContext_Race_ageDesc(ctx, field)
			case "languageDesc":
				return ec.fieldContext_Race_languageDesc(ctx, field)
			case "traits":
				return ec.fieldContext_Race_traits(ctx, field)
			case "startingProficiencies":
				return ec.fieldContext_Race_startingProficiencies(ctx, field)
			case "startingProficiencyOptions":
				return ec.fieldContext_Race_startingProficiencyOptions(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_Race_abilityBonuses(ctx, field)
			case "languages":
				return ec.fieldContext_Race_languages(ctx, field)
			case "languageOptions":
				return ec.fieldContext_Race_languageOptions(ctx, field)
			case "characters":
				return ec.fieldContext_Race_characters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Race", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_class(ctx context.Context, field graphql.CollectedField, obj *ent.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_class(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Class(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Class)
	fc.Result = res
	return ec.marshalOClass2githubcomecshrevedndgenentClass(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_class(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Class_id(ctx, field)
			case "indx":
				return ec.fieldContext_Class_indx(ctx, field)
			case "name":
				return ec.fieldContext_Class_name(ctx, field)
			case "hitDie":
				return ec.fieldContext_Class_hitDie(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Class_proficiencies(ctx, field)
			case "proficiencyOptions":
				return ec.fieldContext_Class_proficiencyOptions(ctx, field)
			case "startingEquipment":
				return ec.fieldContext_Class_startingEquipment(ctx, field)
			case "savingThrows":
				return ec.fieldContext_Class_savingThrows(ctx, field)
			case "characters":
				return ec.fieldContext_Class_characters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Class", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_alignment(ctx context.Context, field graphql.CollectedField, obj *ent.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_alignment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alignment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Alignment)
	fc.Result = res
	return ec.marshalOAlignment2githubcomecshrevedndgenentAlignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_alignment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Alignment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Alignment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Alignment_name(ctx, field)
			case "desc":
				return ec.fieldContext_Alignment_desc(ctx, field)
			case "abbr":
				return ec.fieldContext_Alignment_abbr(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alignment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_characterAbilityScores(ctx context.Context, field graphql.CollectedField, obj *ent.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_characterAbilityScores(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CharacterAbilityScores(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.CharacterAbilityScore)
	fc.Result = res
	return ec.marshalOCharacterAbilityScore2githubcomecshrevedndgenentCharacterAbilityScore(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_characterAbilityScores(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterAbilityScore_id(ctx, field)
			case "score":
				return ec.fieldContext_CharacterAbilityScore_score(ctx, field)
			case "modifier":
				return ec.fieldContext_CharacterAbilityScore_modifier(ctx, field)
			case "character":
				return ec.fieldContext_CharacterAbilityScore_character(ctx, field)
			case "abilityScore":
				return ec.fieldContext_CharacterAbilityScore_abilityScore(ctx, field)
			case "characterSkills":
				return ec.fieldContext_CharacterAbilityScore_characterSkills(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterAbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_characterSkills(ctx context.Context, field graphql.CollectedField, obj *ent.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_characterSkills(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CharacterSkills(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.CharacterSkill)
	fc.Result = res
	return ec.marshalOCharacterSkill2githubcomecshrevedndgenentCharacterSkill(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_characterSkills(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterSkill_id(ctx, field)
			case "proficient":
				return ec.fieldContext_CharacterSkill_proficient(ctx, field)
			case "character":
				return ec.fieldContext_CharacterSkill_character(ctx, field)
			case "skill":
				return ec.fieldContext_CharacterSkill_skill(ctx, field)
			case "characterAbilityScore":
				return ec.fieldContext_CharacterSkill_characterAbilityScore(ctx, field)
			case "characterProficiency":
				return ec.fieldContext_CharacterSkill_characterProficiency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterSkill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_characterProficiencies(ctx context.Context, field graphql.CollectedField, obj *ent.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_characterProficiencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CharacterProficiencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.CharacterProficiency)
	fc.Result = res
	return ec.marshalOCharacterProficiency2githubcomecshrevedndgenentCharacterProficiency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_characterProficiencies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterProficiency_id(ctx, field)
			case "proficiencyType":
				return ec.fieldContext_CharacterProficiency_proficiencyType(ctx, field)
			case "proficiencySource":
				return ec.fieldContext_CharacterProficiency_proficiencySource(ctx, field)
			case "character":
				return ec.fieldContext_CharacterProficiency_character(ctx, field)
			case "proficiency":
				return ec.fieldContext_CharacterProficiency_proficiency(ctx, field)
			case "characterSkill":
				return ec.fieldContext_CharacterProficiency_characterSkill(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterProficiency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterAbilityScore_id(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterAbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterAbilityScore_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterAbilityScore_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterAbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterAbilityScore_score(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterAbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterAbilityScore_score(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Score, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterAbilityScore_score(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterAbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterAbilityScore_modifier(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterAbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterAbilityScore_modifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Modifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterAbilityScore_modifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterAbilityScore",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterAbilityScore_character(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterAbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterAbilityScore_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Character)
	fc.Result = res
	return ec.marshalNCharacter2githubcomecshrevedndgenentCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterAbilityScore_character(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterAbilityScore",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "age":
				return ec.fieldContext_Character_age(ctx, field)
			case "level":
				return ec.fieldContext_Character_level(ctx, field)
			case "proficiencyBonus":
				return ec.fieldContext_Character_proficiencyBonus(ctx, field)
			case "race":
				return ec.fieldContext_Character_race(ctx, field)
			case "class":
				return ec.fieldContext_Character_class(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characterAbilityScores":
				return ec.fieldContext_Character_characterAbilityScores(ctx, field)
			case "characterSkills":
				return ec.fieldContext_Character_characterSkills(ctx, field)
			case "characterProficiencies":
				return ec.fieldContext_Character_characterProficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterAbilityScore_abilityScore(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterAbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterAbilityScore_abilityScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbilityScore(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.AbilityScore)
	fc.Result = res
	return ec.marshalNAbilityScore2githubcomecshrevedndgenentAbilityScore(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterAbilityScore_abilityScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterAbilityScore",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityScore_id(ctx, field)
			case "indx":
				return ec.fieldContext_AbilityScore_indx(ctx, field)
			case "name":
				return ec.fieldContext_AbilityScore_name(ctx, field)
			case "desc":
				return ec.fieldContext_AbilityScore_desc(ctx, field)
			case "fullName":
				return ec.fieldContext_AbilityScore_fullName(ctx, field)
			case "skills":
				return ec.fieldContext_AbilityScore_skills(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterAbilityScore_characterSkills(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterAbilityScore) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterAbilityScore_characterSkills(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CharacterSkills(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.CharacterSkill)
	fc.Result = res
	return ec.marshalOCharacterSkill2githubcomecshrevedndgenentCharacterSkill(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterAbilityScore_characterSkills(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterAbilityScore",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterSkill_id(ctx, field)
			case "proficient":
				return ec.fieldContext_CharacterSkill_proficient(ctx, field)
			case "character":
				return ec.fieldContext_CharacterSkill_character(ctx, field)
			case "skill":
				return ec.fieldContext_CharacterSkill_skill(ctx, field)
			case "characterAbilityScore":
				return ec.fieldContext_CharacterSkill_characterAbilityScore(ctx, field)
			case "characterProficiency":
				return ec.fieldContext_CharacterSkill_characterProficiency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterSkill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.CharacterEdge)
	fc.Result = res
	return ec.marshalOCharacterEdge2githubcomecshrevedndgenentCharacterEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_CharacterEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_CharacterEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[int])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Character)
	fc.Result = res
	return ec.marshalOCharacter2githubcomecshrevedndgenentCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "age":
				return ec.fieldContext_Character_age(ctx, field)
			case "level":
				return ec.fieldContext_Character_level(ctx, field)
			case "proficiencyBonus":
				return ec.fieldContext_Character_proficiencyBonus(ctx, field)
			case "race":
				return ec.fieldContext_Character_race(ctx, field)
			case "class":
				return ec.fieldContext_Character_class(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characterAbilityScores":
				return ec.fieldContext_Character_characterAbilityScores(ctx, field)
			case "characterSkills":
				return ec.fieldContext_Character_characterSkills(ctx, field)
			case "characterProficiencies":
				return ec.fieldContext_Character_characterProficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[int])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterProficiency_id(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterProficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterProficiency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterProficiency_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterProficiency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterProficiency_proficiencyType(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterProficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterProficiency_proficiencyType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProficiencyType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(characterproficiency.ProficiencyType)
	fc.Result = res
	return ec.marshalNCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterProficiency_proficiencyType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterProficiency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterProficiencyProficiencyType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterProficiency_proficiencySource(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterProficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterProficiency_proficiencySource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProficiencySource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(characterproficiency.ProficiencySource)
	fc.Result = res
	return ec.marshalNCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterProficiency_proficiencySource(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterProficiency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterProficiencyProficiencySource does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterProficiency_character(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterProficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterProficiency_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Character)
	fc.Result = res
	return ec.marshalNCharacter2githubcomecshrevedndgenentCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterProficiency_character(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterProficiency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "age":
				return ec.fieldContext_Character_age(ctx, field)
			case "level":
				return ec.fieldContext_Character_level(ctx, field)
			case "proficiencyBonus":
				return ec.fieldContext_Character_proficiencyBonus(ctx, field)
			case "race":
				return ec.fieldContext_Character_race(ctx, field)
			case "class":
				return ec.fieldContext_Character_class(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characterAbilityScores":
				return ec.fieldContext_Character_characterAbilityScores(ctx, field)
			case "characterSkills":
				return ec.fieldContext_Character_characterSkills(ctx, field)
			case "characterProficiencies":
				return ec.fieldContext_Character_characterProficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterProficiency_proficiency(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterProficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterProficiency_proficiency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proficiency(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Proficiency)
	fc.Result = res
	return ec.marshalNProficiency2githubcomecshrevedndgenentProficiency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterProficiency_proficiency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterProficiency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Proficiency_id(ctx, field)
			case "indx":
				return ec.fieldContext_Proficiency_indx(ctx, field)
			case "name":
				return ec.fieldContext_Proficiency_name(ctx, field)
			case "reference":
				return ec.fieldContext_Proficiency_reference(ctx, field)
			case "race":
				return ec.fieldContext_Proficiency_race(ctx, field)
			case "class":
				return ec.fieldContext_Proficiency_class(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Proficiency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterProficiency_characterSkill(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterProficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterProficiency_characterSkill(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CharacterSkill(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.CharacterSkill)
	fc.Result = res
	return ec.marshalOCharacterSkill2githubcomecshrevedndgenentCharacterSkill(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterProficiency_characterSkill(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterProficiency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterSkill_id(ctx, field)
			case "proficient":
				return ec.fieldContext_CharacterSkill_proficient(ctx, field)
			case "character":
				return ec.fieldContext_CharacterSkill_character(ctx, field)
			case "skill":
				return ec.fieldContext_CharacterSkill_skill(ctx, field)
			case "characterAbilityScore":
				return ec.fieldContext_CharacterSkill_characterAbilityScore(ctx, field)
			case "characterProficiency":
				return ec.fieldContext_CharacterSkill_characterProficiency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterSkill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterSkill_id(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterSkill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterSkill_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterSkill_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterSkill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterSkill_proficient(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterSkill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterSkill_proficient(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proficient, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterSkill_proficient(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterSkill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterSkill_character(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterSkill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterSkill_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Character)
	fc.Result = res
	return ec.marshalNCharacter2githubcomecshrevedndgenentCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterSkill_character(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterSkill",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "age":
				return ec.fieldContext_Character_age(ctx, field)
			case "level":
				return ec.fieldContext_Character_level(ctx, field)
			case "proficiencyBonus":
				return ec.fieldContext_Character_proficiencyBonus(ctx, field)
			case "race":
				return ec.fieldContext_Character_race(ctx, field)
			case "class":
				return ec.fieldContext_Character_class(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characterAbilityScores":
				return ec.fieldContext_Character_characterAbilityScores(ctx, field)
			case "characterSkills":
				return ec.fieldContext_Character_characterSkills(ctx, field)
			case "characterProficiencies":
				return ec.fieldContext_Character_characterProficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterSkill_skill(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterSkill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterSkill_skill(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Skill(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Skill)
	fc.Result = res
	return ec.marshalNSkill2githubcomecshrevedndgenentSkill(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterSkill_skill(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterSkill",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Skill_id(ctx, field)
			case "indx":
				return ec.fieldContext_Skill_indx(ctx, field)
			case "name":
				return ec.fieldContext_Skill_name(ctx, field)
			case "desc":
				return ec.fieldContext_Skill_desc(ctx, field)
			case "abilityScore":
				return ec.fieldContext_Skill_abilityScore(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Skill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterSkill_characterAbilityScore(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterSkill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterSkill_characterAbilityScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CharacterAbilityScore(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.CharacterAbilityScore)
	fc.Result = res
	return ec.marshalNCharacterAbilityScore2githubcomecshrevedndgenentCharacterAbilityScore(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterSkill_characterAbilityScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterSkill",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterAbilityScore_id(ctx, field)
			case "score":
				return ec.fieldContext_CharacterAbilityScore_score(ctx, field)
			case "modifier":
				return ec.fieldContext_CharacterAbilityScore_modifier(ctx, field)
			case "character":
				return ec.fieldContext_CharacterAbilityScore_character(ctx, field)
			case "abilityScore":
				return ec.fieldContext_CharacterAbilityScore_abilityScore(ctx, field)
			case "characterSkills":
				return ec.fieldContext_CharacterAbilityScore_characterSkills(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterAbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterSkill_characterProficiency(ctx context.Context, field graphql.CollectedField, obj *ent.CharacterSkill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterSkill_characterProficiency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CharacterProficiency(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.CharacterProficiency)
	fc.Result = res
	return ec.marshalOCharacterProficiency2githubcomecshrevedndgenentCharacterProficiency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterSkill_characterProficiency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterSkill",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterProficiency_id(ctx, field)
			case "proficiencyType":
				return ec.fieldContext_CharacterProficiency_proficiencyType(ctx, field)
			case "proficiencySource":
				return ec.fieldContext_CharacterProficiency_proficiencySource(ctx, field)
			case "character":
				return ec.fieldContext_CharacterProficiency_character(ctx, field)
			case "proficiency":
				return ec.fieldContext_CharacterProficiency_proficiency(ctx, field)
			case "characterSkill":
				return ec.fieldContext_CharacterProficiency_characterSkill(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterProficiency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_id(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_name(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_hitDie(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_hitDie(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HitDie, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_hitDie(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_proficiencies(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_proficiencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proficiencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Proficiency)
	fc.Result = res
	return ec.marshalOProficiency2githubcomecshrevedndgenentProficiency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_proficiencies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Proficiency_id(ctx, field)
			case "indx":
				return ec.fieldContext_Proficiency_indx(ctx, field)
			case "name":
				return ec.fieldContext_Proficiency_name(ctx, field)
			case "reference":
				return ec.fieldContext_Proficiency_reference(ctx, field)
			case "race":
				return ec.fieldContext_Proficiency_race(ctx, field)
			case "class":
				return ec.fieldContext_Proficiency_class(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Proficiency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_proficiencyOptions(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_proficiencyOptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProficiencyOptions(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ProficiencyChoice)
	fc.Result = res
	return ec.marshalOProficiencyChoice2githubcomecshrevedndgenentProficiencyChoice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_proficiencyOptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProficiencyChoice_id(ctx, field)
			case "choose":
				return ec.fieldContext_ProficiencyChoice_choose(ctx, field)
			case "desc":
				return ec.fieldContext_ProficiencyChoice_desc(ctx, field)
			case "proficiencies":
				return ec.fieldContext_ProficiencyChoice_proficiencies(ctx, field)
			case "race":
				return ec.fieldContext_ProficiencyChoice_race(ctx, field)
			case "class":
				return ec.fieldContext_ProficiencyChoice_class(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProficiencyChoice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_startingEquipment(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_startingEquipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartingEquipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.EquipmentEntry)
	fc.Result = res
	return ec.marshalOEquipmentEntry2githubcomecshrevedndgenentEquipmentEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_startingEquipment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EquipmentEntry_id(ctx, field)
			case "quantity":
				return ec.fieldContext_EquipmentEntry_quantity(ctx, field)
			case "class":
				return ec.fieldContext_EquipmentEntry_class(ctx, field)
			case "equipment":
				return ec.fieldContext_EquipmentEntry_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EquipmentEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_savingThrows(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_savingThrows(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SavingThrows(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AbilityScore)
	fc.Result = res
	return ec.marshalOAbilityScore2githubcomecshrevedndgenentAbilityScore(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_savingThrows(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityScore_id(ctx, field)
			case "indx":
				return ec.fieldContext_AbilityScore_indx(ctx, field)
			case "name":
				return ec.fieldContext_AbilityScore_name(ctx, field)
			case "desc":
				return ec.fieldContext_AbilityScore_desc(ctx, field)
			case "fullName":
				return ec.fieldContext_AbilityScore_fullName(ctx, field)
			case "skills":
				return ec.fieldContext_AbilityScore_skills(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Class_characters(ctx context.Context, field graphql.CollectedField, obj *ent.Class) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Class_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Character)
	fc.Result = res
	return ec.marshalOCharacter2githubcomecshrevedndgenentCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Class_characters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Class",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "age":
				return ec.fieldContext_Character_age(ctx, field)
			case "level":
				return ec.fieldContext_Character_level(ctx, field)
			case "proficiencyBonus":
				return ec.fieldContext_Character_proficiencyBonus(ctx, field)
			case "race":
				return ec.fieldContext_Character_race(ctx, field)
			case "class":
				return ec.fieldContext_Character_class(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characterAbilityScores":
				return ec.fieldContext_Character_characterAbilityScores(ctx, field)
			case "characterSkills":
				return ec.fieldContext_Character_characterSkills(ctx, field)
			case "characterProficiencies":
				return ec.fieldContext_Character_characterProficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Coin_id(ctx context.Context, field graphql.CollectedField, obj *ent.Coin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Coin_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Coin_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Coin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Coin_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Coin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Coin_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Coin_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Coin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Coin_name(ctx context.Context, field graphql.CollectedField, obj *ent.Coin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Coin_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Coin_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Coin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Coin_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Coin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Coin_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Coin_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Coin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Coin_goldConversionRate(ctx context.Context, field graphql.CollectedField, obj *ent.Coin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Coin_goldConversionRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoldConversionRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Coin_goldConversionRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Coin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_id(ctx context.Context, field graphql.CollectedField, obj *ent.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_name(ctx context.Context, field graphql.CollectedField, obj *ent.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Condition_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Condition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Condition_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Condition_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Condition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cost_id(ctx context.Context, field graphql.CollectedField, obj *ent.Cost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Cost_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Cost_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cost_quantity(ctx context.Context, field graphql.CollectedField, obj *ent.Cost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Cost_quantity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quantity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Cost_quantity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cost_coin(ctx context.Context, field graphql.CollectedField, obj *ent.Cost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Cost_coin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Coin(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Coin)
	fc.Result = res
	return ec.marshalNCoin2githubcomecshrevedndgenentCoin(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Cost_coin(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Coin_id(ctx, field)
			case "indx":
				return ec.fieldContext_Coin_indx(ctx, field)
			case "name":
				return ec.fieldContext_Coin_name(ctx, field)
			case "desc":
				return ec.fieldContext_Coin_desc(ctx, field)
			case "goldConversionRate":
				return ec.fieldContext_Coin_goldConversionRate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Coin", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Cost_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Cost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Cost_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Equipment)
	fc.Result = res
	return ec.marshalOEquipment2githubcomecshrevedndgenentEquipment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Cost_equipment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Cost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "equipmentCategory":
				return ec.fieldContext_Equipment_equipmentCategory(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "tool":
				return ec.fieldContext_Equipment_tool(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "equipmentEntries":
				return ec.fieldContext_Equipment_equipmentEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DamageType_id(ctx context.Context, field graphql.CollectedField, obj *ent.DamageType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DamageType_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DamageType_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DamageType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DamageType_indx(ctx context.Context, field graphql.CollectedField, obj *ent.DamageType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DamageType_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DamageType_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DamageType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DamageType_name(ctx context.Context, field graphql.CollectedField, obj *ent.DamageType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DamageType_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DamageType_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DamageType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DamageType_desc(ctx context.Context, field graphql.CollectedField, obj *ent.DamageType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DamageType_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DamageType_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DamageType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DamageType_weapons(ctx context.Context, field graphql.CollectedField, obj *ent.DamageType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DamageType_weapons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weapons(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Weapon)
	fc.Result = res
	return ec.marshalOWeapon2githubcomecshrevedndgenentWeapon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DamageType_weapons(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DamageType",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Weapon_id(ctx, field)
			case "weaponCategory":
				return ec.fieldContext_Weapon_weaponCategory(ctx, field)
			case "weaponSubcategory":
				return ec.fieldContext_Weapon_weaponSubcategory(ctx, field)
			case "rangeNormal":
				return ec.fieldContext_Weapon_rangeNormal(ctx, field)
			case "rangeLong":
				return ec.fieldContext_Weapon_rangeLong(ctx, field)
			case "throwRangeNormal":
				return ec.fieldContext_Weapon_throwRangeNormal(ctx, field)
			case "throwRangeLong":
				return ec.fieldContext_Weapon_throwRangeLong(ctx, field)
			case "damageDice":
				return ec.fieldContext_Weapon_damageDice(ctx, field)
			case "properties":
				return ec.fieldContext_Weapon_properties(ctx, field)
			case "damageType":
				return ec.fieldContext_Weapon_damageType(ctx, field)
			case "equipment":
				return ec.fieldContext_Weapon_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Weapon", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_id(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_name(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_equipmentCategory(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_equipmentCategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EquipmentCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(equipment.EquipmentCategory)
	fc.Result = res
	return ec.marshalNEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_equipmentCategory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EquipmentEquipmentCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_weight(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_weight(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_weight(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_cost(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cost)
	fc.Result = res
	return ec.marshalOCost2githubcomecshrevedndgenentCost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_cost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Cost_id(ctx, field)
			case "quantity":
				return ec.fieldContext_Cost_quantity(ctx, field)
			case "coin":
				return ec.fieldContext_Cost_coin(ctx, field)
			case "equipment":
				return ec.fieldContext_Cost_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Cost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_gear(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_gear(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gear(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Gear)
	fc.Result = res
	return ec.marshalOGear2githubcomecshrevedndgenentGear(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_gear(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Gear_id(ctx, field)
			case "gearCategory":
				return ec.fieldContext_Gear_gearCategory(ctx, field)
			case "desc":
				return ec.fieldContext_Gear_desc(ctx, field)
			case "equipment":
				return ec.fieldContext_Gear_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Gear", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_tool(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_tool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tool(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Tool)
	fc.Result = res
	return ec.marshalOTool2githubcomecshrevedndgenentTool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_tool(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tool_id(ctx, field)
			case "toolCategory":
				return ec.fieldContext_Tool_toolCategory(ctx, field)
			case "desc":
				return ec.fieldContext_Tool_desc(ctx, field)
			case "equipment":
				return ec.fieldContext_Tool_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_weapon(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_weapon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weapon(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Weapon)
	fc.Result = res
	return ec.marshalOWeapon2githubcomecshrevedndgenentWeapon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_weapon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Weapon_id(ctx, field)
			case "weaponCategory":
				return ec.fieldContext_Weapon_weaponCategory(ctx, field)
			case "weaponSubcategory":
				return ec.fieldContext_Weapon_weaponSubcategory(ctx, field)
			case "rangeNormal":
				return ec.fieldContext_Weapon_rangeNormal(ctx, field)
			case "rangeLong":
				return ec.fieldContext_Weapon_rangeLong(ctx, field)
			case "throwRangeNormal":
				return ec.fieldContext_Weapon_throwRangeNormal(ctx, field)
			case "throwRangeLong":
				return ec.fieldContext_Weapon_throwRangeLong(ctx, field)
			case "damageDice":
				return ec.fieldContext_Weapon_damageDice(ctx, field)
			case "properties":
				return ec.fieldContext_Weapon_properties(ctx, field)
			case "damageType":
				return ec.fieldContext_Weapon_damageType(ctx, field)
			case "equipment":
				return ec.fieldContext_Weapon_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Weapon", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_vehicle(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_vehicle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vehicle(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Vehicle)
	fc.Result = res
	return ec.marshalOVehicle2githubcomecshrevedndgenentVehicle(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_vehicle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Vehicle_id(ctx, field)
			case "vehicleCategory":
				return ec.fieldContext_Vehicle_vehicleCategory(ctx, field)
			case "capacity":
				return ec.fieldContext_Vehicle_capacity(ctx, field)
			case "desc":
				return ec.fieldContext_Vehicle_desc(ctx, field)
			case "speedQuantity":
				return ec.fieldContext_Vehicle_speedQuantity(ctx, field)
			case "speedUnits":
				return ec.fieldContext_Vehicle_speedUnits(ctx, field)
			case "equipment":
				return ec.fieldContext_Vehicle_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Vehicle", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_armor(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_armor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Armor(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Armor)
	fc.Result = res
	return ec.marshalOArmor2githubcomecshrevedndgenentArmor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_armor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Armor_id(ctx, field)
			case "armorCategory":
				return ec.fieldContext_Armor_armorCategory(ctx, field)
			case "strMinimum":
				return ec.fieldContext_Armor_strMinimum(ctx, field)
			case "stealthDisadvantage":
				return ec.fieldContext_Armor_stealthDisadvantage(ctx, field)
			case "acBase":
				return ec.fieldContext_Armor_acBase(ctx, field)
			case "acDexBonus":
				return ec.fieldContext_Armor_acDexBonus(ctx, field)
			case "acMaxBonus":
				return ec.fieldContext_Armor_acMaxBonus(ctx, field)
			case "equipment":
				return ec.fieldContext_Armor_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Armor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Equipment_equipmentEntries(ctx context.Context, field graphql.CollectedField, obj *ent.Equipment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Equipment_equipmentEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EquipmentEntries(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.EquipmentEntry)
	fc.Result = res
	return ec.marshalOEquipmentEntry2githubcomecshrevedndgenentEquipmentEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Equipment_equipmentEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Equipment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EquipmentEntry_id(ctx, field)
			case "quantity":
				return ec.fieldContext_EquipmentEntry_quantity(ctx, field)
			case "class":
				return ec.fieldContext_EquipmentEntry_class(ctx, field)
			case "equipment":
				return ec.fieldContext_EquipmentEntry_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EquipmentEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.EquipmentEdge)
	fc.Result = res
	return ec.marshalOEquipmentEdge2githubcomecshrevedndgenentEquipmentEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_EquipmentEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_EquipmentEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EquipmentEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[int])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Equipment)
	fc.Result = res
	return ec.marshalOEquipment2githubcomecshrevedndgenentEquipment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "equipmentCategory":
				return ec.fieldContext_Equipment_equipmentCategory(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "tool":
				return ec.fieldContext_Equipment_tool(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "equipmentEntries":
				return ec.fieldContext_Equipment_equipmentEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[int])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentEntry_id(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentEntry_quantity(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentEntry_quantity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quantity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentEntry_quantity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentEntry_class(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentEntry_class(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Class(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Class)
	fc.Result = res
	return ec.marshalOClass2githubcomecshrevedndgenentClass(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentEntry_class(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Class_id(ctx, field)
			case "indx":
				return ec.fieldContext_Class_indx(ctx, field)
			case "name":
				return ec.fieldContext_Class_name(ctx, field)
			case "hitDie":
				return ec.fieldContext_Class_hitDie(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Class_proficiencies(ctx, field)
			case "proficiencyOptions":
				return ec.fieldContext_Class_proficiencyOptions(ctx, field)
			case "startingEquipment":
				return ec.fieldContext_Class_startingEquipment(ctx, field)
			case "savingThrows":
				return ec.fieldContext_Class_savingThrows(ctx, field)
			case "characters":
				return ec.fieldContext_Class_characters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Class", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EquipmentEntry_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.EquipmentEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EquipmentEntry_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Equipment)
	fc.Result = res
	return ec.marshalNEquipment2githubcomecshrevedndgenentEquipment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EquipmentEntry_equipment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EquipmentEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "equipmentCategory":
				return ec.fieldContext_Equipment_equipmentCategory(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "tool":
				return ec.fieldContext_Equipment_tool(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "equipmentEntries":
				return ec.fieldContext_Equipment_equipmentEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feat_id(ctx context.Context, field graphql.CollectedField, obj *ent.Feat) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feat_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feat_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feat",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feat_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Feat) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feat_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feat_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feat",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feat_name(ctx context.Context, field graphql.CollectedField, obj *ent.Feat) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feat_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feat_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feat",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feat_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Feat) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feat_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feat_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feat",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feature_id(ctx context.Context, field graphql.CollectedField, obj *ent.Feature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feature_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feature_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feature_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Feature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feature_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feature_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feature_name(ctx context.Context, field graphql.CollectedField, obj *ent.Feature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feature_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feature_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feature_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Feature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feature_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feature_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feature_level(ctx context.Context, field graphql.CollectedField, obj *ent.Feature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feature_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feature_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feature_prerequisites(ctx context.Context, field graphql.CollectedField, obj *ent.Feature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feature_prerequisites(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Prerequisites(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Prerequisite)
	fc.Result = res
	return ec.marshalOPrerequisite2githubcomecshrevedndgenentPrerequisite(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feature_prerequisites(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feature",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Prerequisite_id(ctx, field)
			case "prerequisiteType":
				return ec.fieldContext_Prerequisite_prerequisiteType(ctx, field)
			case "levelValue":
				return ec.fieldContext_Prerequisite_levelValue(ctx, field)
			case "featureValue":
				return ec.fieldContext_Prerequisite_featureValue(ctx, field)
			case "spellValue":
				return ec.fieldContext_Prerequisite_spellValue(ctx, field)
			case "feature":
				return ec.fieldContext_Prerequisite_feature(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Prerequisite", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Gear_id(ctx context.Context, field graphql.CollectedField, obj *ent.Gear) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Gear_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Gear_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Gear",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Gear_gearCategory(ctx context.Context, field graphql.CollectedField, obj *ent.Gear) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Gear_gearCategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GearCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Gear_gearCategory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Gear",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Gear_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Gear) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Gear_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Gear_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Gear",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Gear_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Gear) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Gear_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Equipment)
	fc.Result = res
	return ec.marshalNEquipment2githubcomecshrevedndgenentEquipment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Gear_equipment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Gear",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "equipmentCategory":
				return ec.fieldContext_Equipment_equipmentCategory(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "tool":
				return ec.fieldContext_Equipment_tool(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "equipmentEntries":
				return ec.fieldContext_Equipment_equipmentEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_id(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_name(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_languageType(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_languageType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LanguageType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(language.LanguageType)
	fc.Result = res
	return ec.marshalNLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_languageType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LanguageLanguageType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_script(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(language.Script)
	fc.Result = res
	return ec.marshalNLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_script(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LanguageScript does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_race(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_race(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Race(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Race)
	fc.Result = res
	return ec.marshalORace2githubcomecshrevedndgenentRace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_race(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Race_id(ctx, field)
			case "indx":
				return ec.fieldContext_Race_indx(ctx, field)
			case "name":
				return ec.fieldContext_Race_name(ctx, field)
			case "speed":
				return ec.fieldContext_Race_speed(ctx, field)
			case "size":
				return ec.fieldContext_Race_size(ctx, field)
			case "sizeDesc":
				return ec.fieldContext_Race_sizeDesc(ctx, field)
			case "alignmentDesc":
				return ec.fieldContext_Race_alignmentDesc(ctx, field)
			case "ageDesc":
				return ec.fieldContext_Race_ageDesc(ctx, field)
			case "languageDesc":
				return ec.fieldContext_Race_languageDesc(ctx, field)
			case "traits":
				return ec.fieldContext_Race_traits(ctx, field)
			case "startingProficiencies":
				return ec.fieldContext_Race_startingProficiencies(ctx, field)
			case "startingProficiencyOptions":
				return ec.fieldContext_Race_startingProficiencyOptions(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_Race_abilityBonuses(ctx, field)
			case "languages":
				return ec.fieldContext_Race_languages(ctx, field)
			case "languageOptions":
				return ec.fieldContext_Race_languageOptions(ctx, field)
			case "characters":
				return ec.fieldContext_Race_characters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Race", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_options(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_options(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Options(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.LanguageChoice)
	fc.Result = res
	return ec.marshalOLanguageChoice2githubcomecshrevedndgenentLanguageChoice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_options(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LanguageChoice_id(ctx, field)
			case "choose":
				return ec.fieldContext_LanguageChoice_choose(ctx, field)
			case "languages":
				return ec.fieldContext_LanguageChoice_languages(ctx, field)
			case "race":
				return ec.fieldContext_LanguageChoice_race(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LanguageChoice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LanguageChoice_id(ctx context.Context, field graphql.CollectedField, obj *ent.LanguageChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageChoice_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageChoice_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageChoice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LanguageChoice_choose(ctx context.Context, field graphql.CollectedField, obj *ent.LanguageChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageChoice_choose(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Choose, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageChoice_choose(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageChoice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LanguageChoice_languages(ctx context.Context, field graphql.CollectedField, obj *ent.LanguageChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageChoice_languages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Languages(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Language)
	fc.Result = res
	return ec.marshalOLanguage2githubcomecshrevedndgenentLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageChoice_languages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageChoice",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Language_id(ctx, field)
			case "indx":
				return ec.fieldContext_Language_indx(ctx, field)
			case "name":
				return ec.fieldContext_Language_name(ctx, field)
			case "desc":
				return ec.fieldContext_Language_desc(ctx, field)
			case "languageType":
				return ec.fieldContext_Language_languageType(ctx, field)
			case "script":
				return ec.fieldContext_Language_script(ctx, field)
			case "race":
				return ec.fieldContext_Language_race(ctx, field)
			case "options":
				return ec.fieldContext_Language_options(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Language", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LanguageChoice_race(ctx context.Context, field graphql.CollectedField, obj *ent.LanguageChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageChoice_race(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Race(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Race)
	fc.Result = res
	return ec.marshalORace2githubcomecshrevedndgenentRace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageChoice_race(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageChoice",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Race_id(ctx, field)
			case "indx":
				return ec.fieldContext_Race_indx(ctx, field)
			case "name":
				return ec.fieldContext_Race_name(ctx, field)
			case "speed":
				return ec.fieldContext_Race_speed(ctx, field)
			case "size":
				return ec.fieldContext_Race_size(ctx, field)
			case "sizeDesc":
				return ec.fieldContext_Race_sizeDesc(ctx, field)
			case "alignmentDesc":
				return ec.fieldContext_Race_alignmentDesc(ctx, field)
			case "ageDesc":
				return ec.fieldContext_Race_ageDesc(ctx, field)
			case "languageDesc":
				return ec.fieldContext_Race_languageDesc(ctx, field)
			case "traits":
				return ec.fieldContext_Race_traits(ctx, field)
			case "startingProficiencies":
				return ec.fieldContext_Race_startingProficiencies(ctx, field)
			case "startingProficiencyOptions":
				return ec.fieldContext_Race_startingProficiencyOptions(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_Race_abilityBonuses(ctx, field)
			case "languages":
				return ec.fieldContext_Race_languages(ctx, field)
			case "languageOptions":
				return ec.fieldContext_Race_languageOptions(ctx, field)
			case "characters":
				return ec.fieldContext_Race_characters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Race", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MagicSchool_id(ctx context.Context, field graphql.CollectedField, obj *ent.MagicSchool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MagicSchool_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MagicSchool_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MagicSchool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MagicSchool_indx(ctx context.Context, field graphql.CollectedField, obj *ent.MagicSchool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MagicSchool_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MagicSchool_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MagicSchool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MagicSchool_name(ctx context.Context, field graphql.CollectedField, obj *ent.MagicSchool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MagicSchool_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MagicSchool_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MagicSchool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MagicSchool_desc(ctx context.Context, field graphql.CollectedField, obj *ent.MagicSchool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MagicSchool_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MagicSchool_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MagicSchool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCharacter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createCharacter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateCharacter(rctx, fc.Args["input"].(ent.CreateCharacterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Character)
	fc.Result = res
	return ec.marshalNCharacter2githubcomecshrevedndgenentCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createCharacter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "age":
				return ec.fieldContext_Character_age(ctx, field)
			case "level":
				return ec.fieldContext_Character_level(ctx, field)
			case "proficiencyBonus":
				return ec.fieldContext_Character_proficiencyBonus(ctx, field)
			case "race":
				return ec.fieldContext_Character_race(ctx, field)
			case "class":
				return ec.fieldContext_Character_class(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characterAbilityScores":
				return ec.fieldContext_Character_characterAbilityScores(ctx, field)
			case "characterSkills":
				return ec.fieldContext_Character_characterSkills(ctx, field)
			case "characterProficiencies":
				return ec.fieldContext_Character_characterProficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCharacter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCharacter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCharacter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateCharacter(rctx, fc.Args["id"].(int), fc.Args["input"].(ent.UpdateCharacterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Character)
	fc.Result = res
	return ec.marshalNCharacter2githubcomecshrevedndgenentCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCharacter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "age":
				return ec.fieldContext_Character_age(ctx, field)
			case "level":
				return ec.fieldContext_Character_level(ctx, field)
			case "proficiencyBonus":
				return ec.fieldContext_Character_proficiencyBonus(ctx, field)
			case "race":
				return ec.fieldContext_Character_race(ctx, field)
			case "class":
				return ec.fieldContext_Character_class(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characterAbilityScores":
				return ec.fieldContext_Character_characterAbilityScores(ctx, field)
			case "characterSkills":
				return ec.fieldContext_Character_characterSkills(ctx, field)
			case "characterProficiencies":
				return ec.fieldContext_Character_characterProficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCharacter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[int])
	fc.Result = res
	return ec.marshalOCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[int]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[int])
	fc.Result = res
	return ec.marshalOCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Prerequisite_id(ctx context.Context, field graphql.CollectedField, obj *ent.Prerequisite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Prerequisite_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Prerequisite_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Prerequisite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Prerequisite_prerequisiteType(ctx context.Context, field graphql.CollectedField, obj *ent.Prerequisite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Prerequisite_prerequisiteType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrerequisiteType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(prerequisite.PrerequisiteType)
	fc.Result = res
	return ec.marshalNPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Prerequisite_prerequisiteType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Prerequisite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PrerequisitePrerequisiteType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Prerequisite_levelValue(ctx context.Context, field graphql.CollectedField, obj *ent.Prerequisite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Prerequisite_levelValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LevelValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Prerequisite_levelValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Prerequisite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Prerequisite_featureValue(ctx context.Context, field graphql.CollectedField, obj *ent.Prerequisite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Prerequisite_featureValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeatureValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Prerequisite_featureValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Prerequisite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Prerequisite_spellValue(ctx context.Context, field graphql.CollectedField, obj *ent.Prerequisite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Prerequisite_spellValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpellValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Prerequisite_spellValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Prerequisite",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Prerequisite_feature(ctx context.Context, field graphql.CollectedField, obj *ent.Prerequisite) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Prerequisite_feature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Feature(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Feature)
	fc.Result = res
	return ec.marshalOFeature2githubcomecshrevedndgenentFeature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Prerequisite_feature(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Prerequisite",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feature_id(ctx, field)
			case "indx":
				return ec.fieldContext_Feature_indx(ctx, field)
			case "name":
				return ec.fieldContext_Feature_name(ctx, field)
			case "desc":
				return ec.fieldContext_Feature_desc(ctx, field)
			case "level":
				return ec.fieldContext_Feature_level(ctx, field)
			case "prerequisites":
				return ec.fieldContext_Feature_prerequisites(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_id(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_name(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_reference(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_reference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_reference(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_race(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_race(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Race(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Race)
	fc.Result = res
	return ec.marshalORace2githubcomecshrevedndgenentRace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_race(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Race_id(ctx, field)
			case "indx":
				return ec.fieldContext_Race_indx(ctx, field)
			case "name":
				return ec.fieldContext_Race_name(ctx, field)
			case "speed":
				return ec.fieldContext_Race_speed(ctx, field)
			case "size":
				return ec.fieldContext_Race_size(ctx, field)
			case "sizeDesc":
				return ec.fieldContext_Race_sizeDesc(ctx, field)
			case "alignmentDesc":
				return ec.fieldContext_Race_alignmentDesc(ctx, field)
			case "ageDesc":
				return ec.fieldContext_Race_ageDesc(ctx, field)
			case "languageDesc":
				return ec.fieldContext_Race_languageDesc(ctx, field)
			case "traits":
				return ec.fieldContext_Race_traits(ctx, field)
			case "startingProficiencies":
				return ec.fieldContext_Race_startingProficiencies(ctx, field)
			case "startingProficiencyOptions":
				return ec.fieldContext_Race_startingProficiencyOptions(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_Race_abilityBonuses(ctx, field)
			case "languages":
				return ec.fieldContext_Race_languages(ctx, field)
			case "languageOptions":
				return ec.fieldContext_Race_languageOptions(ctx, field)
			case "characters":
				return ec.fieldContext_Race_characters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Race", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Proficiency_class(ctx context.Context, field graphql.CollectedField, obj *ent.Proficiency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Proficiency_class(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Class(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Class)
	fc.Result = res
	return ec.marshalOClass2githubcomecshrevedndgenentClass(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Proficiency_class(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Proficiency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Class_id(ctx, field)
			case "indx":
				return ec.fieldContext_Class_indx(ctx, field)
			case "name":
				return ec.fieldContext_Class_name(ctx, field)
			case "hitDie":
				return ec.fieldContext_Class_hitDie(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Class_proficiencies(ctx, field)
			case "proficiencyOptions":
				return ec.fieldContext_Class_proficiencyOptions(ctx, field)
			case "startingEquipment":
				return ec.fieldContext_Class_startingEquipment(ctx, field)
			case "savingThrows":
				return ec.fieldContext_Class_savingThrows(ctx, field)
			case "characters":
				return ec.fieldContext_Class_characters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Class", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProficiencyChoice_id(ctx context.Context, field graphql.CollectedField, obj *ent.ProficiencyChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProficiencyChoice_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProficiencyChoice_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProficiencyChoice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProficiencyChoice_choose(ctx context.Context, field graphql.CollectedField, obj *ent.ProficiencyChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProficiencyChoice_choose(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Choose, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProficiencyChoice_choose(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProficiencyChoice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProficiencyChoice_desc(ctx context.Context, field graphql.CollectedField, obj *ent.ProficiencyChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProficiencyChoice_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProficiencyChoice_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProficiencyChoice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProficiencyChoice_proficiencies(ctx context.Context, field graphql.CollectedField, obj *ent.ProficiencyChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProficiencyChoice_proficiencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proficiencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Proficiency)
	fc.Result = res
	return ec.marshalOProficiency2githubcomecshrevedndgenentProficiency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProficiencyChoice_proficiencies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProficiencyChoice",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Proficiency_id(ctx, field)
			case "indx":
				return ec.fieldContext_Proficiency_indx(ctx, field)
			case "name":
				return ec.fieldContext_Proficiency_name(ctx, field)
			case "reference":
				return ec.fieldContext_Proficiency_reference(ctx, field)
			case "race":
				return ec.fieldContext_Proficiency_race(ctx, field)
			case "class":
				return ec.fieldContext_Proficiency_class(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Proficiency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProficiencyChoice_race(ctx context.Context, field graphql.CollectedField, obj *ent.ProficiencyChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProficiencyChoice_race(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Race(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Race)
	fc.Result = res
	return ec.marshalORace2githubcomecshrevedndgenentRace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProficiencyChoice_race(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProficiencyChoice",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Race_id(ctx, field)
			case "indx":
				return ec.fieldContext_Race_indx(ctx, field)
			case "name":
				return ec.fieldContext_Race_name(ctx, field)
			case "speed":
				return ec.fieldContext_Race_speed(ctx, field)
			case "size":
				return ec.fieldContext_Race_size(ctx, field)
			case "sizeDesc":
				return ec.fieldContext_Race_sizeDesc(ctx, field)
			case "alignmentDesc":
				return ec.fieldContext_Race_alignmentDesc(ctx, field)
			case "ageDesc":
				return ec.fieldContext_Race_ageDesc(ctx, field)
			case "languageDesc":
				return ec.fieldContext_Race_languageDesc(ctx, field)
			case "traits":
				return ec.fieldContext_Race_traits(ctx, field)
			case "startingProficiencies":
				return ec.fieldContext_Race_startingProficiencies(ctx, field)
			case "startingProficiencyOptions":
				return ec.fieldContext_Race_startingProficiencyOptions(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_Race_abilityBonuses(ctx, field)
			case "languages":
				return ec.fieldContext_Race_languages(ctx, field)
			case "languageOptions":
				return ec.fieldContext_Race_languageOptions(ctx, field)
			case "characters":
				return ec.fieldContext_Race_characters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Race", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProficiencyChoice_class(ctx context.Context, field graphql.CollectedField, obj *ent.ProficiencyChoice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProficiencyChoice_class(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Class(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Class)
	fc.Result = res
	return ec.marshalOClass2githubcomecshrevedndgenentClass(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProficiencyChoice_class(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProficiencyChoice",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Class_id(ctx, field)
			case "indx":
				return ec.fieldContext_Class_indx(ctx, field)
			case "name":
				return ec.fieldContext_Class_name(ctx, field)
			case "hitDie":
				return ec.fieldContext_Class_hitDie(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Class_proficiencies(ctx, field)
			case "proficiencyOptions":
				return ec.fieldContext_Class_proficiencyOptions(ctx, field)
			case "startingEquipment":
				return ec.fieldContext_Class_startingEquipment(ctx, field)
			case "savingThrows":
				return ec.fieldContext_Class_savingThrows(ctx, field)
			case "characters":
				return ec.fieldContext_Class_characters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Class", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Property_id(ctx context.Context, field graphql.CollectedField, obj *ent.Property) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Property_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Property_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Property",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Property_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Property) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Property_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Property_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Property",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Property_name(ctx context.Context, field graphql.CollectedField, obj *ent.Property) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Property_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Property_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Property",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Property_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Property) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Property_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Property_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Property",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Property_weapons(ctx context.Context, field graphql.CollectedField, obj *ent.Property) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Property_weapons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weapons(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Weapon)
	fc.Result = res
	return ec.marshalOWeapon2githubcomecshrevedndgenentWeapon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Property_weapons(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Property",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Weapon_id(ctx, field)
			case "weaponCategory":
				return ec.fieldContext_Weapon_weaponCategory(ctx, field)
			case "weaponSubcategory":
				return ec.fieldContext_Weapon_weaponSubcategory(ctx, field)
			case "rangeNormal":
				return ec.fieldContext_Weapon_rangeNormal(ctx, field)
			case "rangeLong":
				return ec.fieldContext_Weapon_rangeLong(ctx, field)
			case "throwRangeNormal":
				return ec.fieldContext_Weapon_throwRangeNormal(ctx, field)
			case "throwRangeLong":
				return ec.fieldContext_Weapon_throwRangeLong(ctx, field)
			case "damageDice":
				return ec.fieldContext_Weapon_damageDice(ctx, field)
			case "properties":
				return ec.fieldContext_Weapon_properties(ctx, field)
			case "damageType":
				return ec.fieldContext_Weapon_damageType(ctx, field)
			case "equipment":
				return ec.fieldContext_Weapon_equipment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Weapon", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ent.Noder)
	fc.Result = res
	return ec.marshalONode2githubcomecshrevedndgenentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Nodes(rctx, fc.Args["ids"].([]int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ent.Noder)
	fc.Result = res
	return ec.marshalNNode2githubcomecshrevedndgenentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_abilityScores(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_abilityScores(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AbilityScores(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AbilityScore)
	fc.Result = res
	return ec.marshalNAbilityScore2githubcomecshrevedndgenentAbilityScore(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_abilityScores(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityScore_id(ctx, field)
			case "indx":
				return ec.fieldContext_AbilityScore_indx(ctx, field)
			case "name":
				return ec.fieldContext_AbilityScore_name(ctx, field)
			case "desc":
				return ec.fieldContext_AbilityScore_desc(ctx, field)
			case "fullName":
				return ec.fieldContext_AbilityScore_fullName(ctx, field)
			case "skills":
				return ec.fieldContext_AbilityScore_skills(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_alignments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_alignments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Alignments(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Alignment)
	fc.Result = res
	return ec.marshalNAlignment2githubcomecshrevedndgenentAlignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_alignments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Alignment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Alignment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Alignment_name(ctx, field)
			case "desc":
				return ec.fieldContext_Alignment_desc(ctx, field)
			case "abbr":
				return ec.fieldContext_Alignment_abbr(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alignment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_characters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Characters(rctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.CharacterOrder), fc.Args["where"].(*ent.CharacterWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.CharacterConnection)
	fc.Result = res
	return ec.marshalNCharacterConnection2githubcomecshrevedndgenentCharacterConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_CharacterConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_CharacterConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_CharacterConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_characters_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_classes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_classes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Classes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Class)
	fc.Result = res
	return ec.marshalNClass2githubcomecshrevedndgenentClass(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_classes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Class_id(ctx, field)
			case "indx":
				return ec.fieldContext_Class_indx(ctx, field)
			case "name":
				return ec.fieldContext_Class_name(ctx, field)
			case "hitDie":
				return ec.fieldContext_Class_hitDie(ctx, field)
			case "proficiencies":
				return ec.fieldContext_Class_proficiencies(ctx, field)
			case "proficiencyOptions":
				return ec.fieldContext_Class_proficiencyOptions(ctx, field)
			case "startingEquipment":
				return ec.fieldContext_Class_startingEquipment(ctx, field)
			case "savingThrows":
				return ec.fieldContext_Class_savingThrows(ctx, field)
			case "characters":
				return ec.fieldContext_Class_characters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Class", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_coins(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_coins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Coins(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Coin)
	fc.Result = res
	return ec.marshalNCoin2githubcomecshrevedndgenentCoin(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_coins(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Coin_id(ctx, field)
			case "indx":
				return ec.fieldContext_Coin_indx(ctx, field)
			case "name":
				return ec.fieldContext_Coin_name(ctx, field)
			case "desc":
				return ec.fieldContext_Coin_desc(ctx, field)
			case "goldConversionRate":
				return ec.fieldContext_Coin_goldConversionRate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Coin", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_conditions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_conditions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Conditions(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Condition)
	fc.Result = res
	return ec.marshalNCondition2githubcomecshrevedndgenentCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_conditions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Condition_id(ctx, field)
			case "indx":
				return ec.fieldContext_Condition_indx(ctx, field)
			case "name":
				return ec.fieldContext_Condition_name(ctx, field)
			case "desc":
				return ec.fieldContext_Condition_desc(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Condition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_damageTypes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_damageTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DamageTypes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.DamageType)
	fc.Result = res
	return ec.marshalNDamageType2githubcomecshrevedndgenentDamageType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_damageTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DamageType_id(ctx, field)
			case "indx":
				return ec.fieldContext_DamageType_indx(ctx, field)
			case "name":
				return ec.fieldContext_DamageType_name(ctx, field)
			case "desc":
				return ec.fieldContext_DamageType_desc(ctx, field)
			case "weapons":
				return ec.fieldContext_DamageType_weapons(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DamageType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_equipments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_equipments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Equipments(rctx, fc.Args["after"].(*entgql.Cursor[int]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[int]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.EquipmentOrder), fc.Args["where"].(*ent.EquipmentWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.EquipmentConnection)
	fc.Result = res
	return ec.marshalNEquipmentConnection2githubcomecshrevedndgenentEquipmentConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_equipments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_EquipmentConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_EquipmentConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_EquipmentConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EquipmentConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_equipments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_feats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_feats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Feats(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Feat)
	fc.Result = res
	return ec.marshalNFeat2githubcomecshrevedndgenentFeat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_feats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feat_id(ctx, field)
			case "indx":
				return ec.fieldContext_Feat_indx(ctx, field)
			case "name":
				return ec.fieldContext_Feat_name(ctx, field)
			case "desc":
				return ec.fieldContext_Feat_desc(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feat", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_features(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_features(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Features(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Feature)
	fc.Result = res
	return ec.marshalNFeature2githubcomecshrevedndgenentFeature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_features(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feature_id(ctx, field)
			case "indx":
				return ec.fieldContext_Feature_indx(ctx, field)
			case "name":
				return ec.fieldContext_Feature_name(ctx, field)
			case "desc":
				return ec.fieldContext_Feature_desc(ctx, field)
			case "level":
				return ec.fieldContext_Feature_level(ctx, field)
			case "prerequisites":
				return ec.fieldContext_Feature_prerequisites(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_languages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_languages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Languages(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Language)
	fc.Result = res
	return ec.marshalNLanguage2githubcomecshrevedndgenentLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_languages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Language_id(ctx, field)
			case "indx":
				return ec.fieldContext_Language_indx(ctx, field)
			case "name":
				return ec.fieldContext_Language_name(ctx, field)
			case "desc":
				return ec.fieldContext_Language_desc(ctx, field)
			case "languageType":
				return ec.fieldContext_Language_languageType(ctx, field)
			case "script":
				return ec.fieldContext_Language_script(ctx, field)
			case "race":
				return ec.fieldContext_Language_race(ctx, field)
			case "options":
				return ec.fieldContext_Language_options(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Language", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_magicSchools(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_magicSchools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MagicSchools(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.MagicSchool)
	fc.Result = res
	return ec.marshalNMagicSchool2githubcomecshrevedndgenentMagicSchool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_magicSchools(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_MagicSchool_id(ctx, field)
			case "indx":
				return ec.fieldContext_MagicSchool_indx(ctx, field)
			case "name":
				return ec.fieldContext_MagicSchool_name(ctx, field)
			case "desc":
				return ec.fieldContext_MagicSchool_desc(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MagicSchool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_properties(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Properties(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Property)
	fc.Result = res
	return ec.marshalNProperty2githubcomecshrevedndgenentProperty(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_properties(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Property_id(ctx, field)
			case "indx":
				return ec.fieldContext_Property_indx(ctx, field)
			case "name":
				return ec.fieldContext_Property_name(ctx, field)
			case "desc":
				return ec.fieldContext_Property_desc(ctx, field)
			case "weapons":
				return ec.fieldContext_Property_weapons(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Property", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_races(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_races(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Races(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Race)
	fc.Result = res
	return ec.marshalNRace2githubcomecshrevedndgenentRace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_races(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Race_id(ctx, field)
			case "indx":
				return ec.fieldContext_Race_indx(ctx, field)
			case "name":
				return ec.fieldContext_Race_name(ctx, field)
			case "speed":
				return ec.fieldContext_Race_speed(ctx, field)
			case "size":
				return ec.fieldContext_Race_size(ctx, field)
			case "sizeDesc":
				return ec.fieldContext_Race_sizeDesc(ctx, field)
			case "alignmentDesc":
				return ec.fieldContext_Race_alignmentDesc(ctx, field)
			case "ageDesc":
				return ec.fieldContext_Race_ageDesc(ctx, field)
			case "languageDesc":
				return ec.fieldContext_Race_languageDesc(ctx, field)
			case "traits":
				return ec.fieldContext_Race_traits(ctx, field)
			case "startingProficiencies":
				return ec.fieldContext_Race_startingProficiencies(ctx, field)
			case "startingProficiencyOptions":
				return ec.fieldContext_Race_startingProficiencyOptions(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_Race_abilityBonuses(ctx, field)
			case "languages":
				return ec.fieldContext_Race_languages(ctx, field)
			case "languageOptions":
				return ec.fieldContext_Race_languageOptions(ctx, field)
			case "characters":
				return ec.fieldContext_Race_characters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Race", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_rules(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_rules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Rules(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Rule)
	fc.Result = res
	return ec.marshalNRule2githubcomecshrevedndgenentRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_rules(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Rule_id(ctx, field)
			case "indx":
				return ec.fieldContext_Rule_indx(ctx, field)
			case "name":
				return ec.fieldContext_Rule_name(ctx, field)
			case "desc":
				return ec.fieldContext_Rule_desc(ctx, field)
			case "sections":
				return ec.fieldContext_Rule_sections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Rule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ruleSections(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ruleSections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RuleSections(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.RuleSection)
	fc.Result = res
	return ec.marshalNRuleSection2githubcomecshrevedndgenentRuleSection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ruleSections(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuleSection_id(ctx, field)
			case "indx":
				return ec.fieldContext_RuleSection_indx(ctx, field)
			case "name":
				return ec.fieldContext_RuleSection_name(ctx, field)
			case "desc":
				return ec.fieldContext_RuleSection_desc(ctx, field)
			case "rule":
				return ec.fieldContext_RuleSection_rule(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuleSection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_skills(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_skills(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Skills(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Skill)
	fc.Result = res
	return ec.marshalNSkill2githubcomecshrevedndgenentSkill(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_skills(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Skill_id(ctx, field)
			case "indx":
				return ec.fieldContext_Skill_indx(ctx, field)
			case "name":
				return ec.fieldContext_Skill_name(ctx, field)
			case "desc":
				return ec.fieldContext_Skill_desc(ctx, field)
			case "abilityScore":
				return ec.fieldContext_Skill_abilityScore(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Skill", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_id(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_name(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_speed(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_speed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Speed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_speed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_size(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(race.Size)
	fc.Result = res
	return ec.marshalNRaceSize2githubcomecshrevedndgenentraceSize(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RaceSize does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_sizeDesc(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_sizeDesc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SizeDesc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_sizeDesc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_alignmentDesc(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_alignmentDesc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlignmentDesc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_alignmentDesc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_ageDesc(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_ageDesc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgeDesc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_ageDesc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_languageDesc(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_languageDesc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LanguageDesc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_languageDesc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_traits(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_traits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Traits(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Trait)
	fc.Result = res
	return ec.marshalOTrait2githubcomecshrevedndgenentTrait(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_traits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trait_id(ctx, field)
			case "indx":
				return ec.fieldContext_Trait_indx(ctx, field)
			case "name":
				return ec.fieldContext_Trait_name(ctx, field)
			case "desc":
				return ec.fieldContext_Trait_desc(ctx, field)
			case "race":
				return ec.fieldContext_Trait_race(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trait", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_startingProficiencies(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_startingProficiencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartingProficiencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Proficiency)
	fc.Result = res
	return ec.marshalOProficiency2githubcomecshrevedndgenentProficiency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_startingProficiencies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Proficiency_id(ctx, field)
			case "indx":
				return ec.fieldContext_Proficiency_indx(ctx, field)
			case "name":
				return ec.fieldContext_Proficiency_name(ctx, field)
			case "reference":
				return ec.fieldContext_Proficiency_reference(ctx, field)
			case "race":
				return ec.fieldContext_Proficiency_race(ctx, field)
			case "class":
				return ec.fieldContext_Proficiency_class(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Proficiency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_startingProficiencyOptions(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_startingProficiencyOptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartingProficiencyOptions(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ProficiencyChoice)
	fc.Result = res
	return ec.marshalOProficiencyChoice2githubcomecshrevedndgenentProficiencyChoice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_startingProficiencyOptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProficiencyChoice_id(ctx, field)
			case "choose":
				return ec.fieldContext_ProficiencyChoice_choose(ctx, field)
			case "desc":
				return ec.fieldContext_ProficiencyChoice_desc(ctx, field)
			case "proficiencies":
				return ec.fieldContext_ProficiencyChoice_proficiencies(ctx, field)
			case "race":
				return ec.fieldContext_ProficiencyChoice_race(ctx, field)
			case "class":
				return ec.fieldContext_ProficiencyChoice_class(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProficiencyChoice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_abilityBonuses(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_abilityBonuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbilityBonuses(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AbilityScore)
	fc.Result = res
	return ec.marshalOAbilityScore2githubcomecshrevedndgenentAbilityScore(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_abilityBonuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityScore_id(ctx, field)
			case "indx":
				return ec.fieldContext_AbilityScore_indx(ctx, field)
			case "name":
				return ec.fieldContext_AbilityScore_name(ctx, field)
			case "desc":
				return ec.fieldContext_AbilityScore_desc(ctx, field)
			case "fullName":
				return ec.fieldContext_AbilityScore_fullName(ctx, field)
			case "skills":
				return ec.fieldContext_AbilityScore_skills(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_languages(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_languages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Languages(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Language)
	fc.Result = res
	return ec.marshalOLanguage2githubcomecshrevedndgenentLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_languages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Language_id(ctx, field)
			case "indx":
				return ec.fieldContext_Language_indx(ctx, field)
			case "name":
				return ec.fieldContext_Language_name(ctx, field)
			case "desc":
				return ec.fieldContext_Language_desc(ctx, field)
			case "languageType":
				return ec.fieldContext_Language_languageType(ctx, field)
			case "script":
				return ec.fieldContext_Language_script(ctx, field)
			case "race":
				return ec.fieldContext_Language_race(ctx, field)
			case "options":
				return ec.fieldContext_Language_options(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Language", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_languageOptions(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_languageOptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LanguageOptions(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.LanguageChoice)
	fc.Result = res
	return ec.marshalOLanguageChoice2githubcomecshrevedndgenentLanguageChoice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_languageOptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LanguageChoice_id(ctx, field)
			case "choose":
				return ec.fieldContext_LanguageChoice_choose(ctx, field)
			case "languages":
				return ec.fieldContext_LanguageChoice_languages(ctx, field)
			case "race":
				return ec.fieldContext_LanguageChoice_race(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LanguageChoice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Race_characters(ctx context.Context, field graphql.CollectedField, obj *ent.Race) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Race_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Character)
	fc.Result = res
	return ec.marshalOCharacter2githubcomecshrevedndgenentCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Race_characters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Race",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "age":
				return ec.fieldContext_Character_age(ctx, field)
			case "level":
				return ec.fieldContext_Character_level(ctx, field)
			case "proficiencyBonus":
				return ec.fieldContext_Character_proficiencyBonus(ctx, field)
			case "race":
				return ec.fieldContext_Character_race(ctx, field)
			case "class":
				return ec.fieldContext_Character_class(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characterAbilityScores":
				return ec.fieldContext_Character_characterAbilityScores(ctx, field)
			case "characterSkills":
				return ec.fieldContext_Character_characterSkills(ctx, field)
			case "characterProficiencies":
				return ec.fieldContext_Character_characterProficiencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Rule_id(ctx context.Context, field graphql.CollectedField, obj *ent.Rule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Rule_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Rule_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Rule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Rule_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Rule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Rule_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Rule_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Rule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Rule_name(ctx context.Context, field graphql.CollectedField, obj *ent.Rule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Rule_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Rule_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Rule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Rule_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Rule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Rule_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Rule_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Rule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Rule_sections(ctx context.Context, field graphql.CollectedField, obj *ent.Rule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Rule_sections(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sections(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.RuleSection)
	fc.Result = res
	return ec.marshalORuleSection2githubcomecshrevedndgenentRuleSection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Rule_sections(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Rule",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RuleSection_id(ctx, field)
			case "indx":
				return ec.fieldContext_RuleSection_indx(ctx, field)
			case "name":
				return ec.fieldContext_RuleSection_name(ctx, field)
			case "desc":
				return ec.fieldContext_RuleSection_desc(ctx, field)
			case "rule":
				return ec.fieldContext_RuleSection_rule(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuleSection", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuleSection_id(ctx context.Context, field graphql.CollectedField, obj *ent.RuleSection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuleSection_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuleSection_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuleSection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuleSection_indx(ctx context.Context, field graphql.CollectedField, obj *ent.RuleSection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuleSection_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuleSection_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuleSection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuleSection_name(ctx context.Context, field graphql.CollectedField, obj *ent.RuleSection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuleSection_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuleSection_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuleSection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuleSection_desc(ctx context.Context, field graphql.CollectedField, obj *ent.RuleSection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuleSection_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuleSection_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuleSection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuleSection_rule(ctx context.Context, field graphql.CollectedField, obj *ent.RuleSection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuleSection_rule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rule(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Rule)
	fc.Result = res
	return ec.marshalORule2githubcomecshrevedndgenentRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuleSection_rule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuleSection",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Rule_id(ctx, field)
			case "indx":
				return ec.fieldContext_Rule_indx(ctx, field)
			case "name":
				return ec.fieldContext_Rule_name(ctx, field)
			case "desc":
				return ec.fieldContext_Rule_desc(ctx, field)
			case "sections":
				return ec.fieldContext_Rule_sections(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Rule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_id(ctx context.Context, field graphql.CollectedField, obj *ent.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_name(ctx context.Context, field graphql.CollectedField, obj *ent.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Skill_abilityScore(ctx context.Context, field graphql.CollectedField, obj *ent.Skill) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Skill_abilityScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbilityScore(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AbilityScore)
	fc.Result = res
	return ec.marshalOAbilityScore2githubcomecshrevedndgenentAbilityScore(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Skill_abilityScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Skill",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AbilityScore_id(ctx, field)
			case "indx":
				return ec.fieldContext_AbilityScore_indx(ctx, field)
			case "name":
				return ec.fieldContext_AbilityScore_name(ctx, field)
			case "desc":
				return ec.fieldContext_AbilityScore_desc(ctx, field)
			case "fullName":
				return ec.fieldContext_AbilityScore_fullName(ctx, field)
			case "skills":
				return ec.fieldContext_AbilityScore_skills(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbilityScore", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tool_id(ctx context.Context, field graphql.CollectedField, obj *ent.Tool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tool_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tool_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tool_toolCategory(ctx context.Context, field graphql.CollectedField, obj *ent.Tool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tool_toolCategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToolCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tool_toolCategory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tool_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Tool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tool_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tool_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tool_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Tool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tool_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Equipment)
	fc.Result = res
	return ec.marshalNEquipment2githubcomecshrevedndgenentEquipment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tool_equipment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tool",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "equipmentCategory":
				return ec.fieldContext_Equipment_equipmentCategory(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "tool":
				return ec.fieldContext_Equipment_tool(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "equipmentEntries":
				return ec.fieldContext_Equipment_equipmentEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trait_id(ctx context.Context, field graphql.CollectedField, obj *ent.Trait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trait_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trait_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trait_indx(ctx context.Context, field graphql.CollectedField, obj *ent.Trait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trait_indx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trait_indx(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trait_name(ctx context.Context, field graphql.CollectedField, obj *ent.Trait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trait_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trait_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trait_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Trait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trait_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trait_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trait",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trait_race(ctx context.Context, field graphql.CollectedField, obj *ent.Trait) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trait_race(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Race(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Race)
	fc.Result = res
	return ec.marshalORace2githubcomecshrevedndgenentRace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trait_race(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trait",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Race_id(ctx, field)
			case "indx":
				return ec.fieldContext_Race_indx(ctx, field)
			case "name":
				return ec.fieldContext_Race_name(ctx, field)
			case "speed":
				return ec.fieldContext_Race_speed(ctx, field)
			case "size":
				return ec.fieldContext_Race_size(ctx, field)
			case "sizeDesc":
				return ec.fieldContext_Race_sizeDesc(ctx, field)
			case "alignmentDesc":
				return ec.fieldContext_Race_alignmentDesc(ctx, field)
			case "ageDesc":
				return ec.fieldContext_Race_ageDesc(ctx, field)
			case "languageDesc":
				return ec.fieldContext_Race_languageDesc(ctx, field)
			case "traits":
				return ec.fieldContext_Race_traits(ctx, field)
			case "startingProficiencies":
				return ec.fieldContext_Race_startingProficiencies(ctx, field)
			case "startingProficiencyOptions":
				return ec.fieldContext_Race_startingProficiencyOptions(ctx, field)
			case "abilityBonuses":
				return ec.fieldContext_Race_abilityBonuses(ctx, field)
			case "languages":
				return ec.fieldContext_Race_languages(ctx, field)
			case "languageOptions":
				return ec.fieldContext_Race_languageOptions(ctx, field)
			case "characters":
				return ec.fieldContext_Race_characters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Race", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vehicle_id(ctx context.Context, field graphql.CollectedField, obj *ent.Vehicle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vehicle_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vehicle_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vehicle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vehicle_vehicleCategory(ctx context.Context, field graphql.CollectedField, obj *ent.Vehicle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vehicle_vehicleCategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(vehicle.VehicleCategory)
	fc.Result = res
	return ec.marshalNVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vehicle_vehicleCategory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vehicle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VehicleVehicleCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vehicle_capacity(ctx context.Context, field graphql.CollectedField, obj *ent.Vehicle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vehicle_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vehicle_capacity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vehicle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vehicle_desc(ctx context.Context, field graphql.CollectedField, obj *ent.Vehicle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vehicle_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Desc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vehicle_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vehicle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vehicle_speedQuantity(ctx context.Context, field graphql.CollectedField, obj *ent.Vehicle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vehicle_speedQuantity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpeedQuantity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vehicle_speedQuantity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vehicle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vehicle_speedUnits(ctx context.Context, field graphql.CollectedField, obj *ent.Vehicle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vehicle_speedUnits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpeedUnits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(vehicle.SpeedUnits)
	fc.Result = res
	return ec.marshalOVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vehicle_speedUnits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vehicle",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type VehicleSpeedUnits does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Vehicle_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Vehicle) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Vehicle_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Equipment)
	fc.Result = res
	return ec.marshalNEquipment2githubcomecshrevedndgenentEquipment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Vehicle_equipment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Vehicle",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "equipmentCategory":
				return ec.fieldContext_Equipment_equipmentCategory(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "tool":
				return ec.fieldContext_Equipment_tool(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "equipmentEntries":
				return ec.fieldContext_Equipment_equipmentEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_id(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_weaponCategory(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_weaponCategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WeaponCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(weapon.WeaponCategory)
	fc.Result = res
	return ec.marshalNWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_weaponCategory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WeaponWeaponCategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_weaponSubcategory(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_weaponSubcategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WeaponSubcategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(weapon.WeaponSubcategory)
	fc.Result = res
	return ec.marshalNWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_weaponSubcategory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WeaponWeaponSubcategory does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_rangeNormal(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_rangeNormal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RangeNormal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_rangeNormal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_rangeLong(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_rangeLong(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RangeLong, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_rangeLong(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_throwRangeNormal(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_throwRangeNormal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ThrowRangeNormal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_throwRangeNormal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_throwRangeLong(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_throwRangeLong(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ThrowRangeLong, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_throwRangeLong(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_damageDice(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_damageDice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DamageDice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_damageDice(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_properties(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Properties(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Property)
	fc.Result = res
	return ec.marshalOProperty2githubcomecshrevedndgenentProperty(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_properties(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Property_id(ctx, field)
			case "indx":
				return ec.fieldContext_Property_indx(ctx, field)
			case "name":
				return ec.fieldContext_Property_name(ctx, field)
			case "desc":
				return ec.fieldContext_Property_desc(ctx, field)
			case "weapons":
				return ec.fieldContext_Property_weapons(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Property", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_damageType(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_damageType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DamageType(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.DamageType)
	fc.Result = res
	return ec.marshalODamageType2githubcomecshrevedndgenentDamageType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_damageType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DamageType_id(ctx, field)
			case "indx":
				return ec.fieldContext_DamageType_indx(ctx, field)
			case "name":
				return ec.fieldContext_DamageType_name(ctx, field)
			case "desc":
				return ec.fieldContext_DamageType_desc(ctx, field)
			case "weapons":
				return ec.fieldContext_DamageType_weapons(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DamageType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Weapon_equipment(ctx context.Context, field graphql.CollectedField, obj *ent.Weapon) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Weapon_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Equipment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Equipment)
	fc.Result = res
	return ec.marshalNEquipment2githubcomecshrevedndgenentEquipment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Weapon_equipment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Weapon",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Equipment_id(ctx, field)
			case "indx":
				return ec.fieldContext_Equipment_indx(ctx, field)
			case "name":
				return ec.fieldContext_Equipment_name(ctx, field)
			case "equipmentCategory":
				return ec.fieldContext_Equipment_equipmentCategory(ctx, field)
			case "weight":
				return ec.fieldContext_Equipment_weight(ctx, field)
			case "cost":
				return ec.fieldContext_Equipment_cost(ctx, field)
			case "gear":
				return ec.fieldContext_Equipment_gear(ctx, field)
			case "tool":
				return ec.fieldContext_Equipment_tool(ctx, field)
			case "weapon":
				return ec.fieldContext_Equipment_weapon(ctx, field)
			case "vehicle":
				return ec.fieldContext_Equipment_vehicle(ctx, field)
			case "armor":
				return ec.fieldContext_Equipment_armor(ctx, field)
			case "equipmentEntries":
				return ec.fieldContext_Equipment_equipmentEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Equipment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAbilityScoreOrder(ctx context.Context, obj interface{}) (ent.AbilityScoreOrder, error) {
	var it ent.AbilityScoreOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNAbilityScoreOrderField2githubcomecshrevedndgenentAbilityScoreOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAbilityScoreWhereInput(ctx context.Context, obj interface{}) (ent.AbilityScoreWhereInput, error) {
	var it ent.AbilityScoreWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "fullName", "fullNameNEQ", "fullNameIn", "fullNameNotIn", "fullNameGT", "fullNameGTE", "fullNameLT", "fullNameLTE", "fullNameContains", "fullNameHasPrefix", "fullNameHasSuffix", "fullNameEqualFold", "fullNameContainsFold", "hasSkills", "hasSkillsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOAbilityScoreWhereInput2githubcomecshrevedndgenentAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOAbilityScoreWhereInput2githubcomecshrevedndgenentAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOAbilityScoreWhereInput2githubcomecshrevedndgenentAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "fullName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullName"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullName = data
		case "fullNameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullNameNEQ = data
		case "fullNameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullNameIn = data
		case "fullNameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullNameNotIn = data
		case "fullNameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullNameGT = data
		case "fullNameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullNameGTE = data
		case "fullNameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullNameLT = data
		case "fullNameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullNameLTE = data
		case "fullNameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullNameContains = data
		case "fullNameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullNameHasPrefix = data
		case "fullNameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullNameHasSuffix = data
		case "fullNameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullNameEqualFold = data
		case "fullNameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fullNameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FullNameContainsFold = data
		case "hasSkills":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSkills"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSkills = data
		case "hasSkillsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSkillsWith"))
			data, err := ec.unmarshalOSkillWhereInput2githubcomecshrevedndgenentSkillWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSkillsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAlignmentOrder(ctx context.Context, obj interface{}) (ent.AlignmentOrder, error) {
	var it ent.AlignmentOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNAlignmentOrderField2githubcomecshrevedndgenentAlignmentOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAlignmentWhereInput(ctx context.Context, obj interface{}) (ent.AlignmentWhereInput, error) {
	var it ent.AlignmentWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "abbr", "abbrNEQ", "abbrIn", "abbrNotIn"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOAlignmentWhereInput2githubcomecshrevedndgenentAlignmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOAlignmentWhereInput2githubcomecshrevedndgenentAlignmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOAlignmentWhereInput2githubcomecshrevedndgenentAlignmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "abbr":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbr"))
			data, err := ec.unmarshalOAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx, v)
			if err != nil {
				return it, err
			}
			it.Abbr = data
		case "abbrNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrNEQ"))
			data, err := ec.unmarshalOAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx, v)
			if err != nil {
				return it, err
			}
			it.AbbrNEQ = data
		case "abbrIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrIn"))
			data, err := ec.unmarshalOAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx, v)
			if err != nil {
				return it, err
			}
			it.AbbrIn = data
		case "abbrNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abbrNotIn"))
			data, err := ec.unmarshalOAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx, v)
			if err != nil {
				return it, err
			}
			it.AbbrNotIn = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputArmorWhereInput(ctx context.Context, obj interface{}) (ent.ArmorWhereInput, error) {
	var it ent.ArmorWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "armorCategory", "armorCategoryNEQ", "armorCategoryIn", "armorCategoryNotIn", "strMinimum", "strMinimumNEQ", "strMinimumIn", "strMinimumNotIn", "strMinimumGT", "strMinimumGTE", "strMinimumLT", "strMinimumLTE", "stealthDisadvantage", "stealthDisadvantageNEQ", "acBase", "acBaseNEQ", "acBaseIn", "acBaseNotIn", "acBaseGT", "acBaseGTE", "acBaseLT", "acBaseLTE", "acDexBonus", "acDexBonusNEQ", "acMaxBonus", "acMaxBonusNEQ", "acMaxBonusIn", "acMaxBonusNotIn", "acMaxBonusGT", "acMaxBonusGTE", "acMaxBonusLT", "acMaxBonusLTE", "hasEquipment", "hasEquipmentWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOArmorWhereInput2githubcomecshrevedndgenentArmorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOArmorWhereInput2githubcomecshrevedndgenentArmorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOArmorWhereInput2githubcomecshrevedndgenentArmorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "armorCategory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorCategory"))
			data, err := ec.unmarshalOArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.ArmorCategory = data
		case "armorCategoryNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorCategoryNEQ"))
			data, err := ec.unmarshalOArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.ArmorCategoryNEQ = data
		case "armorCategoryIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorCategoryIn"))
			data, err := ec.unmarshalOArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.ArmorCategoryIn = data
		case "armorCategoryNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("armorCategoryNotIn"))
			data, err := ec.unmarshalOArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.ArmorCategoryNotIn = data
		case "strMinimum":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("strMinimum"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StrMinimum = data
		case "strMinimumNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("strMinimumNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StrMinimumNEQ = data
		case "strMinimumIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("strMinimumIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StrMinimumIn = data
		case "strMinimumNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("strMinimumNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StrMinimumNotIn = data
		case "strMinimumGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("strMinimumGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StrMinimumGT = data
		case "strMinimumGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("strMinimumGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StrMinimumGTE = data
		case "strMinimumLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("strMinimumLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StrMinimumLT = data
		case "strMinimumLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("strMinimumLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StrMinimumLTE = data
		case "stealthDisadvantage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stealthDisadvantage"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StealthDisadvantage = data
		case "stealthDisadvantageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stealthDisadvantageNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StealthDisadvantageNEQ = data
		case "acBase":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acBase"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcBase = data
		case "acBaseNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acBaseNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcBaseNEQ = data
		case "acBaseIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acBaseIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcBaseIn = data
		case "acBaseNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acBaseNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcBaseNotIn = data
		case "acBaseGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acBaseGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcBaseGT = data
		case "acBaseGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acBaseGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcBaseGTE = data
		case "acBaseLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acBaseLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcBaseLT = data
		case "acBaseLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acBaseLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcBaseLTE = data
		case "acDexBonus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acDexBonus"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcDexBonus = data
		case "acDexBonusNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acDexBonusNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcDexBonusNEQ = data
		case "acMaxBonus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acMaxBonus"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcMaxBonus = data
		case "acMaxBonusNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acMaxBonusNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcMaxBonusNEQ = data
		case "acMaxBonusIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acMaxBonusIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcMaxBonusIn = data
		case "acMaxBonusNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acMaxBonusNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcMaxBonusNotIn = data
		case "acMaxBonusGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acMaxBonusGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcMaxBonusGT = data
		case "acMaxBonusGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acMaxBonusGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcMaxBonusGTE = data
		case "acMaxBonusLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acMaxBonusLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcMaxBonusLT = data
		case "acMaxBonusLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acMaxBonusLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcMaxBonusLTE = data
		case "hasEquipment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipment = data
		case "hasEquipmentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			data, err := ec.unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipmentWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCharacterAbilityScoreWhereInput(ctx context.Context, obj interface{}) (ent.CharacterAbilityScoreWhereInput, error) {
	var it ent.CharacterAbilityScoreWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "score", "scoreNEQ", "scoreIn", "scoreNotIn", "scoreGT", "scoreGTE", "scoreLT", "scoreLTE", "modifier", "modifierNEQ", "modifierIn", "modifierNotIn", "modifierGT", "modifierGTE", "modifierLT", "modifierLTE", "hasCharacter", "hasCharacterWith", "hasAbilityScore", "hasAbilityScoreWith", "hasCharacterSkills", "hasCharacterSkillsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOCharacterAbilityScoreWhereInput2githubcomecshrevedndgenentCharacterAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOCharacterAbilityScoreWhereInput2githubcomecshrevedndgenentCharacterAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOCharacterAbilityScoreWhereInput2githubcomecshrevedndgenentCharacterAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "score":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Score = data
		case "scoreNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreNEQ = data
		case "scoreIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreIn = data
		case "scoreNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreNotIn = data
		case "scoreGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreGT = data
		case "scoreGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreGTE = data
		case "scoreLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreLT = data
		case "scoreLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreLTE = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		case "modifierNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifierNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModifierNEQ = data
		case "modifierIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifierIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModifierIn = data
		case "modifierNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifierNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModifierNotIn = data
		case "modifierGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifierGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModifierGT = data
		case "modifierGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifierGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModifierGTE = data
		case "modifierLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifierLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModifierLT = data
		case "modifierLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifierLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ModifierLTE = data
		case "hasCharacter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacter"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacter = data
		case "hasCharacterWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterWith"))
			data, err := ec.unmarshalOCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterWith = data
		case "hasAbilityScore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityScore"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAbilityScore = data
		case "hasAbilityScoreWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityScoreWith"))
			data, err := ec.unmarshalOAbilityScoreWhereInput2githubcomecshrevedndgenentAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAbilityScoreWith = data
		case "hasCharacterSkills":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterSkills"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterSkills = data
		case "hasCharacterSkillsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterSkillsWith"))
			data, err := ec.unmarshalOCharacterSkillWhereInput2githubcomecshrevedndgenentCharacterSkillWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterSkillsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCharacterOrder(ctx context.Context, obj interface{}) (ent.CharacterOrder, error) {
	var it ent.CharacterOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNCharacterOrderField2githubcomecshrevedndgenentCharacterOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCharacterProficiencyWhereInput(ctx context.Context, obj interface{}) (ent.CharacterProficiencyWhereInput, error) {
	var it ent.CharacterProficiencyWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "proficiencyType", "proficiencyTypeNEQ", "proficiencyTypeIn", "proficiencyTypeNotIn", "proficiencySource", "proficiencySourceNEQ", "proficiencySourceIn", "proficiencySourceNotIn", "hasCharacter", "hasCharacterWith", "hasProficiency", "hasProficiencyWith", "hasCharacterSkill", "hasCharacterSkillWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOCharacterProficiencyWhereInput2githubcomecshrevedndgenentCharacterProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOCharacterProficiencyWhereInput2githubcomecshrevedndgenentCharacterProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOCharacterProficiencyWhereInput2githubcomecshrevedndgenentCharacterProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "proficiencyType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyType"))
			data, err := ec.unmarshalOCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyType = data
		case "proficiencyTypeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyTypeNEQ"))
			data, err := ec.unmarshalOCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyTypeNEQ = data
		case "proficiencyTypeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyTypeIn"))
			data, err := ec.unmarshalOCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyTypeIn = data
		case "proficiencyTypeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyTypeNotIn"))
			data, err := ec.unmarshalOCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyTypeNotIn = data
		case "proficiencySource":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencySource"))
			data, err := ec.unmarshalOCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencySource = data
		case "proficiencySourceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencySourceNEQ"))
			data, err := ec.unmarshalOCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencySourceNEQ = data
		case "proficiencySourceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencySourceIn"))
			data, err := ec.unmarshalOCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencySourceIn = data
		case "proficiencySourceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencySourceNotIn"))
			data, err := ec.unmarshalOCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencySourceNotIn = data
		case "hasCharacter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacter"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacter = data
		case "hasCharacterWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterWith"))
			data, err := ec.unmarshalOCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterWith = data
		case "hasProficiency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficiency"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasProficiency = data
		case "hasProficiencyWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficiencyWith"))
			data, err := ec.unmarshalOProficiencyWhereInput2githubcomecshrevedndgenentProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasProficiencyWith = data
		case "hasCharacterSkill":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterSkill"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterSkill = data
		case "hasCharacterSkillWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterSkillWith"))
			data, err := ec.unmarshalOCharacterSkillWhereInput2githubcomecshrevedndgenentCharacterSkillWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterSkillWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCharacterSkillWhereInput(ctx context.Context, obj interface{}) (ent.CharacterSkillWhereInput, error) {
	var it ent.CharacterSkillWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "proficient", "proficientNEQ", "hasCharacter", "hasCharacterWith", "hasSkill", "hasSkillWith", "hasCharacterAbilityScore", "hasCharacterAbilityScoreWith", "hasCharacterProficiency", "hasCharacterProficiencyWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOCharacterSkillWhereInput2githubcomecshrevedndgenentCharacterSkillWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOCharacterSkillWhereInput2githubcomecshrevedndgenentCharacterSkillWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOCharacterSkillWhereInput2githubcomecshrevedndgenentCharacterSkillWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "proficient":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficient"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Proficient = data
		case "proficientNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficientNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficientNEQ = data
		case "hasCharacter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacter"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacter = data
		case "hasCharacterWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterWith"))
			data, err := ec.unmarshalOCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterWith = data
		case "hasSkill":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSkill"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSkill = data
		case "hasSkillWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSkillWith"))
			data, err := ec.unmarshalOSkillWhereInput2githubcomecshrevedndgenentSkillWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSkillWith = data
		case "hasCharacterAbilityScore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterAbilityScore"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterAbilityScore = data
		case "hasCharacterAbilityScoreWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterAbilityScoreWith"))
			data, err := ec.unmarshalOCharacterAbilityScoreWhereInput2githubcomecshrevedndgenentCharacterAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterAbilityScoreWith = data
		case "hasCharacterProficiency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterProficiency"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterProficiency = data
		case "hasCharacterProficiencyWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterProficiencyWith"))
			data, err := ec.unmarshalOCharacterProficiencyWhereInput2githubcomecshrevedndgenentCharacterProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterProficiencyWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCharacterWhereInput(ctx context.Context, obj interface{}) (ent.CharacterWhereInput, error) {
	var it ent.CharacterWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "age", "ageNEQ", "ageIn", "ageNotIn", "ageGT", "ageGTE", "ageLT", "ageLTE", "level", "levelNEQ", "levelIn", "levelNotIn", "levelGT", "levelGTE", "levelLT", "levelLTE", "proficiencyBonus", "proficiencyBonusNEQ", "proficiencyBonusIn", "proficiencyBonusNotIn", "proficiencyBonusGT", "proficiencyBonusGTE", "proficiencyBonusLT", "proficiencyBonusLTE", "hasRace", "hasRaceWith", "hasClass", "hasClassWith", "hasAlignment", "hasAlignmentWith", "hasCharacterAbilityScores", "hasCharacterAbilityScoresWith", "hasCharacterSkills", "hasCharacterSkillsWith", "hasCharacterProficiencies", "hasCharacterProficienciesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "age":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("age"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Age = data
		case "ageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeNEQ = data
		case "ageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeIn = data
		case "ageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeNotIn = data
		case "ageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeGT = data
		case "ageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeGTE = data
		case "ageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeLT = data
		case "ageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeLTE = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "levelNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelNEQ = data
		case "levelIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelIn = data
		case "levelNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelNotIn = data
		case "levelGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelGT = data
		case "levelGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelGTE = data
		case "levelLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelLT = data
		case "levelLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelLTE = data
		case "proficiencyBonus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyBonus"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyBonus = data
		case "proficiencyBonusNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyBonusNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyBonusNEQ = data
		case "proficiencyBonusIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyBonusIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyBonusIn = data
		case "proficiencyBonusNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyBonusNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyBonusNotIn = data
		case "proficiencyBonusGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyBonusGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyBonusGT = data
		case "proficiencyBonusGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyBonusGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyBonusGTE = data
		case "proficiencyBonusLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyBonusLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyBonusLT = data
		case "proficiencyBonusLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyBonusLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyBonusLTE = data
		case "hasRace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRace"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRace = data
		case "hasRaceWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRaceWith"))
			data, err := ec.unmarshalORaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRaceWith = data
		case "hasClass":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClass"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasClass = data
		case "hasClassWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClassWith"))
			data, err := ec.unmarshalOClassWhereInput2githubcomecshrevedndgenentClassWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasClassWith = data
		case "hasAlignment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAlignment"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAlignment = data
		case "hasAlignmentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAlignmentWith"))
			data, err := ec.unmarshalOAlignmentWhereInput2githubcomecshrevedndgenentAlignmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAlignmentWith = data
		case "hasCharacterAbilityScores":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterAbilityScores"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterAbilityScores = data
		case "hasCharacterAbilityScoresWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterAbilityScoresWith"))
			data, err := ec.unmarshalOCharacterAbilityScoreWhereInput2githubcomecshrevedndgenentCharacterAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterAbilityScoresWith = data
		case "hasCharacterSkills":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterSkills"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterSkills = data
		case "hasCharacterSkillsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterSkillsWith"))
			data, err := ec.unmarshalOCharacterSkillWhereInput2githubcomecshrevedndgenentCharacterSkillWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterSkillsWith = data
		case "hasCharacterProficiencies":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterProficiencies"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterProficiencies = data
		case "hasCharacterProficienciesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacterProficienciesWith"))
			data, err := ec.unmarshalOCharacterProficiencyWhereInput2githubcomecshrevedndgenentCharacterProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacterProficienciesWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputClassOrder(ctx context.Context, obj interface{}) (ent.ClassOrder, error) {
	var it ent.ClassOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNClassOrderField2githubcomecshrevedndgenentClassOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputClassWhereInput(ctx context.Context, obj interface{}) (ent.ClassWhereInput, error) {
	var it ent.ClassWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hitDie", "hitDieNEQ", "hitDieIn", "hitDieNotIn", "hitDieGT", "hitDieGTE", "hitDieLT", "hitDieLTE", "hasProficiencies", "hasProficienciesWith", "hasProficiencyOptions", "hasProficiencyOptionsWith", "hasStartingEquipment", "hasStartingEquipmentWith", "hasSavingThrows", "hasSavingThrowsWith", "hasCharacters", "hasCharactersWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOClassWhereInput2githubcomecshrevedndgenentClassWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOClassWhereInput2githubcomecshrevedndgenentClassWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOClassWhereInput2githubcomecshrevedndgenentClassWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "hitDie":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDie"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HitDie = data
		case "hitDieNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HitDieNEQ = data
		case "hitDieIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HitDieIn = data
		case "hitDieNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HitDieNotIn = data
		case "hitDieGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HitDieGT = data
		case "hitDieGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HitDieGTE = data
		case "hitDieLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HitDieLT = data
		case "hitDieLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hitDieLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HitDieLTE = data
		case "hasProficiencies":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficiencies"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasProficiencies = data
		case "hasProficienciesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficienciesWith"))
			data, err := ec.unmarshalOProficiencyWhereInput2githubcomecshrevedndgenentProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasProficienciesWith = data
		case "hasProficiencyOptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficiencyOptions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasProficiencyOptions = data
		case "hasProficiencyOptionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficiencyOptionsWith"))
			data, err := ec.unmarshalOProficiencyChoiceWhereInput2githubcomecshrevedndgenentProficiencyChoiceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasProficiencyOptionsWith = data
		case "hasStartingEquipment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStartingEquipment"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasStartingEquipment = data
		case "hasStartingEquipmentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStartingEquipmentWith"))
			data, err := ec.unmarshalOEquipmentEntryWhereInput2githubcomecshrevedndgenentEquipmentEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasStartingEquipmentWith = data
		case "hasSavingThrows":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSavingThrows"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSavingThrows = data
		case "hasSavingThrowsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSavingThrowsWith"))
			data, err := ec.unmarshalOAbilityScoreWhereInput2githubcomecshrevedndgenentAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSavingThrowsWith = data
		case "hasCharacters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacters"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacters = data
		case "hasCharactersWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharactersWith"))
			data, err := ec.unmarshalOCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharactersWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCoinOrder(ctx context.Context, obj interface{}) (ent.CoinOrder, error) {
	var it ent.CoinOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNCoinOrderField2githubcomecshrevedndgenentCoinOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCoinWhereInput(ctx context.Context, obj interface{}) (ent.CoinWhereInput, error) {
	var it ent.CoinWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "goldConversionRate", "goldConversionRateNEQ", "goldConversionRateIn", "goldConversionRateNotIn", "goldConversionRateGT", "goldConversionRateGTE", "goldConversionRateLT", "goldConversionRateLTE"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOCoinWhereInput2githubcomecshrevedndgenentCoinWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOCoinWhereInput2githubcomecshrevedndgenentCoinWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOCoinWhereInput2githubcomecshrevedndgenentCoinWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "goldConversionRate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("goldConversionRate"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GoldConversionRate = data
		case "goldConversionRateNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("goldConversionRateNEQ"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GoldConversionRateNEQ = data
		case "goldConversionRateIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("goldConversionRateIn"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GoldConversionRateIn = data
		case "goldConversionRateNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("goldConversionRateNotIn"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GoldConversionRateNotIn = data
		case "goldConversionRateGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("goldConversionRateGT"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GoldConversionRateGT = data
		case "goldConversionRateGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("goldConversionRateGTE"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GoldConversionRateGTE = data
		case "goldConversionRateLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("goldConversionRateLT"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GoldConversionRateLT = data
		case "goldConversionRateLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("goldConversionRateLTE"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GoldConversionRateLTE = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputConditionOrder(ctx context.Context, obj interface{}) (ent.ConditionOrder, error) {
	var it ent.ConditionOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNConditionOrderField2githubcomecshrevedndgenentConditionOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputConditionWhereInput(ctx context.Context, obj interface{}) (ent.ConditionWhereInput, error) {
	var it ent.ConditionWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOConditionWhereInput2githubcomecshrevedndgenentConditionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOConditionWhereInput2githubcomecshrevedndgenentConditionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOConditionWhereInput2githubcomecshrevedndgenentConditionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCostWhereInput(ctx context.Context, obj interface{}) (ent.CostWhereInput, error) {
	var it ent.CostWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "quantity", "quantityNEQ", "quantityIn", "quantityNotIn", "quantityGT", "quantityGTE", "quantityLT", "quantityLTE", "hasCoin", "hasCoinWith", "hasEquipment", "hasEquipmentWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOCostWhereInput2githubcomecshrevedndgenentCostWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOCostWhereInput2githubcomecshrevedndgenentCostWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOCostWhereInput2githubcomecshrevedndgenentCostWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "quantity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantity"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Quantity = data
		case "quantityNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityNEQ = data
		case "quantityIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityIn = data
		case "quantityNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityNotIn = data
		case "quantityGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityGT = data
		case "quantityGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityGTE = data
		case "quantityLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityLT = data
		case "quantityLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityLTE = data
		case "hasCoin":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCoin"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCoin = data
		case "hasCoinWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCoinWith"))
			data, err := ec.unmarshalOCoinWhereInput2githubcomecshrevedndgenentCoinWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCoinWith = data
		case "hasEquipment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipment = data
		case "hasEquipmentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			data, err := ec.unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipmentWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCharacterAbilityScoreInput(ctx context.Context, obj interface{}) (ent.CreateCharacterAbilityScoreInput, error) {
	var it ent.CreateCharacterAbilityScoreInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"score", "modifier", "characterID", "abilityScoreID", "characterSkillIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "score":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Score = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		case "characterID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterID"))
			data, err := ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterID = data
		case "abilityScoreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abilityScoreID"))
			data, err := ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AbilityScoreID = data
		case "characterSkillIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterSkillIDs"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterSkillIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCharacterInput(ctx context.Context, obj interface{}) (ent.CreateCharacterInput, error) {
	var it ent.CreateCharacterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "age", "level", "proficiencyBonus", "raceID", "classID", "alignmentID", "characterAbilityScoreIDs", "characterSkillIDs", "characterProficiencyIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "age":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("age"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Age = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "proficiencyBonus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyBonus"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyBonus = data
		case "raceID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("raceID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RaceID = data
		case "classID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("classID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClassID = data
		case "alignmentID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentID = data
		case "characterAbilityScoreIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterAbilityScoreIDs"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterAbilityScoreIDs = data
		case "characterSkillIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterSkillIDs"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterSkillIDs = data
		case "characterProficiencyIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterProficiencyIDs"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterProficiencyIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCharacterProficiencyInput(ctx context.Context, obj interface{}) (ent.CreateCharacterProficiencyInput, error) {
	var it ent.CreateCharacterProficiencyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"proficiencyType", "proficiencySource", "characterID", "proficiencyID", "characterSkillID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "proficiencyType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyType"))
			data, err := ec.unmarshalNCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyType = data
		case "proficiencySource":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencySource"))
			data, err := ec.unmarshalNCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencySource = data
		case "characterID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterID"))
			data, err := ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterID = data
		case "proficiencyID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyID"))
			data, err := ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyID = data
		case "characterSkillID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterSkillID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterSkillID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCharacterSkillInput(ctx context.Context, obj interface{}) (ent.CreateCharacterSkillInput, error) {
	var it ent.CreateCharacterSkillInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"proficient", "characterID", "skillID", "characterAbilityScoreID", "characterProficiencyID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "proficient":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficient"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Proficient = data
		case "characterID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterID"))
			data, err := ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterID = data
		case "skillID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skillID"))
			data, err := ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SkillID = data
		case "characterAbilityScoreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterAbilityScoreID"))
			data, err := ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterAbilityScoreID = data
		case "characterProficiencyID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterProficiencyID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterProficiencyID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDamageTypeOrder(ctx context.Context, obj interface{}) (ent.DamageTypeOrder, error) {
	var it ent.DamageTypeOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNDamageTypeOrderField2githubcomecshrevedndgenentDamageTypeOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDamageTypeWhereInput(ctx context.Context, obj interface{}) (ent.DamageTypeWhereInput, error) {
	var it ent.DamageTypeWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasWeapons", "hasWeaponsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalODamageTypeWhereInput2githubcomecshrevedndgenentDamageTypeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalODamageTypeWhereInput2githubcomecshrevedndgenentDamageTypeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalODamageTypeWhereInput2githubcomecshrevedndgenentDamageTypeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "hasWeapons":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeapons"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWeapons = data
		case "hasWeaponsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeaponsWith"))
			data, err := ec.unmarshalOWeaponWhereInput2githubcomecshrevedndgenentWeaponWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWeaponsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEquipmentEntryWhereInput(ctx context.Context, obj interface{}) (ent.EquipmentEntryWhereInput, error) {
	var it ent.EquipmentEntryWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "quantity", "quantityNEQ", "quantityIn", "quantityNotIn", "quantityGT", "quantityGTE", "quantityLT", "quantityLTE", "hasClass", "hasClassWith", "hasEquipment", "hasEquipmentWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOEquipmentEntryWhereInput2githubcomecshrevedndgenentEquipmentEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOEquipmentEntryWhereInput2githubcomecshrevedndgenentEquipmentEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOEquipmentEntryWhereInput2githubcomecshrevedndgenentEquipmentEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "quantity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantity"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Quantity = data
		case "quantityNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityNEQ = data
		case "quantityIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityIn = data
		case "quantityNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityNotIn = data
		case "quantityGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityGT = data
		case "quantityGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityGTE = data
		case "quantityLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityLT = data
		case "quantityLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quantityLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuantityLTE = data
		case "hasClass":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClass"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasClass = data
		case "hasClassWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClassWith"))
			data, err := ec.unmarshalOClassWhereInput2githubcomecshrevedndgenentClassWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasClassWith = data
		case "hasEquipment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipment = data
		case "hasEquipmentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			data, err := ec.unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipmentWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEquipmentOrder(ctx context.Context, obj interface{}) (ent.EquipmentOrder, error) {
	var it ent.EquipmentOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNEquipmentOrderField2githubcomecshrevedndgenentEquipmentOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEquipmentWhereInput(ctx context.Context, obj interface{}) (ent.EquipmentWhereInput, error) {
	var it ent.EquipmentWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "equipmentCategory", "equipmentCategoryNEQ", "equipmentCategoryIn", "equipmentCategoryNotIn", "weight", "weightNEQ", "weightIn", "weightNotIn", "weightGT", "weightGTE", "weightLT", "weightLTE", "weightIsNil", "weightNotNil", "hasCost", "hasCostWith", "hasGear", "hasGearWith", "hasTool", "hasToolWith", "hasWeapon", "hasWeaponWith", "hasVehicle", "hasVehicleWith", "hasArmor", "hasArmorWith", "hasEquipmentEntries", "hasEquipmentEntriesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "equipmentCategory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("equipmentCategory"))
			data, err := ec.unmarshalOEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.EquipmentCategory = data
		case "equipmentCategoryNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("equipmentCategoryNEQ"))
			data, err := ec.unmarshalOEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.EquipmentCategoryNEQ = data
		case "equipmentCategoryIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("equipmentCategoryIn"))
			data, err := ec.unmarshalOEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.EquipmentCategoryIn = data
		case "equipmentCategoryNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("equipmentCategoryNotIn"))
			data, err := ec.unmarshalOEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.EquipmentCategoryNotIn = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "weightNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightNEQ"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeightNEQ = data
		case "weightIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightIn"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeightIn = data
		case "weightNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightNotIn"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeightNotIn = data
		case "weightGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightGT"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeightGT = data
		case "weightGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightGTE"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeightGTE = data
		case "weightLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightLT"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeightLT = data
		case "weightLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightLTE"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeightLTE = data
		case "weightIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeightIsNil = data
		case "weightNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weightNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeightNotNil = data
		case "hasCost":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCost"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCost = data
		case "hasCostWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCostWith"))
			data, err := ec.unmarshalOCostWhereInput2githubcomecshrevedndgenentCostWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCostWith = data
		case "hasGear":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGear"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasGear = data
		case "hasGearWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasGearWith"))
			data, err := ec.unmarshalOGearWhereInput2githubcomecshrevedndgenentGearWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasGearWith = data
		case "hasTool":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTool"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTool = data
		case "hasToolWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasToolWith"))
			data, err := ec.unmarshalOToolWhereInput2githubcomecshrevedndgenentToolWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasToolWith = data
		case "hasWeapon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeapon"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWeapon = data
		case "hasWeaponWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeaponWith"))
			data, err := ec.unmarshalOWeaponWhereInput2githubcomecshrevedndgenentWeaponWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWeaponWith = data
		case "hasVehicle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVehicle"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasVehicle = data
		case "hasVehicleWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVehicleWith"))
			data, err := ec.unmarshalOVehicleWhereInput2githubcomecshrevedndgenentVehicleWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasVehicleWith = data
		case "hasArmor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasArmor"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasArmor = data
		case "hasArmorWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasArmorWith"))
			data, err := ec.unmarshalOArmorWhereInput2githubcomecshrevedndgenentArmorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasArmorWith = data
		case "hasEquipmentEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentEntries"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipmentEntries = data
		case "hasEquipmentEntriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentEntriesWith"))
			data, err := ec.unmarshalOEquipmentEntryWhereInput2githubcomecshrevedndgenentEquipmentEntryWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipmentEntriesWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeatOrder(ctx context.Context, obj interface{}) (ent.FeatOrder, error) {
	var it ent.FeatOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNFeatOrderField2githubcomecshrevedndgenentFeatOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeatWhereInput(ctx context.Context, obj interface{}) (ent.FeatWhereInput, error) {
	var it ent.FeatWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOFeatWhereInput2githubcomecshrevedndgenentFeatWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOFeatWhereInput2githubcomecshrevedndgenentFeatWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOFeatWhereInput2githubcomecshrevedndgenentFeatWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeatureOrder(ctx context.Context, obj interface{}) (ent.FeatureOrder, error) {
	var it ent.FeatureOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNFeatureOrderField2githubcomecshrevedndgenentFeatureOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeatureWhereInput(ctx context.Context, obj interface{}) (ent.FeatureWhereInput, error) {
	var it ent.FeatureWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "level", "levelNEQ", "levelIn", "levelNotIn", "levelGT", "levelGTE", "levelLT", "levelLTE", "hasPrerequisites", "hasPrerequisitesWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOFeatureWhereInput2githubcomecshrevedndgenentFeatureWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOFeatureWhereInput2githubcomecshrevedndgenentFeatureWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOFeatureWhereInput2githubcomecshrevedndgenentFeatureWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "levelNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelNEQ = data
		case "levelIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelIn = data
		case "levelNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelNotIn = data
		case "levelGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelGT = data
		case "levelGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelGTE = data
		case "levelLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelLT = data
		case "levelLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelLTE = data
		case "hasPrerequisites":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPrerequisites"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasPrerequisites = data
		case "hasPrerequisitesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPrerequisitesWith"))
			data, err := ec.unmarshalOPrerequisiteWhereInput2githubcomecshrevedndgenentPrerequisiteWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasPrerequisitesWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGearWhereInput(ctx context.Context, obj interface{}) (ent.GearWhereInput, error) {
	var it ent.GearWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "gearCategory", "gearCategoryNEQ", "gearCategoryIn", "gearCategoryNotIn", "gearCategoryGT", "gearCategoryGTE", "gearCategoryLT", "gearCategoryLTE", "gearCategoryContains", "gearCategoryHasPrefix", "gearCategoryHasSuffix", "gearCategoryEqualFold", "gearCategoryContainsFold", "hasEquipment", "hasEquipmentWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOGearWhereInput2githubcomecshrevedndgenentGearWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOGearWhereInput2githubcomecshrevedndgenentGearWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOGearWhereInput2githubcomecshrevedndgenentGearWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "gearCategory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategory"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategory = data
		case "gearCategoryNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategoryNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategoryNEQ = data
		case "gearCategoryIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategoryIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategoryIn = data
		case "gearCategoryNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategoryNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategoryNotIn = data
		case "gearCategoryGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategoryGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategoryGT = data
		case "gearCategoryGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategoryGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategoryGTE = data
		case "gearCategoryLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategoryLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategoryLT = data
		case "gearCategoryLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategoryLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategoryLTE = data
		case "gearCategoryContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategoryContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategoryContains = data
		case "gearCategoryHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategoryHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategoryHasPrefix = data
		case "gearCategoryHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategoryHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategoryHasSuffix = data
		case "gearCategoryEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategoryEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategoryEqualFold = data
		case "gearCategoryContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gearCategoryContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GearCategoryContainsFold = data
		case "hasEquipment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipment = data
		case "hasEquipmentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			data, err := ec.unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipmentWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLanguageChoiceWhereInput(ctx context.Context, obj interface{}) (ent.LanguageChoiceWhereInput, error) {
	var it ent.LanguageChoiceWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "choose", "chooseNEQ", "chooseIn", "chooseNotIn", "chooseGT", "chooseGTE", "chooseLT", "chooseLTE", "hasLanguages", "hasLanguagesWith", "hasRace", "hasRaceWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOLanguageChoiceWhereInput2githubcomecshrevedndgenentLanguageChoiceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOLanguageChoiceWhereInput2githubcomecshrevedndgenentLanguageChoiceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOLanguageChoiceWhereInput2githubcomecshrevedndgenentLanguageChoiceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "choose":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("choose"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Choose = data
		case "chooseNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseNEQ = data
		case "chooseIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseIn = data
		case "chooseNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseNotIn = data
		case "chooseGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseGT = data
		case "chooseGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseGTE = data
		case "chooseLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseLT = data
		case "chooseLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseLTE = data
		case "hasLanguages":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLanguages"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLanguages = data
		case "hasLanguagesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLanguagesWith"))
			data, err := ec.unmarshalOLanguageWhereInput2githubcomecshrevedndgenentLanguageWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLanguagesWith = data
		case "hasRace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRace"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRace = data
		case "hasRaceWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRaceWith"))
			data, err := ec.unmarshalORaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRaceWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLanguageOrder(ctx context.Context, obj interface{}) (ent.LanguageOrder, error) {
	var it ent.LanguageOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNLanguageOrderField2githubcomecshrevedndgenentLanguageOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLanguageWhereInput(ctx context.Context, obj interface{}) (ent.LanguageWhereInput, error) {
	var it ent.LanguageWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "languageType", "languageTypeNEQ", "languageTypeIn", "languageTypeNotIn", "script", "scriptNEQ", "scriptIn", "scriptNotIn", "hasRace", "hasRaceWith", "hasOptions", "hasOptionsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOLanguageWhereInput2githubcomecshrevedndgenentLanguageWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOLanguageWhereInput2githubcomecshrevedndgenentLanguageWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOLanguageWhereInput2githubcomecshrevedndgenentLanguageWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "languageType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageType"))
			data, err := ec.unmarshalOLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageType = data
		case "languageTypeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageTypeNEQ"))
			data, err := ec.unmarshalOLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageTypeNEQ = data
		case "languageTypeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageTypeIn"))
			data, err := ec.unmarshalOLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageTypeIn = data
		case "languageTypeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageTypeNotIn"))
			data, err := ec.unmarshalOLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageTypeNotIn = data
		case "script":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("script"))
			data, err := ec.unmarshalOLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx, v)
			if err != nil {
				return it, err
			}
			it.Script = data
		case "scriptNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scriptNEQ"))
			data, err := ec.unmarshalOLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScriptNEQ = data
		case "scriptIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scriptIn"))
			data, err := ec.unmarshalOLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScriptIn = data
		case "scriptNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scriptNotIn"))
			data, err := ec.unmarshalOLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScriptNotIn = data
		case "hasRace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRace"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRace = data
		case "hasRaceWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRaceWith"))
			data, err := ec.unmarshalORaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRaceWith = data
		case "hasOptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOptions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOptions = data
		case "hasOptionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasOptionsWith"))
			data, err := ec.unmarshalOLanguageChoiceWhereInput2githubcomecshrevedndgenentLanguageChoiceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasOptionsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMagicSchoolOrder(ctx context.Context, obj interface{}) (ent.MagicSchoolOrder, error) {
	var it ent.MagicSchoolOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNMagicSchoolOrderField2githubcomecshrevedndgenentMagicSchoolOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMagicSchoolWhereInput(ctx context.Context, obj interface{}) (ent.MagicSchoolWhereInput, error) {
	var it ent.MagicSchoolWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOMagicSchoolWhereInput2githubcomecshrevedndgenentMagicSchoolWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOMagicSchoolWhereInput2githubcomecshrevedndgenentMagicSchoolWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOMagicSchoolWhereInput2githubcomecshrevedndgenentMagicSchoolWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPrerequisiteWhereInput(ctx context.Context, obj interface{}) (ent.PrerequisiteWhereInput, error) {
	var it ent.PrerequisiteWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "prerequisiteType", "prerequisiteTypeNEQ", "prerequisiteTypeIn", "prerequisiteTypeNotIn", "levelValue", "levelValueNEQ", "levelValueIn", "levelValueNotIn", "levelValueGT", "levelValueGTE", "levelValueLT", "levelValueLTE", "levelValueIsNil", "levelValueNotNil", "featureValue", "featureValueNEQ", "featureValueIn", "featureValueNotIn", "featureValueGT", "featureValueGTE", "featureValueLT", "featureValueLTE", "featureValueContains", "featureValueHasPrefix", "featureValueHasSuffix", "featureValueIsNil", "featureValueNotNil", "featureValueEqualFold", "featureValueContainsFold", "spellValue", "spellValueNEQ", "spellValueIn", "spellValueNotIn", "spellValueGT", "spellValueGTE", "spellValueLT", "spellValueLTE", "spellValueContains", "spellValueHasPrefix", "spellValueHasSuffix", "spellValueIsNil", "spellValueNotNil", "spellValueEqualFold", "spellValueContainsFold", "hasFeature", "hasFeatureWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOPrerequisiteWhereInput2githubcomecshrevedndgenentPrerequisiteWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOPrerequisiteWhereInput2githubcomecshrevedndgenentPrerequisiteWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOPrerequisiteWhereInput2githubcomecshrevedndgenentPrerequisiteWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "prerequisiteType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prerequisiteType"))
			data, err := ec.unmarshalOPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrerequisiteType = data
		case "prerequisiteTypeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prerequisiteTypeNEQ"))
			data, err := ec.unmarshalOPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrerequisiteTypeNEQ = data
		case "prerequisiteTypeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prerequisiteTypeIn"))
			data, err := ec.unmarshalOPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrerequisiteTypeIn = data
		case "prerequisiteTypeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prerequisiteTypeNotIn"))
			data, err := ec.unmarshalOPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrerequisiteTypeNotIn = data
		case "levelValue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelValue"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelValue = data
		case "levelValueNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelValueNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelValueNEQ = data
		case "levelValueIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelValueIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelValueIn = data
		case "levelValueNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelValueNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelValueNotIn = data
		case "levelValueGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelValueGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelValueGT = data
		case "levelValueGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelValueGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelValueGTE = data
		case "levelValueLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelValueLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelValueLT = data
		case "levelValueLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelValueLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelValueLTE = data
		case "levelValueIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelValueIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelValueIsNil = data
		case "levelValueNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("levelValueNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelValueNotNil = data
		case "featureValue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValue"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValue = data
		case "featureValueNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueNEQ = data
		case "featureValueIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueIn = data
		case "featureValueNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueNotIn = data
		case "featureValueGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueGT = data
		case "featureValueGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueGTE = data
		case "featureValueLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueLT = data
		case "featureValueLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueLTE = data
		case "featureValueContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueContains = data
		case "featureValueHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueHasPrefix = data
		case "featureValueHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueHasSuffix = data
		case "featureValueIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueIsNil = data
		case "featureValueNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueNotNil = data
		case "featureValueEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueEqualFold = data
		case "featureValueContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("featureValueContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeatureValueContainsFold = data
		case "spellValue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValue"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValue = data
		case "spellValueNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueNEQ = data
		case "spellValueIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueIn = data
		case "spellValueNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueNotIn = data
		case "spellValueGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueGT = data
		case "spellValueGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueGTE = data
		case "spellValueLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueLT = data
		case "spellValueLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueLTE = data
		case "spellValueContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueContains = data
		case "spellValueHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueHasPrefix = data
		case "spellValueHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueHasSuffix = data
		case "spellValueIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueIsNil = data
		case "spellValueNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueNotNil = data
		case "spellValueEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueEqualFold = data
		case "spellValueContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spellValueContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpellValueContainsFold = data
		case "hasFeature":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasFeature"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasFeature = data
		case "hasFeatureWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasFeatureWith"))
			data, err := ec.unmarshalOFeatureWhereInput2githubcomecshrevedndgenentFeatureWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasFeatureWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProficiencyChoiceWhereInput(ctx context.Context, obj interface{}) (ent.ProficiencyChoiceWhereInput, error) {
	var it ent.ProficiencyChoiceWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "choose", "chooseNEQ", "chooseIn", "chooseNotIn", "chooseGT", "chooseGTE", "chooseLT", "chooseLTE", "hasProficiencies", "hasProficienciesWith", "hasRace", "hasRaceWith", "hasClass", "hasClassWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOProficiencyChoiceWhereInput2githubcomecshrevedndgenentProficiencyChoiceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOProficiencyChoiceWhereInput2githubcomecshrevedndgenentProficiencyChoiceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOProficiencyChoiceWhereInput2githubcomecshrevedndgenentProficiencyChoiceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "choose":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("choose"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Choose = data
		case "chooseNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseNEQ = data
		case "chooseIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseIn = data
		case "chooseNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseNotIn = data
		case "chooseGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseGT = data
		case "chooseGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseGTE = data
		case "chooseLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseLT = data
		case "chooseLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chooseLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChooseLTE = data
		case "hasProficiencies":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficiencies"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasProficiencies = data
		case "hasProficienciesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProficienciesWith"))
			data, err := ec.unmarshalOProficiencyWhereInput2githubcomecshrevedndgenentProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasProficienciesWith = data
		case "hasRace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRace"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRace = data
		case "hasRaceWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRaceWith"))
			data, err := ec.unmarshalORaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRaceWith = data
		case "hasClass":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClass"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasClass = data
		case "hasClassWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClassWith"))
			data, err := ec.unmarshalOClassWhereInput2githubcomecshrevedndgenentClassWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasClassWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProficiencyOrder(ctx context.Context, obj interface{}) (ent.ProficiencyOrder, error) {
	var it ent.ProficiencyOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNProficiencyOrderField2githubcomecshrevedndgenentProficiencyOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProficiencyWhereInput(ctx context.Context, obj interface{}) (ent.ProficiencyWhereInput, error) {
	var it ent.ProficiencyWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "reference", "referenceNEQ", "referenceIn", "referenceNotIn", "referenceGT", "referenceGTE", "referenceLT", "referenceLTE", "referenceContains", "referenceHasPrefix", "referenceHasSuffix", "referenceEqualFold", "referenceContainsFold", "hasRace", "hasRaceWith", "hasClass", "hasClassWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOProficiencyWhereInput2githubcomecshrevedndgenentProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOProficiencyWhereInput2githubcomecshrevedndgenentProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOProficiencyWhereInput2githubcomecshrevedndgenentProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "reference":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reference"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Reference = data
		case "referenceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referenceNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReferenceNEQ = data
		case "referenceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referenceIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReferenceIn = data
		case "referenceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referenceNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReferenceNotIn = data
		case "referenceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referenceGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReferenceGT = data
		case "referenceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referenceGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReferenceGTE = data
		case "referenceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referenceLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReferenceLT = data
		case "referenceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referenceLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReferenceLTE = data
		case "referenceContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referenceContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReferenceContains = data
		case "referenceHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referenceHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReferenceHasPrefix = data
		case "referenceHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referenceHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReferenceHasSuffix = data
		case "referenceEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referenceEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReferenceEqualFold = data
		case "referenceContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("referenceContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReferenceContainsFold = data
		case "hasRace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRace"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRace = data
		case "hasRaceWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRaceWith"))
			data, err := ec.unmarshalORaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRaceWith = data
		case "hasClass":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClass"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasClass = data
		case "hasClassWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClassWith"))
			data, err := ec.unmarshalOClassWhereInput2githubcomecshrevedndgenentClassWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasClassWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPropertyOrder(ctx context.Context, obj interface{}) (ent.PropertyOrder, error) {
	var it ent.PropertyOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNPropertyOrderField2githubcomecshrevedndgenentPropertyOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPropertyWhereInput(ctx context.Context, obj interface{}) (ent.PropertyWhereInput, error) {
	var it ent.PropertyWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasWeapons", "hasWeaponsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOPropertyWhereInput2githubcomecshrevedndgenentPropertyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOPropertyWhereInput2githubcomecshrevedndgenentPropertyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOPropertyWhereInput2githubcomecshrevedndgenentPropertyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "hasWeapons":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeapons"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWeapons = data
		case "hasWeaponsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeaponsWith"))
			data, err := ec.unmarshalOWeaponWhereInput2githubcomecshrevedndgenentWeaponWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWeaponsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRaceOrder(ctx context.Context, obj interface{}) (ent.RaceOrder, error) {
	var it ent.RaceOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNRaceOrderField2githubcomecshrevedndgenentRaceOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRaceWhereInput(ctx context.Context, obj interface{}) (ent.RaceWhereInput, error) {
	var it ent.RaceWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "speed", "speedNEQ", "speedIn", "speedNotIn", "speedGT", "speedGTE", "speedLT", "speedLTE", "size", "sizeNEQ", "sizeIn", "sizeNotIn", "sizeDesc", "sizeDescNEQ", "sizeDescIn", "sizeDescNotIn", "sizeDescGT", "sizeDescGTE", "sizeDescLT", "sizeDescLTE", "sizeDescContains", "sizeDescHasPrefix", "sizeDescHasSuffix", "sizeDescEqualFold", "sizeDescContainsFold", "alignmentDesc", "alignmentDescNEQ", "alignmentDescIn", "alignmentDescNotIn", "alignmentDescGT", "alignmentDescGTE", "alignmentDescLT", "alignmentDescLTE", "alignmentDescContains", "alignmentDescHasPrefix", "alignmentDescHasSuffix", "alignmentDescEqualFold", "alignmentDescContainsFold", "ageDesc", "ageDescNEQ", "ageDescIn", "ageDescNotIn", "ageDescGT", "ageDescGTE", "ageDescLT", "ageDescLTE", "ageDescContains", "ageDescHasPrefix", "ageDescHasSuffix", "ageDescEqualFold", "ageDescContainsFold", "languageDesc", "languageDescNEQ", "languageDescIn", "languageDescNotIn", "languageDescGT", "languageDescGTE", "languageDescLT", "languageDescLTE", "languageDescContains", "languageDescHasPrefix", "languageDescHasSuffix", "languageDescEqualFold", "languageDescContainsFold", "hasTraits", "hasTraitsWith", "hasStartingProficiencies", "hasStartingProficienciesWith", "hasStartingProficiencyOptions", "hasStartingProficiencyOptionsWith", "hasAbilityBonuses", "hasAbilityBonusesWith", "hasLanguages", "hasLanguagesWith", "hasLanguageOptions", "hasLanguageOptionsWith", "hasCharacters", "hasCharactersWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalORaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalORaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalORaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "speed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speed"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Speed = data
		case "speedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedNEQ = data
		case "speedIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedIn = data
		case "speedNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedNotIn = data
		case "speedGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedGT = data
		case "speedGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedGTE = data
		case "speedLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedLT = data
		case "speedLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedLTE = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalORaceSize2githubcomecshrevedndgenentraceSize(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "sizeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeNEQ"))
			data, err := ec.unmarshalORaceSize2githubcomecshrevedndgenentraceSize(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeNEQ = data
		case "sizeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeIn"))
			data, err := ec.unmarshalORaceSize2githubcomecshrevedndgenentraceSize(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeIn = data
		case "sizeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeNotIn"))
			data, err := ec.unmarshalORaceSize2githubcomecshrevedndgenentraceSize(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeNotIn = data
		case "sizeDesc":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDesc"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDesc = data
		case "sizeDescNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDescNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDescNEQ = data
		case "sizeDescIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDescIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDescIn = data
		case "sizeDescNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDescNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDescNotIn = data
		case "sizeDescGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDescGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDescGT = data
		case "sizeDescGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDescGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDescGTE = data
		case "sizeDescLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDescLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDescLT = data
		case "sizeDescLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDescLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDescLTE = data
		case "sizeDescContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDescContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDescContains = data
		case "sizeDescHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDescHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDescHasPrefix = data
		case "sizeDescHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDescHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDescHasSuffix = data
		case "sizeDescEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDescEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDescEqualFold = data
		case "sizeDescContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeDescContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeDescContainsFold = data
		case "alignmentDesc":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDesc"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDesc = data
		case "alignmentDescNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDescNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDescNEQ = data
		case "alignmentDescIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDescIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDescIn = data
		case "alignmentDescNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDescNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDescNotIn = data
		case "alignmentDescGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDescGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDescGT = data
		case "alignmentDescGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDescGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDescGTE = data
		case "alignmentDescLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDescLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDescLT = data
		case "alignmentDescLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDescLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDescLTE = data
		case "alignmentDescContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDescContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDescContains = data
		case "alignmentDescHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDescHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDescHasPrefix = data
		case "alignmentDescHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDescHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDescHasSuffix = data
		case "alignmentDescEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDescEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDescEqualFold = data
		case "alignmentDescContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentDescContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentDescContainsFold = data
		case "ageDesc":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDesc"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDesc = data
		case "ageDescNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDescNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDescNEQ = data
		case "ageDescIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDescIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDescIn = data
		case "ageDescNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDescNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDescNotIn = data
		case "ageDescGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDescGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDescGT = data
		case "ageDescGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDescGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDescGTE = data
		case "ageDescLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDescLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDescLT = data
		case "ageDescLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDescLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDescLTE = data
		case "ageDescContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDescContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDescContains = data
		case "ageDescHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDescHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDescHasPrefix = data
		case "ageDescHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDescHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDescHasSuffix = data
		case "ageDescEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDescEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDescEqualFold = data
		case "ageDescContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageDescContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeDescContainsFold = data
		case "languageDesc":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDesc"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDesc = data
		case "languageDescNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDescNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDescNEQ = data
		case "languageDescIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDescIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDescIn = data
		case "languageDescNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDescNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDescNotIn = data
		case "languageDescGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDescGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDescGT = data
		case "languageDescGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDescGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDescGTE = data
		case "languageDescLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDescLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDescLT = data
		case "languageDescLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDescLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDescLTE = data
		case "languageDescContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDescContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDescContains = data
		case "languageDescHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDescHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDescHasPrefix = data
		case "languageDescHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDescHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDescHasSuffix = data
		case "languageDescEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDescEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDescEqualFold = data
		case "languageDescContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageDescContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageDescContainsFold = data
		case "hasTraits":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTraits"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTraits = data
		case "hasTraitsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTraitsWith"))
			data, err := ec.unmarshalOTraitWhereInput2githubcomecshrevedndgenentTraitWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTraitsWith = data
		case "hasStartingProficiencies":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStartingProficiencies"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasStartingProficiencies = data
		case "hasStartingProficienciesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStartingProficienciesWith"))
			data, err := ec.unmarshalOProficiencyWhereInput2githubcomecshrevedndgenentProficiencyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasStartingProficienciesWith = data
		case "hasStartingProficiencyOptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStartingProficiencyOptions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasStartingProficiencyOptions = data
		case "hasStartingProficiencyOptionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasStartingProficiencyOptionsWith"))
			data, err := ec.unmarshalOProficiencyChoiceWhereInput2githubcomecshrevedndgenentProficiencyChoiceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasStartingProficiencyOptionsWith = data
		case "hasAbilityBonuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityBonuses"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAbilityBonuses = data
		case "hasAbilityBonusesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityBonusesWith"))
			data, err := ec.unmarshalOAbilityScoreWhereInput2githubcomecshrevedndgenentAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAbilityBonusesWith = data
		case "hasLanguages":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLanguages"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLanguages = data
		case "hasLanguagesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLanguagesWith"))
			data, err := ec.unmarshalOLanguageWhereInput2githubcomecshrevedndgenentLanguageWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLanguagesWith = data
		case "hasLanguageOptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLanguageOptions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLanguageOptions = data
		case "hasLanguageOptionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLanguageOptionsWith"))
			data, err := ec.unmarshalOLanguageChoiceWhereInput2githubcomecshrevedndgenentLanguageChoiceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLanguageOptionsWith = data
		case "hasCharacters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharacters"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharacters = data
		case "hasCharactersWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasCharactersWith"))
			data, err := ec.unmarshalOCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasCharactersWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRuleOrder(ctx context.Context, obj interface{}) (ent.RuleOrder, error) {
	var it ent.RuleOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNRuleOrderField2githubcomecshrevedndgenentRuleOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRuleSectionOrder(ctx context.Context, obj interface{}) (ent.RuleSectionOrder, error) {
	var it ent.RuleSectionOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNRuleSectionOrderField2githubcomecshrevedndgenentRuleSectionOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRuleSectionWhereInput(ctx context.Context, obj interface{}) (ent.RuleSectionWhereInput, error) {
	var it ent.RuleSectionWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasRule", "hasRuleWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalORuleSectionWhereInput2githubcomecshrevedndgenentRuleSectionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalORuleSectionWhereInput2githubcomecshrevedndgenentRuleSectionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalORuleSectionWhereInput2githubcomecshrevedndgenentRuleSectionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "hasRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRule"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRule = data
		case "hasRuleWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRuleWith"))
			data, err := ec.unmarshalORuleWhereInput2githubcomecshrevedndgenentRuleWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRuleWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRuleWhereInput(ctx context.Context, obj interface{}) (ent.RuleWhereInput, error) {
	var it ent.RuleWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasSections", "hasSectionsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalORuleWhereInput2githubcomecshrevedndgenentRuleWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalORuleWhereInput2githubcomecshrevedndgenentRuleWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalORuleWhereInput2githubcomecshrevedndgenentRuleWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "hasSections":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSections"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSections = data
		case "hasSectionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSectionsWith"))
			data, err := ec.unmarshalORuleSectionWhereInput2githubcomecshrevedndgenentRuleSectionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSectionsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSkillOrder(ctx context.Context, obj interface{}) (ent.SkillOrder, error) {
	var it ent.SkillOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNSkillOrderField2githubcomecshrevedndgenentSkillOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSkillWhereInput(ctx context.Context, obj interface{}) (ent.SkillWhereInput, error) {
	var it ent.SkillWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasAbilityScore", "hasAbilityScoreWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOSkillWhereInput2githubcomecshrevedndgenentSkillWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOSkillWhereInput2githubcomecshrevedndgenentSkillWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOSkillWhereInput2githubcomecshrevedndgenentSkillWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "hasAbilityScore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityScore"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAbilityScore = data
		case "hasAbilityScoreWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAbilityScoreWith"))
			data, err := ec.unmarshalOAbilityScoreWhereInput2githubcomecshrevedndgenentAbilityScoreWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAbilityScoreWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputToolWhereInput(ctx context.Context, obj interface{}) (ent.ToolWhereInput, error) {
	var it ent.ToolWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "toolCategory", "toolCategoryNEQ", "toolCategoryIn", "toolCategoryNotIn", "toolCategoryGT", "toolCategoryGTE", "toolCategoryLT", "toolCategoryLTE", "toolCategoryContains", "toolCategoryHasPrefix", "toolCategoryHasSuffix", "toolCategoryEqualFold", "toolCategoryContainsFold", "hasEquipment", "hasEquipmentWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOToolWhereInput2githubcomecshrevedndgenentToolWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOToolWhereInput2githubcomecshrevedndgenentToolWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOToolWhereInput2githubcomecshrevedndgenentToolWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "toolCategory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategory"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategory = data
		case "toolCategoryNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategoryNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategoryNEQ = data
		case "toolCategoryIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategoryIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategoryIn = data
		case "toolCategoryNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategoryNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategoryNotIn = data
		case "toolCategoryGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategoryGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategoryGT = data
		case "toolCategoryGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategoryGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategoryGTE = data
		case "toolCategoryLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategoryLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategoryLT = data
		case "toolCategoryLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategoryLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategoryLTE = data
		case "toolCategoryContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategoryContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategoryContains = data
		case "toolCategoryHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategoryHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategoryHasPrefix = data
		case "toolCategoryHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategoryHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategoryHasSuffix = data
		case "toolCategoryEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategoryEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategoryEqualFold = data
		case "toolCategoryContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toolCategoryContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToolCategoryContainsFold = data
		case "hasEquipment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipment = data
		case "hasEquipmentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			data, err := ec.unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipmentWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTraitOrder(ctx context.Context, obj interface{}) (ent.TraitOrder, error) {
	var it ent.TraitOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNTraitOrderField2githubcomecshrevedndgenentTraitOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTraitWhereInput(ctx context.Context, obj interface{}) (ent.TraitWhereInput, error) {
	var it ent.TraitWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "indx", "indxNEQ", "indxIn", "indxNotIn", "indxGT", "indxGTE", "indxLT", "indxLTE", "indxContains", "indxHasPrefix", "indxHasSuffix", "indxEqualFold", "indxContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasRace", "hasRaceWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOTraitWhereInput2githubcomecshrevedndgenentTraitWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOTraitWhereInput2githubcomecshrevedndgenentTraitWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOTraitWhereInput2githubcomecshrevedndgenentTraitWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "indx":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indx"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Indx = data
		case "indxNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNEQ = data
		case "indxIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxIn = data
		case "indxNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxNotIn = data
		case "indxGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGT = data
		case "indxGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxGTE = data
		case "indxLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLT = data
		case "indxLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxLTE = data
		case "indxContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContains = data
		case "indxHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasPrefix = data
		case "indxHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxHasSuffix = data
		case "indxEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxEqualFold = data
		case "indxContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indxContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndxContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "hasRace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRace"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRace = data
		case "hasRaceWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRaceWith"))
			data, err := ec.unmarshalORaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRaceWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCharacterAbilityScoreInput(ctx context.Context, obj interface{}) (ent.UpdateCharacterAbilityScoreInput, error) {
	var it ent.UpdateCharacterAbilityScoreInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"score", "modifier", "characterID", "abilityScoreID", "addCharacterSkillIDs", "removeCharacterSkillIDs", "clearCharacterSkills"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "score":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Score = data
		case "modifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("modifier"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Modifier = data
		case "characterID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterID = data
		case "abilityScoreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abilityScoreID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AbilityScoreID = data
		case "addCharacterSkillIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addCharacterSkillIDs"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddCharacterSkillIDs = data
		case "removeCharacterSkillIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeCharacterSkillIDs"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveCharacterSkillIDs = data
		case "clearCharacterSkills":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCharacterSkills"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCharacterSkills = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCharacterInput(ctx context.Context, obj interface{}) (ent.UpdateCharacterInput, error) {
	var it ent.UpdateCharacterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "age", "level", "proficiencyBonus", "raceID", "clearRace", "classID", "clearClass", "alignmentID", "clearAlignment", "addCharacterAbilityScoreIDs", "removeCharacterAbilityScoreIDs", "clearCharacterAbilityScores", "addCharacterSkillIDs", "removeCharacterSkillIDs", "clearCharacterSkills", "addCharacterProficiencyIDs", "removeCharacterProficiencyIDs", "clearCharacterProficiencies"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "age":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("age"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Age = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "proficiencyBonus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyBonus"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyBonus = data
		case "raceID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("raceID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RaceID = data
		case "clearRace":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearRace"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearRace = data
		case "classID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("classID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClassID = data
		case "clearClass":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearClass"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearClass = data
		case "alignmentID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignmentID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlignmentID = data
		case "clearAlignment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearAlignment"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearAlignment = data
		case "addCharacterAbilityScoreIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addCharacterAbilityScoreIDs"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddCharacterAbilityScoreIDs = data
		case "removeCharacterAbilityScoreIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeCharacterAbilityScoreIDs"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveCharacterAbilityScoreIDs = data
		case "clearCharacterAbilityScores":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCharacterAbilityScores"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCharacterAbilityScores = data
		case "addCharacterSkillIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addCharacterSkillIDs"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddCharacterSkillIDs = data
		case "removeCharacterSkillIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeCharacterSkillIDs"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveCharacterSkillIDs = data
		case "clearCharacterSkills":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCharacterSkills"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCharacterSkills = data
		case "addCharacterProficiencyIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addCharacterProficiencyIDs"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddCharacterProficiencyIDs = data
		case "removeCharacterProficiencyIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeCharacterProficiencyIDs"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveCharacterProficiencyIDs = data
		case "clearCharacterProficiencies":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCharacterProficiencies"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCharacterProficiencies = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCharacterProficiencyInput(ctx context.Context, obj interface{}) (ent.UpdateCharacterProficiencyInput, error) {
	var it ent.UpdateCharacterProficiencyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"proficiencyType", "proficiencySource", "characterID", "proficiencyID", "characterSkillID", "clearCharacterSkill"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "proficiencyType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyType"))
			data, err := ec.unmarshalOCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyType = data
		case "proficiencySource":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencySource"))
			data, err := ec.unmarshalOCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencySource = data
		case "characterID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterID = data
		case "proficiencyID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficiencyID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProficiencyID = data
		case "characterSkillID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterSkillID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterSkillID = data
		case "clearCharacterSkill":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCharacterSkill"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCharacterSkill = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCharacterSkillInput(ctx context.Context, obj interface{}) (ent.UpdateCharacterSkillInput, error) {
	var it ent.UpdateCharacterSkillInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"proficient", "characterID", "skillID", "characterAbilityScoreID", "characterProficiencyID", "clearCharacterProficiency"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "proficient":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proficient"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Proficient = data
		case "characterID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterID = data
		case "skillID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skillID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SkillID = data
		case "characterAbilityScoreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterAbilityScoreID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterAbilityScoreID = data
		case "characterProficiencyID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("characterProficiencyID"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CharacterProficiencyID = data
		case "clearCharacterProficiency":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCharacterProficiency"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCharacterProficiency = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVehicleWhereInput(ctx context.Context, obj interface{}) (ent.VehicleWhereInput, error) {
	var it ent.VehicleWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "vehicleCategory", "vehicleCategoryNEQ", "vehicleCategoryIn", "vehicleCategoryNotIn", "capacity", "capacityNEQ", "capacityIn", "capacityNotIn", "capacityGT", "capacityGTE", "capacityLT", "capacityLTE", "capacityContains", "capacityHasPrefix", "capacityHasSuffix", "capacityIsNil", "capacityNotNil", "capacityEqualFold", "capacityContainsFold", "speedQuantity", "speedQuantityNEQ", "speedQuantityIn", "speedQuantityNotIn", "speedQuantityGT", "speedQuantityGTE", "speedQuantityLT", "speedQuantityLTE", "speedQuantityIsNil", "speedQuantityNotNil", "speedUnits", "speedUnitsNEQ", "speedUnitsIn", "speedUnitsNotIn", "speedUnitsIsNil", "speedUnitsNotNil", "hasEquipment", "hasEquipmentWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOVehicleWhereInput2githubcomecshrevedndgenentVehicleWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOVehicleWhereInput2githubcomecshrevedndgenentVehicleWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOVehicleWhereInput2githubcomecshrevedndgenentVehicleWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "vehicleCategory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vehicleCategory"))
			data, err := ec.unmarshalOVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.VehicleCategory = data
		case "vehicleCategoryNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vehicleCategoryNEQ"))
			data, err := ec.unmarshalOVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.VehicleCategoryNEQ = data
		case "vehicleCategoryIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vehicleCategoryIn"))
			data, err := ec.unmarshalOVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.VehicleCategoryIn = data
		case "vehicleCategoryNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vehicleCategoryNotIn"))
			data, err := ec.unmarshalOVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.VehicleCategoryNotIn = data
		case "capacity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacity"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Capacity = data
		case "capacityNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityNEQ = data
		case "capacityIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityIn = data
		case "capacityNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityNotIn = data
		case "capacityGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityGT = data
		case "capacityGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityGTE = data
		case "capacityLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityLT = data
		case "capacityLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityLTE = data
		case "capacityContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityContains = data
		case "capacityHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityHasPrefix = data
		case "capacityHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityHasSuffix = data
		case "capacityIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityIsNil = data
		case "capacityNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityNotNil = data
		case "capacityEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityEqualFold = data
		case "capacityContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("capacityContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CapacityContainsFold = data
		case "speedQuantity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedQuantity"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedQuantity = data
		case "speedQuantityNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedQuantityNEQ"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedQuantityNEQ = data
		case "speedQuantityIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedQuantityIn"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedQuantityIn = data
		case "speedQuantityNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedQuantityNotIn"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedQuantityNotIn = data
		case "speedQuantityGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedQuantityGT"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedQuantityGT = data
		case "speedQuantityGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedQuantityGTE"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedQuantityGTE = data
		case "speedQuantityLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedQuantityLT"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedQuantityLT = data
		case "speedQuantityLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedQuantityLTE"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedQuantityLTE = data
		case "speedQuantityIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedQuantityIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedQuantityIsNil = data
		case "speedQuantityNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedQuantityNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedQuantityNotNil = data
		case "speedUnits":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedUnits"))
			data, err := ec.unmarshalOVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedUnits = data
		case "speedUnitsNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedUnitsNEQ"))
			data, err := ec.unmarshalOVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedUnitsNEQ = data
		case "speedUnitsIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedUnitsIn"))
			data, err := ec.unmarshalOVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedUnitsIn = data
		case "speedUnitsNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedUnitsNotIn"))
			data, err := ec.unmarshalOVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedUnitsNotIn = data
		case "speedUnitsIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedUnitsIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedUnitsIsNil = data
		case "speedUnitsNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("speedUnitsNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpeedUnitsNotNil = data
		case "hasEquipment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipment = data
		case "hasEquipmentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			data, err := ec.unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipmentWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWeaponWhereInput(ctx context.Context, obj interface{}) (ent.WeaponWhereInput, error) {
	var it ent.WeaponWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "weaponCategory", "weaponCategoryNEQ", "weaponCategoryIn", "weaponCategoryNotIn", "weaponSubcategory", "weaponSubcategoryNEQ", "weaponSubcategoryIn", "weaponSubcategoryNotIn", "rangeNormal", "rangeNormalNEQ", "rangeNormalIn", "rangeNormalNotIn", "rangeNormalGT", "rangeNormalGTE", "rangeNormalLT", "rangeNormalLTE", "rangeNormalIsNil", "rangeNormalNotNil", "rangeLong", "rangeLongNEQ", "rangeLongIn", "rangeLongNotIn", "rangeLongGT", "rangeLongGTE", "rangeLongLT", "rangeLongLTE", "rangeLongIsNil", "rangeLongNotNil", "throwRangeNormal", "throwRangeNormalNEQ", "throwRangeNormalIn", "throwRangeNormalNotIn", "throwRangeNormalGT", "throwRangeNormalGTE", "throwRangeNormalLT", "throwRangeNormalLTE", "throwRangeNormalIsNil", "throwRangeNormalNotNil", "throwRangeLong", "throwRangeLongNEQ", "throwRangeLongIn", "throwRangeLongNotIn", "throwRangeLongGT", "throwRangeLongGTE", "throwRangeLongLT", "throwRangeLongLTE", "throwRangeLongIsNil", "throwRangeLongNotNil", "damageDice", "damageDiceNEQ", "damageDiceIn", "damageDiceNotIn", "damageDiceGT", "damageDiceGTE", "damageDiceLT", "damageDiceLTE", "damageDiceContains", "damageDiceHasPrefix", "damageDiceHasSuffix", "damageDiceIsNil", "damageDiceNotNil", "damageDiceEqualFold", "damageDiceContainsFold", "hasProperties", "hasPropertiesWith", "hasDamageType", "hasDamageTypeWith", "hasEquipment", "hasEquipmentWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOWeaponWhereInput2githubcomecshrevedndgenentWeaponWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOWeaponWhereInput2githubcomecshrevedndgenentWeaponWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOWeaponWhereInput2githubcomecshrevedndgenentWeaponWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "weaponCategory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weaponCategory"))
			data, err := ec.unmarshalOWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeaponCategory = data
		case "weaponCategoryNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weaponCategoryNEQ"))
			data, err := ec.unmarshalOWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeaponCategoryNEQ = data
		case "weaponCategoryIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weaponCategoryIn"))
			data, err := ec.unmarshalOWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeaponCategoryIn = data
		case "weaponCategoryNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weaponCategoryNotIn"))
			data, err := ec.unmarshalOWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeaponCategoryNotIn = data
		case "weaponSubcategory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weaponSubcategory"))
			data, err := ec.unmarshalOWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeaponSubcategory = data
		case "weaponSubcategoryNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weaponSubcategoryNEQ"))
			data, err := ec.unmarshalOWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeaponSubcategoryNEQ = data
		case "weaponSubcategoryIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weaponSubcategoryIn"))
			data, err := ec.unmarshalOWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeaponSubcategoryIn = data
		case "weaponSubcategoryNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weaponSubcategoryNotIn"))
			data, err := ec.unmarshalOWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.WeaponSubcategoryNotIn = data
		case "rangeNormal":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeNormal"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeNormal = data
		case "rangeNormalNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeNormalNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeNormalNEQ = data
		case "rangeNormalIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeNormalIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeNormalIn = data
		case "rangeNormalNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeNormalNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeNormalNotIn = data
		case "rangeNormalGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeNormalGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeNormalGT = data
		case "rangeNormalGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeNormalGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeNormalGTE = data
		case "rangeNormalLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeNormalLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeNormalLT = data
		case "rangeNormalLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeNormalLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeNormalLTE = data
		case "rangeNormalIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeNormalIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeNormalIsNil = data
		case "rangeNormalNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeNormalNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeNormalNotNil = data
		case "rangeLong":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeLong"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeLong = data
		case "rangeLongNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeLongNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeLongNEQ = data
		case "rangeLongIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeLongIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeLongIn = data
		case "rangeLongNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeLongNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeLongNotIn = data
		case "rangeLongGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeLongGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeLongGT = data
		case "rangeLongGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeLongGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeLongGTE = data
		case "rangeLongLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeLongLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeLongLT = data
		case "rangeLongLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeLongLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeLongLTE = data
		case "rangeLongIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeLongIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeLongIsNil = data
		case "rangeLongNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rangeLongNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RangeLongNotNil = data
		case "throwRangeNormal":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeNormal"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeNormal = data
		case "throwRangeNormalNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeNormalNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeNormalNEQ = data
		case "throwRangeNormalIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeNormalIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeNormalIn = data
		case "throwRangeNormalNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeNormalNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeNormalNotIn = data
		case "throwRangeNormalGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeNormalGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeNormalGT = data
		case "throwRangeNormalGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeNormalGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeNormalGTE = data
		case "throwRangeNormalLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeNormalLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeNormalLT = data
		case "throwRangeNormalLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeNormalLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeNormalLTE = data
		case "throwRangeNormalIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeNormalIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeNormalIsNil = data
		case "throwRangeNormalNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeNormalNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeNormalNotNil = data
		case "throwRangeLong":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeLong"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeLong = data
		case "throwRangeLongNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeLongNEQ"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeLongNEQ = data
		case "throwRangeLongIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeLongIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeLongIn = data
		case "throwRangeLongNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeLongNotIn"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeLongNotIn = data
		case "throwRangeLongGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeLongGT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeLongGT = data
		case "throwRangeLongGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeLongGTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeLongGTE = data
		case "throwRangeLongLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeLongLT"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeLongLT = data
		case "throwRangeLongLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeLongLTE"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeLongLTE = data
		case "throwRangeLongIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeLongIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeLongIsNil = data
		case "throwRangeLongNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("throwRangeLongNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThrowRangeLongNotNil = data
		case "damageDice":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDice"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDice = data
		case "damageDiceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceNEQ = data
		case "damageDiceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceIn = data
		case "damageDiceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceNotIn = data
		case "damageDiceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceGT = data
		case "damageDiceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceGTE = data
		case "damageDiceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceLT = data
		case "damageDiceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceLTE = data
		case "damageDiceContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceContains = data
		case "damageDiceHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceHasPrefix = data
		case "damageDiceHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceHasSuffix = data
		case "damageDiceIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceIsNil = data
		case "damageDiceNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceNotNil = data
		case "damageDiceEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceEqualFold = data
		case "damageDiceContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("damageDiceContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DamageDiceContainsFold = data
		case "hasProperties":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasProperties"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasProperties = data
		case "hasPropertiesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPropertiesWith"))
			data, err := ec.unmarshalOPropertyWhereInput2githubcomecshrevedndgenentPropertyWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasPropertiesWith = data
		case "hasDamageType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDamageType"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasDamageType = data
		case "hasDamageTypeWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDamageTypeWith"))
			data, err := ec.unmarshalODamageTypeWhereInput2githubcomecshrevedndgenentDamageTypeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasDamageTypeWith = data
		case "hasEquipment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipment"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipment = data
		case "hasEquipmentWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasEquipmentWith"))
			data, err := ec.unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasEquipmentWith = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.AbilityScore:
		if obj == nil {
			return graphql.Null
		}
		return ec._AbilityScore(ctx, sel, obj)
	case *ent.Alignment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Alignment(ctx, sel, obj)
	case *ent.Armor:
		if obj == nil {
			return graphql.Null
		}
		return ec._Armor(ctx, sel, obj)
	case *ent.Character:
		if obj == nil {
			return graphql.Null
		}
		return ec._Character(ctx, sel, obj)
	case *ent.CharacterAbilityScore:
		if obj == nil {
			return graphql.Null
		}
		return ec._CharacterAbilityScore(ctx, sel, obj)
	case *ent.CharacterProficiency:
		if obj == nil {
			return graphql.Null
		}
		return ec._CharacterProficiency(ctx, sel, obj)
	case *ent.CharacterSkill:
		if obj == nil {
			return graphql.Null
		}
		return ec._CharacterSkill(ctx, sel, obj)
	case *ent.Class:
		if obj == nil {
			return graphql.Null
		}
		return ec._Class(ctx, sel, obj)
	case *ent.Coin:
		if obj == nil {
			return graphql.Null
		}
		return ec._Coin(ctx, sel, obj)
	case *ent.Condition:
		if obj == nil {
			return graphql.Null
		}
		return ec._Condition(ctx, sel, obj)
	case *ent.Cost:
		if obj == nil {
			return graphql.Null
		}
		return ec._Cost(ctx, sel, obj)
	case *ent.DamageType:
		if obj == nil {
			return graphql.Null
		}
		return ec._DamageType(ctx, sel, obj)
	case *ent.Equipment:
		if obj == nil {
			return graphql.Null
		}
		return ec._Equipment(ctx, sel, obj)
	case *ent.EquipmentEntry:
		if obj == nil {
			return graphql.Null
		}
		return ec._EquipmentEntry(ctx, sel, obj)
	case *ent.Feat:
		if obj == nil {
			return graphql.Null
		}
		return ec._Feat(ctx, sel, obj)
	case *ent.Feature:
		if obj == nil {
			return graphql.Null
		}
		return ec._Feature(ctx, sel, obj)
	case *ent.Gear:
		if obj == nil {
			return graphql.Null
		}
		return ec._Gear(ctx, sel, obj)
	case *ent.Language:
		if obj == nil {
			return graphql.Null
		}
		return ec._Language(ctx, sel, obj)
	case *ent.LanguageChoice:
		if obj == nil {
			return graphql.Null
		}
		return ec._LanguageChoice(ctx, sel, obj)
	case *ent.MagicSchool:
		if obj == nil {
			return graphql.Null
		}
		return ec._MagicSchool(ctx, sel, obj)
	case *ent.Prerequisite:
		if obj == nil {
			return graphql.Null
		}
		return ec._Prerequisite(ctx, sel, obj)
	case *ent.Proficiency:
		if obj == nil {
			return graphql.Null
		}
		return ec._Proficiency(ctx, sel, obj)
	case *ent.ProficiencyChoice:
		if obj == nil {
			return graphql.Null
		}
		return ec._ProficiencyChoice(ctx, sel, obj)
	case *ent.Property:
		if obj == nil {
			return graphql.Null
		}
		return ec._Property(ctx, sel, obj)
	case *ent.Race:
		if obj == nil {
			return graphql.Null
		}
		return ec._Race(ctx, sel, obj)
	case *ent.Rule:
		if obj == nil {
			return graphql.Null
		}
		return ec._Rule(ctx, sel, obj)
	case *ent.RuleSection:
		if obj == nil {
			return graphql.Null
		}
		return ec._RuleSection(ctx, sel, obj)
	case *ent.Skill:
		if obj == nil {
			return graphql.Null
		}
		return ec._Skill(ctx, sel, obj)
	case *ent.Tool:
		if obj == nil {
			return graphql.Null
		}
		return ec._Tool(ctx, sel, obj)
	case *ent.Trait:
		if obj == nil {
			return graphql.Null
		}
		return ec._Trait(ctx, sel, obj)
	case *ent.Vehicle:
		if obj == nil {
			return graphql.Null
		}
		return ec._Vehicle(ctx, sel, obj)
	case *ent.Weapon:
		if obj == nil {
			return graphql.Null
		}
		return ec._Weapon(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var abilityScoreImplementors = []string{"AbilityScore", "Node"}

func (ec *executionContext) _AbilityScore(ctx context.Context, sel ast.SelectionSet, obj *ent.AbilityScore) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, abilityScoreImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AbilityScore")
		case "id":
			out.Values[i] = ec._AbilityScore_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._AbilityScore_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._AbilityScore_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "desc":
			out.Values[i] = ec._AbilityScore_desc(ctx, field, obj)
		case "fullName":
			out.Values[i] = ec._AbilityScore_fullName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "skills":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AbilityScore_skills(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var alignmentImplementors = []string{"Alignment", "Node"}

func (ec *executionContext) _Alignment(ctx context.Context, sel ast.SelectionSet, obj *ent.Alignment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alignmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Alignment")
		case "id":
			out.Values[i] = ec._Alignment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "indx":
			out.Values[i] = ec._Alignment_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Alignment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "desc":
			out.Values[i] = ec._Alignment_desc(ctx, field, obj)
		case "abbr":
			out.Values[i] = ec._Alignment_abbr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var armorImplementors = []string{"Armor", "Node"}

func (ec *executionContext) _Armor(ctx context.Context, sel ast.SelectionSet, obj *ent.Armor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, armorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Armor")
		case "id":
			out.Values[i] = ec._Armor_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "armorCategory":
			out.Values[i] = ec._Armor_armorCategory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "strMinimum":
			out.Values[i] = ec._Armor_strMinimum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stealthDisadvantage":
			out.Values[i] = ec._Armor_stealthDisadvantage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "acBase":
			out.Values[i] = ec._Armor_acBase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "acDexBonus":
			out.Values[i] = ec._Armor_acDexBonus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "acMaxBonus":
			out.Values[i] = ec._Armor_acMaxBonus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Armor_equipment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterImplementors = []string{"Character", "Node"}

func (ec *executionContext) _Character(ctx context.Context, sel ast.SelectionSet, obj *ent.Character) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Character")
		case "id":
			out.Values[i] = ec._Character_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Character_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "age":
			out.Values[i] = ec._Character_age(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "level":
			out.Values[i] = ec._Character_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "proficiencyBonus":
			out.Values[i] = ec._Character_proficiencyBonus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "race":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Character_race(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "class":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Character_class(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "alignment":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Character_alignment(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "characterAbilityScores":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Character_characterAbilityScores(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "characterSkills":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Character_characterSkills(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "characterProficiencies":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Character_characterProficiencies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterAbilityScoreImplementors = []string{"CharacterAbilityScore", "Node"}

func (ec *executionContext) _CharacterAbilityScore(ctx context.Context, sel ast.SelectionSet, obj *ent.CharacterAbilityScore) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterAbilityScoreImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterAbilityScore")
		case "id":
			out.Values[i] = ec._CharacterAbilityScore_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "score":
			out.Values[i] = ec._CharacterAbilityScore_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "modifier":
			out.Values[i] = ec._CharacterAbilityScore_modifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "character":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CharacterAbilityScore_character(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "abilityScore":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CharacterAbilityScore_abilityScore(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "characterSkills":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CharacterAbilityScore_characterSkills(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterConnectionImplementors = []string{"CharacterConnection"}

func (ec *executionContext) _CharacterConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.CharacterConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterConnection")
		case "edges":
			out.Values[i] = ec._CharacterConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._CharacterConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._CharacterConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterEdgeImplementors = []string{"CharacterEdge"}

func (ec *executionContext) _CharacterEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.CharacterEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterEdge")
		case "node":
			out.Values[i] = ec._CharacterEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._CharacterEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterProficiencyImplementors = []string{"CharacterProficiency", "Node"}

func (ec *executionContext) _CharacterProficiency(ctx context.Context, sel ast.SelectionSet, obj *ent.CharacterProficiency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterProficiencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterProficiency")
		case "id":
			out.Values[i] = ec._CharacterProficiency_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "proficiencyType":
			out.Values[i] = ec._CharacterProficiency_proficiencyType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "proficiencySource":
			out.Values[i] = ec._CharacterProficiency_proficiencySource(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "character":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CharacterProficiency_character(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "proficiency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CharacterProficiency_proficiency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "characterSkill":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CharacterProficiency_characterSkill(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterSkillImplementors = []string{"CharacterSkill", "Node"}

func (ec *executionContext) _CharacterSkill(ctx context.Context, sel ast.SelectionSet, obj *ent.CharacterSkill) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterSkillImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterSkill")
		case "id":
			out.Values[i] = ec._CharacterSkill_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "proficient":
			out.Values[i] = ec._CharacterSkill_proficient(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "character":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CharacterSkill_character(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "skill":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CharacterSkill_skill(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "characterAbilityScore":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CharacterSkill_characterAbilityScore(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "characterProficiency":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CharacterSkill_characterProficiency(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var classImplementors = []string{"Class", "Node"}

func (ec *executionContext) _Class(ctx context.Context, sel ast.SelectionSet, obj *ent.Class) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, classImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Class")
		case "id":
			out.Values[i] = ec._Class_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._Class_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Class_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hitDie":
			out.Values[i] = ec._Class_hitDie(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "proficiencies":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Class_proficiencies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "proficiencyOptions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Class_proficiencyOptions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "startingEquipment":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Class_startingEquipment(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "savingThrows":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Class_savingThrows(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "characters":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Class_characters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var coinImplementors = []string{"Coin", "Node"}

func (ec *executionContext) _Coin(ctx context.Context, sel ast.SelectionSet, obj *ent.Coin) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Coin")
		case "id":
			out.Values[i] = ec._Coin_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "indx":
			out.Values[i] = ec._Coin_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Coin_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "desc":
			out.Values[i] = ec._Coin_desc(ctx, field, obj)
		case "goldConversionRate":
			out.Values[i] = ec._Coin_goldConversionRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var conditionImplementors = []string{"Condition", "Node"}

func (ec *executionContext) _Condition(ctx context.Context, sel ast.SelectionSet, obj *ent.Condition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, conditionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Condition")
		case "id":
			out.Values[i] = ec._Condition_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "indx":
			out.Values[i] = ec._Condition_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Condition_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "desc":
			out.Values[i] = ec._Condition_desc(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var costImplementors = []string{"Cost", "Node"}

func (ec *executionContext) _Cost(ctx context.Context, sel ast.SelectionSet, obj *ent.Cost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, costImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Cost")
		case "id":
			out.Values[i] = ec._Cost_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "quantity":
			out.Values[i] = ec._Cost_quantity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "coin":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Cost_coin(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Cost_equipment(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var damageTypeImplementors = []string{"DamageType", "Node"}

func (ec *executionContext) _DamageType(ctx context.Context, sel ast.SelectionSet, obj *ent.DamageType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, damageTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DamageType")
		case "id":
			out.Values[i] = ec._DamageType_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._DamageType_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._DamageType_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "desc":
			out.Values[i] = ec._DamageType_desc(ctx, field, obj)
		case "weapons":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DamageType_weapons(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var equipmentImplementors = []string{"Equipment", "Node"}

func (ec *executionContext) _Equipment(ctx context.Context, sel ast.SelectionSet, obj *ent.Equipment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, equipmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Equipment")
		case "id":
			out.Values[i] = ec._Equipment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._Equipment_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Equipment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "equipmentCategory":
			out.Values[i] = ec._Equipment_equipmentCategory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "weight":
			out.Values[i] = ec._Equipment_weight(ctx, field, obj)
		case "cost":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_cost(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "gear":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_gear(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tool":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_tool(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "weapon":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_weapon(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vehicle":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_vehicle(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "armor":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_armor(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "equipmentEntries":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Equipment_equipmentEntries(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var equipmentConnectionImplementors = []string{"EquipmentConnection"}

func (ec *executionContext) _EquipmentConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.EquipmentConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, equipmentConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EquipmentConnection")
		case "edges":
			out.Values[i] = ec._EquipmentConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._EquipmentConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._EquipmentConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var equipmentEdgeImplementors = []string{"EquipmentEdge"}

func (ec *executionContext) _EquipmentEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.EquipmentEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, equipmentEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EquipmentEdge")
		case "node":
			out.Values[i] = ec._EquipmentEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._EquipmentEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var equipmentEntryImplementors = []string{"EquipmentEntry", "Node"}

func (ec *executionContext) _EquipmentEntry(ctx context.Context, sel ast.SelectionSet, obj *ent.EquipmentEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, equipmentEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EquipmentEntry")
		case "id":
			out.Values[i] = ec._EquipmentEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "quantity":
			out.Values[i] = ec._EquipmentEntry_quantity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "class":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EquipmentEntry_class(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EquipmentEntry_equipment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featImplementors = []string{"Feat", "Node"}

func (ec *executionContext) _Feat(ctx context.Context, sel ast.SelectionSet, obj *ent.Feat) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Feat")
		case "id":
			out.Values[i] = ec._Feat_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "indx":
			out.Values[i] = ec._Feat_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Feat_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "desc":
			out.Values[i] = ec._Feat_desc(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var featureImplementors = []string{"Feature", "Node"}

func (ec *executionContext) _Feature(ctx context.Context, sel ast.SelectionSet, obj *ent.Feature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, featureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Feature")
		case "id":
			out.Values[i] = ec._Feature_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._Feature_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Feature_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "desc":
			out.Values[i] = ec._Feature_desc(ctx, field, obj)
		case "level":
			out.Values[i] = ec._Feature_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "prerequisites":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feature_prerequisites(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gearImplementors = []string{"Gear", "Node"}

func (ec *executionContext) _Gear(ctx context.Context, sel ast.SelectionSet, obj *ent.Gear) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gearImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Gear")
		case "id":
			out.Values[i] = ec._Gear_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "gearCategory":
			out.Values[i] = ec._Gear_gearCategory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "desc":
			out.Values[i] = ec._Gear_desc(ctx, field, obj)
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Gear_equipment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var languageImplementors = []string{"Language", "Node"}

func (ec *executionContext) _Language(ctx context.Context, sel ast.SelectionSet, obj *ent.Language) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, languageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Language")
		case "id":
			out.Values[i] = ec._Language_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._Language_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Language_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "desc":
			out.Values[i] = ec._Language_desc(ctx, field, obj)
		case "languageType":
			out.Values[i] = ec._Language_languageType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "script":
			out.Values[i] = ec._Language_script(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "race":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Language_race(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "options":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Language_options(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var languageChoiceImplementors = []string{"LanguageChoice", "Node"}

func (ec *executionContext) _LanguageChoice(ctx context.Context, sel ast.SelectionSet, obj *ent.LanguageChoice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, languageChoiceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LanguageChoice")
		case "id":
			out.Values[i] = ec._LanguageChoice_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "choose":
			out.Values[i] = ec._LanguageChoice_choose(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "languages":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LanguageChoice_languages(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "race":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LanguageChoice_race(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var magicSchoolImplementors = []string{"MagicSchool", "Node"}

func (ec *executionContext) _MagicSchool(ctx context.Context, sel ast.SelectionSet, obj *ent.MagicSchool) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, magicSchoolImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MagicSchool")
		case "id":
			out.Values[i] = ec._MagicSchool_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "indx":
			out.Values[i] = ec._MagicSchool_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MagicSchool_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "desc":
			out.Values[i] = ec._MagicSchool_desc(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createCharacter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCharacter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateCharacter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCharacter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *entgql.PageInfo[int]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var prerequisiteImplementors = []string{"Prerequisite", "Node"}

func (ec *executionContext) _Prerequisite(ctx context.Context, sel ast.SelectionSet, obj *ent.Prerequisite) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, prerequisiteImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Prerequisite")
		case "id":
			out.Values[i] = ec._Prerequisite_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "prerequisiteType":
			out.Values[i] = ec._Prerequisite_prerequisiteType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "levelValue":
			out.Values[i] = ec._Prerequisite_levelValue(ctx, field, obj)
		case "featureValue":
			out.Values[i] = ec._Prerequisite_featureValue(ctx, field, obj)
		case "spellValue":
			out.Values[i] = ec._Prerequisite_spellValue(ctx, field, obj)
		case "feature":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Prerequisite_feature(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var proficiencyImplementors = []string{"Proficiency", "Node"}

func (ec *executionContext) _Proficiency(ctx context.Context, sel ast.SelectionSet, obj *ent.Proficiency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, proficiencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Proficiency")
		case "id":
			out.Values[i] = ec._Proficiency_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._Proficiency_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Proficiency_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "reference":
			out.Values[i] = ec._Proficiency_reference(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "race":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Proficiency_race(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "class":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Proficiency_class(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var proficiencyChoiceImplementors = []string{"ProficiencyChoice", "Node"}

func (ec *executionContext) _ProficiencyChoice(ctx context.Context, sel ast.SelectionSet, obj *ent.ProficiencyChoice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, proficiencyChoiceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProficiencyChoice")
		case "id":
			out.Values[i] = ec._ProficiencyChoice_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "choose":
			out.Values[i] = ec._ProficiencyChoice_choose(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "desc":
			out.Values[i] = ec._ProficiencyChoice_desc(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "proficiencies":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProficiencyChoice_proficiencies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "race":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProficiencyChoice_race(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "class":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProficiencyChoice_class(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var propertyImplementors = []string{"Property", "Node"}

func (ec *executionContext) _Property(ctx context.Context, sel ast.SelectionSet, obj *ent.Property) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, propertyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Property")
		case "id":
			out.Values[i] = ec._Property_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._Property_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Property_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "desc":
			out.Values[i] = ec._Property_desc(ctx, field, obj)
		case "weapons":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Property_weapons(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "abilityScores":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_abilityScores(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "alignments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_alignments(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "characters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_characters(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "classes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_classes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "coins":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coins(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "conditions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_conditions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "damageTypes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_damageTypes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "equipments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_equipments(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "feats":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_feats(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "features":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_features(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "languages":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_languages(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "magicSchools":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_magicSchools(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "properties":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_properties(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "races":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_races(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "rules":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_rules(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ruleSections":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ruleSections(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "skills":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_skills(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var raceImplementors = []string{"Race", "Node"}

func (ec *executionContext) _Race(ctx context.Context, sel ast.SelectionSet, obj *ent.Race) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, raceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Race")
		case "id":
			out.Values[i] = ec._Race_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._Race_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Race_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "speed":
			out.Values[i] = ec._Race_speed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "size":
			out.Values[i] = ec._Race_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sizeDesc":
			out.Values[i] = ec._Race_sizeDesc(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "alignmentDesc":
			out.Values[i] = ec._Race_alignmentDesc(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ageDesc":
			out.Values[i] = ec._Race_ageDesc(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "languageDesc":
			out.Values[i] = ec._Race_languageDesc(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "traits":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Race_traits(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "startingProficiencies":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Race_startingProficiencies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "startingProficiencyOptions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Race_startingProficiencyOptions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "abilityBonuses":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Race_abilityBonuses(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "languages":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Race_languages(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "languageOptions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Race_languageOptions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "characters":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Race_characters(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ruleImplementors = []string{"Rule", "Node"}

func (ec *executionContext) _Rule(ctx context.Context, sel ast.SelectionSet, obj *ent.Rule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ruleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Rule")
		case "id":
			out.Values[i] = ec._Rule_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._Rule_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Rule_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "desc":
			out.Values[i] = ec._Rule_desc(ctx, field, obj)
		case "sections":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Rule_sections(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ruleSectionImplementors = []string{"RuleSection", "Node"}

func (ec *executionContext) _RuleSection(ctx context.Context, sel ast.SelectionSet, obj *ent.RuleSection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ruleSectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuleSection")
		case "id":
			out.Values[i] = ec._RuleSection_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._RuleSection_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._RuleSection_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "desc":
			out.Values[i] = ec._RuleSection_desc(ctx, field, obj)
		case "rule":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RuleSection_rule(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var skillImplementors = []string{"Skill", "Node"}

func (ec *executionContext) _Skill(ctx context.Context, sel ast.SelectionSet, obj *ent.Skill) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, skillImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Skill")
		case "id":
			out.Values[i] = ec._Skill_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._Skill_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Skill_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "desc":
			out.Values[i] = ec._Skill_desc(ctx, field, obj)
		case "abilityScore":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Skill_abilityScore(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var toolImplementors = []string{"Tool", "Node"}

func (ec *executionContext) _Tool(ctx context.Context, sel ast.SelectionSet, obj *ent.Tool) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, toolImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tool")
		case "id":
			out.Values[i] = ec._Tool_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "toolCategory":
			out.Values[i] = ec._Tool_toolCategory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "desc":
			out.Values[i] = ec._Tool_desc(ctx, field, obj)
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tool_equipment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var traitImplementors = []string{"Trait", "Node"}

func (ec *executionContext) _Trait(ctx context.Context, sel ast.SelectionSet, obj *ent.Trait) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, traitImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Trait")
		case "id":
			out.Values[i] = ec._Trait_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "indx":
			out.Values[i] = ec._Trait_indx(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Trait_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "desc":
			out.Values[i] = ec._Trait_desc(ctx, field, obj)
		case "race":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trait_race(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vehicleImplementors = []string{"Vehicle", "Node"}

func (ec *executionContext) _Vehicle(ctx context.Context, sel ast.SelectionSet, obj *ent.Vehicle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vehicleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Vehicle")
		case "id":
			out.Values[i] = ec._Vehicle_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "vehicleCategory":
			out.Values[i] = ec._Vehicle_vehicleCategory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "capacity":
			out.Values[i] = ec._Vehicle_capacity(ctx, field, obj)
		case "desc":
			out.Values[i] = ec._Vehicle_desc(ctx, field, obj)
		case "speedQuantity":
			out.Values[i] = ec._Vehicle_speedQuantity(ctx, field, obj)
		case "speedUnits":
			out.Values[i] = ec._Vehicle_speedUnits(ctx, field, obj)
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Vehicle_equipment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var weaponImplementors = []string{"Weapon", "Node"}

func (ec *executionContext) _Weapon(ctx context.Context, sel ast.SelectionSet, obj *ent.Weapon) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, weaponImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Weapon")
		case "id":
			out.Values[i] = ec._Weapon_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "weaponCategory":
			out.Values[i] = ec._Weapon_weaponCategory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "weaponSubcategory":
			out.Values[i] = ec._Weapon_weaponSubcategory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "rangeNormal":
			out.Values[i] = ec._Weapon_rangeNormal(ctx, field, obj)
		case "rangeLong":
			out.Values[i] = ec._Weapon_rangeLong(ctx, field, obj)
		case "throwRangeNormal":
			out.Values[i] = ec._Weapon_throwRangeNormal(ctx, field, obj)
		case "throwRangeLong":
			out.Values[i] = ec._Weapon_throwRangeLong(ctx, field, obj)
		case "damageDice":
			out.Values[i] = ec._Weapon_damageDice(ctx, field, obj)
		case "properties":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Weapon_properties(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "damageType":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Weapon_damageType(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "equipment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Weapon_equipment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAbilityScore2githubcomecshrevedndgenentAbilityScore(ctx context.Context, sel ast.SelectionSet, v []*ent.AbilityScore) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAbilityScore2githubcomecshrevedndgenentAbilityScore(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAbilityScore2githubcomecshrevedndgenentAbilityScore(ctx context.Context, sel ast.SelectionSet, v *ent.AbilityScore) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AbilityScore(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAbilityScoreOrderField2githubcomecshrevedndgenentAbilityScoreOrderField(ctx context.Context, v interface{}) (*ent.AbilityScoreOrderField, error) {
	var res = new(ent.AbilityScoreOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAbilityScoreOrderField2githubcomecshrevedndgenentAbilityScoreOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.AbilityScoreOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNAbilityScoreWhereInput2githubcomecshrevedndgenentAbilityScoreWhereInput(ctx context.Context, v interface{}) (*ent.AbilityScoreWhereInput, error) {
	res, err := ec.unmarshalInputAbilityScoreWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAlignment2githubcomecshrevedndgenentAlignment(ctx context.Context, sel ast.SelectionSet, v []*ent.Alignment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAlignment2githubcomecshrevedndgenentAlignment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAlignment2githubcomecshrevedndgenentAlignment(ctx context.Context, sel ast.SelectionSet, v *ent.Alignment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Alignment(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx context.Context, v interface{}) (alignment.Abbr, error) {
	var res alignment.Abbr
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx context.Context, sel ast.SelectionSet, v alignment.Abbr) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNAlignmentOrderField2githubcomecshrevedndgenentAlignmentOrderField(ctx context.Context, v interface{}) (*ent.AlignmentOrderField, error) {
	var res = new(ent.AlignmentOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAlignmentOrderField2githubcomecshrevedndgenentAlignmentOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.AlignmentOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNAlignmentWhereInput2githubcomecshrevedndgenentAlignmentWhereInput(ctx context.Context, v interface{}) (*ent.AlignmentWhereInput, error) {
	res, err := ec.unmarshalInputAlignmentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx context.Context, v interface{}) (armor.ArmorCategory, error) {
	var res armor.ArmorCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx context.Context, sel ast.SelectionSet, v armor.ArmorCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNArmorWhereInput2githubcomecshrevedndgenentArmorWhereInput(ctx context.Context, v interface{}) (*ent.ArmorWhereInput, error) {
	res, err := ec.unmarshalInputArmorWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCharacter2githubcomecshrevedndgenentCharacter(ctx context.Context, sel ast.SelectionSet, v ent.Character) graphql.Marshaler {
	return ec._Character(ctx, sel, &v)
}

func (ec *executionContext) marshalNCharacter2githubcomecshrevedndgenentCharacter(ctx context.Context, sel ast.SelectionSet, v *ent.Character) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Character(ctx, sel, v)
}

func (ec *executionContext) marshalNCharacterAbilityScore2githubcomecshrevedndgenentCharacterAbilityScore(ctx context.Context, sel ast.SelectionSet, v *ent.CharacterAbilityScore) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterAbilityScore(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterAbilityScoreWhereInput2githubcomecshrevedndgenentCharacterAbilityScoreWhereInput(ctx context.Context, v interface{}) (*ent.CharacterAbilityScoreWhereInput, error) {
	res, err := ec.unmarshalInputCharacterAbilityScoreWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterConnection2githubcomecshrevedndgenentCharacterConnection(ctx context.Context, sel ast.SelectionSet, v ent.CharacterConnection) graphql.Marshaler {
	return ec._CharacterConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNCharacterConnection2githubcomecshrevedndgenentCharacterConnection(ctx context.Context, sel ast.SelectionSet, v *ent.CharacterConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterOrderField2githubcomecshrevedndgenentCharacterOrderField(ctx context.Context, v interface{}) (*ent.CharacterOrderField, error) {
	var res = new(ent.CharacterOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterOrderField2githubcomecshrevedndgenentCharacterOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.CharacterOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNCharacterProficiency2githubcomecshrevedndgenentCharacterProficiency(ctx context.Context, sel ast.SelectionSet, v *ent.CharacterProficiency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterProficiency(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx context.Context, v interface{}) (characterproficiency.ProficiencySource, error) {
	var res characterproficiency.ProficiencySource
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx context.Context, sel ast.SelectionSet, v characterproficiency.ProficiencySource) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx context.Context, v interface{}) (characterproficiency.ProficiencyType, error) {
	var res characterproficiency.ProficiencyType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx context.Context, sel ast.SelectionSet, v characterproficiency.ProficiencyType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNCharacterProficiencyWhereInput2githubcomecshrevedndgenentCharacterProficiencyWhereInput(ctx context.Context, v interface{}) (*ent.CharacterProficiencyWhereInput, error) {
	res, err := ec.unmarshalInputCharacterProficiencyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterSkill2githubcomecshrevedndgenentCharacterSkill(ctx context.Context, sel ast.SelectionSet, v *ent.CharacterSkill) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterSkill(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterSkillWhereInput2githubcomecshrevedndgenentCharacterSkillWhereInput(ctx context.Context, v interface{}) (*ent.CharacterSkillWhereInput, error) {
	res, err := ec.unmarshalInputCharacterSkillWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx context.Context, v interface{}) (*ent.CharacterWhereInput, error) {
	res, err := ec.unmarshalInputCharacterWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNClass2githubcomecshrevedndgenentClass(ctx context.Context, sel ast.SelectionSet, v []*ent.Class) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNClass2githubcomecshrevedndgenentClass(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNClass2githubcomecshrevedndgenentClass(ctx context.Context, sel ast.SelectionSet, v *ent.Class) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Class(ctx, sel, v)
}

func (ec *executionContext) unmarshalNClassOrderField2githubcomecshrevedndgenentClassOrderField(ctx context.Context, v interface{}) (*ent.ClassOrderField, error) {
	var res = new(ent.ClassOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNClassOrderField2githubcomecshrevedndgenentClassOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.ClassOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNClassWhereInput2githubcomecshrevedndgenentClassWhereInput(ctx context.Context, v interface{}) (*ent.ClassWhereInput, error) {
	res, err := ec.unmarshalInputClassWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCoin2githubcomecshrevedndgenentCoin(ctx context.Context, sel ast.SelectionSet, v []*ent.Coin) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCoin2githubcomecshrevedndgenentCoin(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCoin2githubcomecshrevedndgenentCoin(ctx context.Context, sel ast.SelectionSet, v *ent.Coin) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Coin(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCoinOrderField2githubcomecshrevedndgenentCoinOrderField(ctx context.Context, v interface{}) (*ent.CoinOrderField, error) {
	var res = new(ent.CoinOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCoinOrderField2githubcomecshrevedndgenentCoinOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.CoinOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNCoinWhereInput2githubcomecshrevedndgenentCoinWhereInput(ctx context.Context, v interface{}) (*ent.CoinWhereInput, error) {
	res, err := ec.unmarshalInputCoinWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCondition2githubcomecshrevedndgenentCondition(ctx context.Context, sel ast.SelectionSet, v []*ent.Condition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCondition2githubcomecshrevedndgenentCondition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCondition2githubcomecshrevedndgenentCondition(ctx context.Context, sel ast.SelectionSet, v *ent.Condition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Condition(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConditionOrderField2githubcomecshrevedndgenentConditionOrderField(ctx context.Context, v interface{}) (*ent.ConditionOrderField, error) {
	var res = new(ent.ConditionOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConditionOrderField2githubcomecshrevedndgenentConditionOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.ConditionOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNConditionWhereInput2githubcomecshrevedndgenentConditionWhereInput(ctx context.Context, v interface{}) (*ent.ConditionWhereInput, error) {
	res, err := ec.unmarshalInputConditionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCostWhereInput2githubcomecshrevedndgenentCostWhereInput(ctx context.Context, v interface{}) (*ent.CostWhereInput, error) {
	res, err := ec.unmarshalInputCostWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateCharacterInput2githubcomecshrevedndgenentCreateCharacterInput(ctx context.Context, v interface{}) (ent.CreateCharacterInput, error) {
	res, err := ec.unmarshalInputCreateCharacterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2entgoiocontribentgqlCursor(ctx context.Context, v interface{}) (entgql.Cursor[int], error) {
	var res entgql.Cursor[int]
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2entgoiocontribentgqlCursor(ctx context.Context, sel ast.SelectionSet, v entgql.Cursor[int]) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDamageType2githubcomecshrevedndgenentDamageType(ctx context.Context, sel ast.SelectionSet, v []*ent.DamageType) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDamageType2githubcomecshrevedndgenentDamageType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDamageType2githubcomecshrevedndgenentDamageType(ctx context.Context, sel ast.SelectionSet, v *ent.DamageType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DamageType(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDamageTypeOrderField2githubcomecshrevedndgenentDamageTypeOrderField(ctx context.Context, v interface{}) (*ent.DamageTypeOrderField, error) {
	var res = new(ent.DamageTypeOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDamageTypeOrderField2githubcomecshrevedndgenentDamageTypeOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.DamageTypeOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNDamageTypeWhereInput2githubcomecshrevedndgenentDamageTypeWhereInput(ctx context.Context, v interface{}) (*ent.DamageTypeWhereInput, error) {
	res, err := ec.unmarshalInputDamageTypeWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEquipment2githubcomecshrevedndgenentEquipment(ctx context.Context, sel ast.SelectionSet, v *ent.Equipment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Equipment(ctx, sel, v)
}

func (ec *executionContext) marshalNEquipmentConnection2githubcomecshrevedndgenentEquipmentConnection(ctx context.Context, sel ast.SelectionSet, v ent.EquipmentConnection) graphql.Marshaler {
	return ec._EquipmentConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNEquipmentConnection2githubcomecshrevedndgenentEquipmentConnection(ctx context.Context, sel ast.SelectionSet, v *ent.EquipmentConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EquipmentConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNEquipmentEntry2githubcomecshrevedndgenentEquipmentEntry(ctx context.Context, sel ast.SelectionSet, v *ent.EquipmentEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EquipmentEntry(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEquipmentEntryWhereInput2githubcomecshrevedndgenentEquipmentEntryWhereInput(ctx context.Context, v interface{}) (*ent.EquipmentEntryWhereInput, error) {
	res, err := ec.unmarshalInputEquipmentEntryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx context.Context, v interface{}) (equipment.EquipmentCategory, error) {
	var res equipment.EquipmentCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx context.Context, sel ast.SelectionSet, v equipment.EquipmentCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEquipmentOrderField2githubcomecshrevedndgenentEquipmentOrderField(ctx context.Context, v interface{}) (*ent.EquipmentOrderField, error) {
	var res = new(ent.EquipmentOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEquipmentOrderField2githubcomecshrevedndgenentEquipmentOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.EquipmentOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx context.Context, v interface{}) (*ent.EquipmentWhereInput, error) {
	res, err := ec.unmarshalInputEquipmentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeat2githubcomecshrevedndgenentFeat(ctx context.Context, sel ast.SelectionSet, v []*ent.Feat) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeat2githubcomecshrevedndgenentFeat(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeat2githubcomecshrevedndgenentFeat(ctx context.Context, sel ast.SelectionSet, v *ent.Feat) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Feat(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFeatOrderField2githubcomecshrevedndgenentFeatOrderField(ctx context.Context, v interface{}) (*ent.FeatOrderField, error) {
	var res = new(ent.FeatOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeatOrderField2githubcomecshrevedndgenentFeatOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.FeatOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNFeatWhereInput2githubcomecshrevedndgenentFeatWhereInput(ctx context.Context, v interface{}) (*ent.FeatWhereInput, error) {
	res, err := ec.unmarshalInputFeatWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeature2githubcomecshrevedndgenentFeature(ctx context.Context, sel ast.SelectionSet, v []*ent.Feature) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeature2githubcomecshrevedndgenentFeature(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeature2githubcomecshrevedndgenentFeature(ctx context.Context, sel ast.SelectionSet, v *ent.Feature) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Feature(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFeatureOrderField2githubcomecshrevedndgenentFeatureOrderField(ctx context.Context, v interface{}) (*ent.FeatureOrderField, error) {
	var res = new(ent.FeatureOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeatureOrderField2githubcomecshrevedndgenentFeatureOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.FeatureOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNFeatureWhereInput2githubcomecshrevedndgenentFeatureWhereInput(ctx context.Context, v interface{}) (*ent.FeatureWhereInput, error) {
	res, err := ec.unmarshalInputFeatureWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNGearWhereInput2githubcomecshrevedndgenentGearWhereInput(ctx context.Context, v interface{}) (*ent.GearWhereInput, error) {
	res, err := ec.unmarshalInputGearWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalIntID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalIntID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLanguage2githubcomecshrevedndgenentLanguage(ctx context.Context, sel ast.SelectionSet, v []*ent.Language) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLanguage2githubcomecshrevedndgenentLanguage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLanguage2githubcomecshrevedndgenentLanguage(ctx context.Context, sel ast.SelectionSet, v *ent.Language) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Language(ctx, sel, v)
}

func (ec *executionContext) marshalNLanguageChoice2githubcomecshrevedndgenentLanguageChoice(ctx context.Context, sel ast.SelectionSet, v *ent.LanguageChoice) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LanguageChoice(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLanguageChoiceWhereInput2githubcomecshrevedndgenentLanguageChoiceWhereInput(ctx context.Context, v interface{}) (*ent.LanguageChoiceWhereInput, error) {
	res, err := ec.unmarshalInputLanguageChoiceWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx context.Context, v interface{}) (language.LanguageType, error) {
	var res language.LanguageType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx context.Context, sel ast.SelectionSet, v language.LanguageType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNLanguageOrderField2githubcomecshrevedndgenentLanguageOrderField(ctx context.Context, v interface{}) (*ent.LanguageOrderField, error) {
	var res = new(ent.LanguageOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLanguageOrderField2githubcomecshrevedndgenentLanguageOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.LanguageOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx context.Context, v interface{}) (language.Script, error) {
	var res language.Script
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx context.Context, sel ast.SelectionSet, v language.Script) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNLanguageWhereInput2githubcomecshrevedndgenentLanguageWhereInput(ctx context.Context, v interface{}) (*ent.LanguageWhereInput, error) {
	res, err := ec.unmarshalInputLanguageWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMagicSchool2githubcomecshrevedndgenentMagicSchool(ctx context.Context, sel ast.SelectionSet, v []*ent.MagicSchool) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMagicSchool2githubcomecshrevedndgenentMagicSchool(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMagicSchool2githubcomecshrevedndgenentMagicSchool(ctx context.Context, sel ast.SelectionSet, v *ent.MagicSchool) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MagicSchool(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMagicSchoolOrderField2githubcomecshrevedndgenentMagicSchoolOrderField(ctx context.Context, v interface{}) (*ent.MagicSchoolOrderField, error) {
	var res = new(ent.MagicSchoolOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMagicSchoolOrderField2githubcomecshrevedndgenentMagicSchoolOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.MagicSchoolOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNMagicSchoolWhereInput2githubcomecshrevedndgenentMagicSchoolWhereInput(ctx context.Context, v interface{}) (*ent.MagicSchoolWhereInput, error) {
	res, err := ec.unmarshalInputMagicSchoolWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNode2githubcomecshrevedndgenentNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2githubcomecshrevedndgenentNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx context.Context, v interface{}) (entgql.OrderDirection, error) {
	var res entgql.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx context.Context, sel ast.SelectionSet, v entgql.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx context.Context, sel ast.SelectionSet, v entgql.PageInfo[int]) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNPrerequisite2githubcomecshrevedndgenentPrerequisite(ctx context.Context, sel ast.SelectionSet, v *ent.Prerequisite) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Prerequisite(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx context.Context, v interface{}) (prerequisite.PrerequisiteType, error) {
	var res prerequisite.PrerequisiteType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx context.Context, sel ast.SelectionSet, v prerequisite.PrerequisiteType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPrerequisiteWhereInput2githubcomecshrevedndgenentPrerequisiteWhereInput(ctx context.Context, v interface{}) (*ent.PrerequisiteWhereInput, error) {
	res, err := ec.unmarshalInputPrerequisiteWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProficiency2githubcomecshrevedndgenentProficiency(ctx context.Context, sel ast.SelectionSet, v *ent.Proficiency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Proficiency(ctx, sel, v)
}

func (ec *executionContext) marshalNProficiencyChoice2githubcomecshrevedndgenentProficiencyChoice(ctx context.Context, sel ast.SelectionSet, v *ent.ProficiencyChoice) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProficiencyChoice(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProficiencyChoiceWhereInput2githubcomecshrevedndgenentProficiencyChoiceWhereInput(ctx context.Context, v interface{}) (*ent.ProficiencyChoiceWhereInput, error) {
	res, err := ec.unmarshalInputProficiencyChoiceWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNProficiencyOrderField2githubcomecshrevedndgenentProficiencyOrderField(ctx context.Context, v interface{}) (*ent.ProficiencyOrderField, error) {
	var res = new(ent.ProficiencyOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProficiencyOrderField2githubcomecshrevedndgenentProficiencyOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.ProficiencyOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNProficiencyWhereInput2githubcomecshrevedndgenentProficiencyWhereInput(ctx context.Context, v interface{}) (*ent.ProficiencyWhereInput, error) {
	res, err := ec.unmarshalInputProficiencyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProperty2githubcomecshrevedndgenentProperty(ctx context.Context, sel ast.SelectionSet, v []*ent.Property) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProperty2githubcomecshrevedndgenentProperty(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProperty2githubcomecshrevedndgenentProperty(ctx context.Context, sel ast.SelectionSet, v *ent.Property) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Property(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPropertyOrderField2githubcomecshrevedndgenentPropertyOrderField(ctx context.Context, v interface{}) (*ent.PropertyOrderField, error) {
	var res = new(ent.PropertyOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPropertyOrderField2githubcomecshrevedndgenentPropertyOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.PropertyOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNPropertyWhereInput2githubcomecshrevedndgenentPropertyWhereInput(ctx context.Context, v interface{}) (*ent.PropertyWhereInput, error) {
	res, err := ec.unmarshalInputPropertyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRace2githubcomecshrevedndgenentRace(ctx context.Context, sel ast.SelectionSet, v []*ent.Race) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRace2githubcomecshrevedndgenentRace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRace2githubcomecshrevedndgenentRace(ctx context.Context, sel ast.SelectionSet, v *ent.Race) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Race(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRaceOrderField2githubcomecshrevedndgenentRaceOrderField(ctx context.Context, v interface{}) (*ent.RaceOrderField, error) {
	var res = new(ent.RaceOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRaceOrderField2githubcomecshrevedndgenentRaceOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.RaceOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNRaceSize2githubcomecshrevedndgenentraceSize(ctx context.Context, v interface{}) (race.Size, error) {
	var res race.Size
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRaceSize2githubcomecshrevedndgenentraceSize(ctx context.Context, sel ast.SelectionSet, v race.Size) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx context.Context, v interface{}) (*ent.RaceWhereInput, error) {
	res, err := ec.unmarshalInputRaceWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRule2githubcomecshrevedndgenentRule(ctx context.Context, sel ast.SelectionSet, v []*ent.Rule) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRule2githubcomecshrevedndgenentRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRule2githubcomecshrevedndgenentRule(ctx context.Context, sel ast.SelectionSet, v *ent.Rule) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Rule(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRuleOrderField2githubcomecshrevedndgenentRuleOrderField(ctx context.Context, v interface{}) (*ent.RuleOrderField, error) {
	var res = new(ent.RuleOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRuleOrderField2githubcomecshrevedndgenentRuleOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.RuleOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNRuleSection2githubcomecshrevedndgenentRuleSection(ctx context.Context, sel ast.SelectionSet, v []*ent.RuleSection) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRuleSection2githubcomecshrevedndgenentRuleSection(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRuleSection2githubcomecshrevedndgenentRuleSection(ctx context.Context, sel ast.SelectionSet, v *ent.RuleSection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RuleSection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRuleSectionOrderField2githubcomecshrevedndgenentRuleSectionOrderField(ctx context.Context, v interface{}) (*ent.RuleSectionOrderField, error) {
	var res = new(ent.RuleSectionOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRuleSectionOrderField2githubcomecshrevedndgenentRuleSectionOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.RuleSectionOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNRuleSectionWhereInput2githubcomecshrevedndgenentRuleSectionWhereInput(ctx context.Context, v interface{}) (*ent.RuleSectionWhereInput, error) {
	res, err := ec.unmarshalInputRuleSectionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRuleWhereInput2githubcomecshrevedndgenentRuleWhereInput(ctx context.Context, v interface{}) (*ent.RuleWhereInput, error) {
	res, err := ec.unmarshalInputRuleWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSkill2githubcomecshrevedndgenentSkill(ctx context.Context, sel ast.SelectionSet, v []*ent.Skill) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSkill2githubcomecshrevedndgenentSkill(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSkill2githubcomecshrevedndgenentSkill(ctx context.Context, sel ast.SelectionSet, v *ent.Skill) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Skill(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSkillOrderField2githubcomecshrevedndgenentSkillOrderField(ctx context.Context, v interface{}) (*ent.SkillOrderField, error) {
	var res = new(ent.SkillOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSkillOrderField2githubcomecshrevedndgenentSkillOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.SkillOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNSkillWhereInput2githubcomecshrevedndgenentSkillWhereInput(ctx context.Context, v interface{}) (*ent.SkillWhereInput, error) {
	res, err := ec.unmarshalInputSkillWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNToolWhereInput2githubcomecshrevedndgenentToolWhereInput(ctx context.Context, v interface{}) (*ent.ToolWhereInput, error) {
	res, err := ec.unmarshalInputToolWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTrait2githubcomecshrevedndgenentTrait(ctx context.Context, sel ast.SelectionSet, v *ent.Trait) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Trait(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTraitOrderField2githubcomecshrevedndgenentTraitOrderField(ctx context.Context, v interface{}) (*ent.TraitOrderField, error) {
	var res = new(ent.TraitOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTraitOrderField2githubcomecshrevedndgenentTraitOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.TraitOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNTraitWhereInput2githubcomecshrevedndgenentTraitWhereInput(ctx context.Context, v interface{}) (*ent.TraitWhereInput, error) {
	res, err := ec.unmarshalInputTraitWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateCharacterInput2githubcomecshrevedndgenentUpdateCharacterInput(ctx context.Context, v interface{}) (ent.UpdateCharacterInput, error) {
	res, err := ec.unmarshalInputUpdateCharacterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx context.Context, v interface{}) (vehicle.SpeedUnits, error) {
	var res vehicle.SpeedUnits
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx context.Context, sel ast.SelectionSet, v vehicle.SpeedUnits) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx context.Context, v interface{}) (vehicle.VehicleCategory, error) {
	var res vehicle.VehicleCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx context.Context, sel ast.SelectionSet, v vehicle.VehicleCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNVehicleWhereInput2githubcomecshrevedndgenentVehicleWhereInput(ctx context.Context, v interface{}) (*ent.VehicleWhereInput, error) {
	res, err := ec.unmarshalInputVehicleWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWeapon2githubcomecshrevedndgenentWeapon(ctx context.Context, sel ast.SelectionSet, v *ent.Weapon) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Weapon(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx context.Context, v interface{}) (weapon.WeaponCategory, error) {
	var res weapon.WeaponCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx context.Context, sel ast.SelectionSet, v weapon.WeaponCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx context.Context, v interface{}) (weapon.WeaponSubcategory, error) {
	var res weapon.WeaponSubcategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx context.Context, sel ast.SelectionSet, v weapon.WeaponSubcategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNWeaponWhereInput2githubcomecshrevedndgenentWeaponWhereInput(ctx context.Context, v interface{}) (*ent.WeaponWhereInput, error) {
	res, err := ec.unmarshalInputWeaponWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAbilityScore2githubcomecshrevedndgenentAbilityScore(ctx context.Context, sel ast.SelectionSet, v []*ent.AbilityScore) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAbilityScore2githubcomecshrevedndgenentAbilityScore(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOAbilityScore2githubcomecshrevedndgenentAbilityScore(ctx context.Context, sel ast.SelectionSet, v *ent.AbilityScore) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AbilityScore(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAbilityScoreWhereInput2githubcomecshrevedndgenentAbilityScoreWhereInput(ctx context.Context, v interface{}) ([]*ent.AbilityScoreWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.AbilityScoreWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAbilityScoreWhereInput2githubcomecshrevedndgenentAbilityScoreWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAbilityScoreWhereInput2githubcomecshrevedndgenentAbilityScoreWhereInput(ctx context.Context, v interface{}) (*ent.AbilityScoreWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAbilityScoreWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAlignment2githubcomecshrevedndgenentAlignment(ctx context.Context, sel ast.SelectionSet, v *ent.Alignment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Alignment(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx context.Context, v interface{}) ([]alignment.Abbr, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]alignment.Abbr, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx context.Context, sel ast.SelectionSet, v []alignment.Abbr) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx context.Context, v interface{}) (*alignment.Abbr, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(alignment.Abbr)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAlignmentAbbr2githubcomecshrevedndgenentalignmentAbbr(ctx context.Context, sel ast.SelectionSet, v *alignment.Abbr) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOAlignmentWhereInput2githubcomecshrevedndgenentAlignmentWhereInput(ctx context.Context, v interface{}) ([]*ent.AlignmentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.AlignmentWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAlignmentWhereInput2githubcomecshrevedndgenentAlignmentWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAlignmentWhereInput2githubcomecshrevedndgenentAlignmentWhereInput(ctx context.Context, v interface{}) (*ent.AlignmentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAlignmentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOArmor2githubcomecshrevedndgenentArmor(ctx context.Context, sel ast.SelectionSet, v *ent.Armor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Armor(ctx, sel, v)
}

func (ec *executionContext) unmarshalOArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx context.Context, v interface{}) ([]armor.ArmorCategory, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]armor.ArmorCategory, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx context.Context, sel ast.SelectionSet, v []armor.ArmorCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx context.Context, v interface{}) (*armor.ArmorCategory, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(armor.ArmorCategory)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOArmorArmorCategory2githubcomecshrevedndgenentarmorArmorCategory(ctx context.Context, sel ast.SelectionSet, v *armor.ArmorCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOArmorWhereInput2githubcomecshrevedndgenentArmorWhereInput(ctx context.Context, v interface{}) ([]*ent.ArmorWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ArmorWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNArmorWhereInput2githubcomecshrevedndgenentArmorWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOArmorWhereInput2githubcomecshrevedndgenentArmorWhereInput(ctx context.Context, v interface{}) (*ent.ArmorWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputArmorWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCharacter2githubcomecshrevedndgenentCharacter(ctx context.Context, sel ast.SelectionSet, v []*ent.Character) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacter2githubcomecshrevedndgenentCharacter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCharacter2githubcomecshrevedndgenentCharacter(ctx context.Context, sel ast.SelectionSet, v *ent.Character) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Character(ctx, sel, v)
}

func (ec *executionContext) marshalOCharacterAbilityScore2githubcomecshrevedndgenentCharacterAbilityScore(ctx context.Context, sel ast.SelectionSet, v []*ent.CharacterAbilityScore) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterAbilityScore2githubcomecshrevedndgenentCharacterAbilityScore(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOCharacterAbilityScoreWhereInput2githubcomecshrevedndgenentCharacterAbilityScoreWhereInput(ctx context.Context, v interface{}) ([]*ent.CharacterAbilityScoreWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.CharacterAbilityScoreWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCharacterAbilityScoreWhereInput2githubcomecshrevedndgenentCharacterAbilityScoreWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCharacterAbilityScoreWhereInput2githubcomecshrevedndgenentCharacterAbilityScoreWhereInput(ctx context.Context, v interface{}) (*ent.CharacterAbilityScoreWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCharacterAbilityScoreWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCharacterEdge2githubcomecshrevedndgenentCharacterEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.CharacterEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCharacterEdge2githubcomecshrevedndgenentCharacterEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOCharacterEdge2githubcomecshrevedndgenentCharacterEdge(ctx context.Context, sel ast.SelectionSet, v *ent.CharacterEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CharacterEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCharacterOrder2githubcomecshrevedndgenentCharacterOrder(ctx context.Context, v interface{}) (*ent.CharacterOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCharacterOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCharacterProficiency2githubcomecshrevedndgenentCharacterProficiency(ctx context.Context, sel ast.SelectionSet, v []*ent.CharacterProficiency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterProficiency2githubcomecshrevedndgenentCharacterProficiency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCharacterProficiency2githubcomecshrevedndgenentCharacterProficiency(ctx context.Context, sel ast.SelectionSet, v *ent.CharacterProficiency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CharacterProficiency(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx context.Context, v interface{}) ([]characterproficiency.ProficiencySource, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]characterproficiency.ProficiencySource, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx context.Context, sel ast.SelectionSet, v []characterproficiency.ProficiencySource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx context.Context, v interface{}) (*characterproficiency.ProficiencySource, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(characterproficiency.ProficiencySource)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCharacterProficiencyProficiencySource2githubcomecshrevedndgenentcharacterproficiencyProficiencySource(ctx context.Context, sel ast.SelectionSet, v *characterproficiency.ProficiencySource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx context.Context, v interface{}) ([]characterproficiency.ProficiencyType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]characterproficiency.ProficiencyType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx context.Context, sel ast.SelectionSet, v []characterproficiency.ProficiencyType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx context.Context, v interface{}) (*characterproficiency.ProficiencyType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(characterproficiency.ProficiencyType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCharacterProficiencyProficiencyType2githubcomecshrevedndgenentcharacterproficiencyProficiencyType(ctx context.Context, sel ast.SelectionSet, v *characterproficiency.ProficiencyType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOCharacterProficiencyWhereInput2githubcomecshrevedndgenentCharacterProficiencyWhereInput(ctx context.Context, v interface{}) ([]*ent.CharacterProficiencyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.CharacterProficiencyWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCharacterProficiencyWhereInput2githubcomecshrevedndgenentCharacterProficiencyWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCharacterProficiencyWhereInput2githubcomecshrevedndgenentCharacterProficiencyWhereInput(ctx context.Context, v interface{}) (*ent.CharacterProficiencyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCharacterProficiencyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCharacterSkill2githubcomecshrevedndgenentCharacterSkill(ctx context.Context, sel ast.SelectionSet, v []*ent.CharacterSkill) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterSkill2githubcomecshrevedndgenentCharacterSkill(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCharacterSkill2githubcomecshrevedndgenentCharacterSkill(ctx context.Context, sel ast.SelectionSet, v *ent.CharacterSkill) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CharacterSkill(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCharacterSkillWhereInput2githubcomecshrevedndgenentCharacterSkillWhereInput(ctx context.Context, v interface{}) ([]*ent.CharacterSkillWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.CharacterSkillWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCharacterSkillWhereInput2githubcomecshrevedndgenentCharacterSkillWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCharacterSkillWhereInput2githubcomecshrevedndgenentCharacterSkillWhereInput(ctx context.Context, v interface{}) (*ent.CharacterSkillWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCharacterSkillWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx context.Context, v interface{}) ([]*ent.CharacterWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.CharacterWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCharacterWhereInput2githubcomecshrevedndgenentCharacterWhereInput(ctx context.Context, v interface{}) (*ent.CharacterWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCharacterWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOClass2githubcomecshrevedndgenentClass(ctx context.Context, sel ast.SelectionSet, v []*ent.Class) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNClass2githubcomecshrevedndgenentClass(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOClass2githubcomecshrevedndgenentClass(ctx context.Context, sel ast.SelectionSet, v *ent.Class) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Class(ctx, sel, v)
}

func (ec *executionContext) unmarshalOClassWhereInput2githubcomecshrevedndgenentClassWhereInput(ctx context.Context, v interface{}) ([]*ent.ClassWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ClassWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNClassWhereInput2githubcomecshrevedndgenentClassWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOClassWhereInput2githubcomecshrevedndgenentClassWhereInput(ctx context.Context, v interface{}) (*ent.ClassWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputClassWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCoinWhereInput2githubcomecshrevedndgenentCoinWhereInput(ctx context.Context, v interface{}) ([]*ent.CoinWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.CoinWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCoinWhereInput2githubcomecshrevedndgenentCoinWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCoinWhereInput2githubcomecshrevedndgenentCoinWhereInput(ctx context.Context, v interface{}) (*ent.CoinWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCoinWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOConditionWhereInput2githubcomecshrevedndgenentConditionWhereInput(ctx context.Context, v interface{}) ([]*ent.ConditionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ConditionWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNConditionWhereInput2githubcomecshrevedndgenentConditionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOConditionWhereInput2githubcomecshrevedndgenentConditionWhereInput(ctx context.Context, v interface{}) (*ent.ConditionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputConditionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCost2githubcomecshrevedndgenentCost(ctx context.Context, sel ast.SelectionSet, v *ent.Cost) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Cost(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCostWhereInput2githubcomecshrevedndgenentCostWhereInput(ctx context.Context, v interface{}) ([]*ent.CostWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.CostWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNCostWhereInput2githubcomecshrevedndgenentCostWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOCostWhereInput2githubcomecshrevedndgenentCostWhereInput(ctx context.Context, v interface{}) (*ent.CostWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCostWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursor2entgoiocontribentgqlCursor(ctx context.Context, v interface{}) (*entgql.Cursor[int], error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entgql.Cursor[int])
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2entgoiocontribentgqlCursor(ctx context.Context, sel ast.SelectionSet, v *entgql.Cursor[int]) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalODamageType2githubcomecshrevedndgenentDamageType(ctx context.Context, sel ast.SelectionSet, v *ent.DamageType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DamageType(ctx, sel, v)
}

func (ec *executionContext) unmarshalODamageTypeWhereInput2githubcomecshrevedndgenentDamageTypeWhereInput(ctx context.Context, v interface{}) ([]*ent.DamageTypeWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.DamageTypeWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDamageTypeWhereInput2githubcomecshrevedndgenentDamageTypeWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalODamageTypeWhereInput2githubcomecshrevedndgenentDamageTypeWhereInput(ctx context.Context, v interface{}) (*ent.DamageTypeWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDamageTypeWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEquipment2githubcomecshrevedndgenentEquipment(ctx context.Context, sel ast.SelectionSet, v *ent.Equipment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Equipment(ctx, sel, v)
}

func (ec *executionContext) marshalOEquipmentEdge2githubcomecshrevedndgenentEquipmentEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.EquipmentEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEquipmentEdge2githubcomecshrevedndgenentEquipmentEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOEquipmentEdge2githubcomecshrevedndgenentEquipmentEdge(ctx context.Context, sel ast.SelectionSet, v *ent.EquipmentEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EquipmentEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOEquipmentEntry2githubcomecshrevedndgenentEquipmentEntry(ctx context.Context, sel ast.SelectionSet, v []*ent.EquipmentEntry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEquipmentEntry2githubcomecshrevedndgenentEquipmentEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOEquipmentEntryWhereInput2githubcomecshrevedndgenentEquipmentEntryWhereInput(ctx context.Context, v interface{}) ([]*ent.EquipmentEntryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.EquipmentEntryWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEquipmentEntryWhereInput2githubcomecshrevedndgenentEquipmentEntryWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOEquipmentEntryWhereInput2githubcomecshrevedndgenentEquipmentEntryWhereInput(ctx context.Context, v interface{}) (*ent.EquipmentEntryWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEquipmentEntryWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx context.Context, v interface{}) ([]equipment.EquipmentCategory, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]equipment.EquipmentCategory, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx context.Context, sel ast.SelectionSet, v []equipment.EquipmentCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx context.Context, v interface{}) (*equipment.EquipmentCategory, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(equipment.EquipmentCategory)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEquipmentEquipmentCategory2githubcomecshrevedndgenentequipmentEquipmentCategory(ctx context.Context, sel ast.SelectionSet, v *equipment.EquipmentCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEquipmentOrder2githubcomecshrevedndgenentEquipmentOrder(ctx context.Context, v interface{}) (*ent.EquipmentOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEquipmentOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx context.Context, v interface{}) ([]*ent.EquipmentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.EquipmentWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOEquipmentWhereInput2githubcomecshrevedndgenentEquipmentWhereInput(ctx context.Context, v interface{}) (*ent.EquipmentWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEquipmentWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFeatWhereInput2githubcomecshrevedndgenentFeatWhereInput(ctx context.Context, v interface{}) ([]*ent.FeatWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.FeatWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFeatWhereInput2githubcomecshrevedndgenentFeatWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFeatWhereInput2githubcomecshrevedndgenentFeatWhereInput(ctx context.Context, v interface{}) (*ent.FeatWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeatWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeature2githubcomecshrevedndgenentFeature(ctx context.Context, sel ast.SelectionSet, v *ent.Feature) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Feature(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFeatureWhereInput2githubcomecshrevedndgenentFeatureWhereInput(ctx context.Context, v interface{}) ([]*ent.FeatureWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.FeatureWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFeatureWhereInput2githubcomecshrevedndgenentFeatureWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFeatureWhereInput2githubcomecshrevedndgenentFeatureWhereInput(ctx context.Context, v interface{}) (*ent.FeatureWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeatureWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) ([]float64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]float64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFloat2float64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v []float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNFloat2float64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOGear2githubcomecshrevedndgenentGear(ctx context.Context, sel ast.SelectionSet, v *ent.Gear) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Gear(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGearWhereInput2githubcomecshrevedndgenentGearWhereInput(ctx context.Context, v interface{}) ([]*ent.GearWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GearWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGearWhereInput2githubcomecshrevedndgenentGearWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGearWhereInput2githubcomecshrevedndgenentGearWhereInput(ctx context.Context, v interface{}) (*ent.GearWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGearWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalIntID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalIntID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOLanguage2githubcomecshrevedndgenentLanguage(ctx context.Context, sel ast.SelectionSet, v []*ent.Language) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLanguage2githubcomecshrevedndgenentLanguage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLanguageChoice2githubcomecshrevedndgenentLanguageChoice(ctx context.Context, sel ast.SelectionSet, v []*ent.LanguageChoice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLanguageChoice2githubcomecshrevedndgenentLanguageChoice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLanguageChoice2githubcomecshrevedndgenentLanguageChoice(ctx context.Context, sel ast.SelectionSet, v *ent.LanguageChoice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LanguageChoice(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLanguageChoiceWhereInput2githubcomecshrevedndgenentLanguageChoiceWhereInput(ctx context.Context, v interface{}) ([]*ent.LanguageChoiceWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.LanguageChoiceWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLanguageChoiceWhereInput2githubcomecshrevedndgenentLanguageChoiceWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLanguageChoiceWhereInput2githubcomecshrevedndgenentLanguageChoiceWhereInput(ctx context.Context, v interface{}) (*ent.LanguageChoiceWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLanguageChoiceWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx context.Context, v interface{}) ([]language.LanguageType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]language.LanguageType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx context.Context, sel ast.SelectionSet, v []language.LanguageType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx context.Context, v interface{}) (*language.LanguageType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(language.LanguageType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLanguageLanguageType2githubcomecshrevedndgenentlanguageLanguageType(ctx context.Context, sel ast.SelectionSet, v *language.LanguageType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx context.Context, v interface{}) ([]language.Script, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]language.Script, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx context.Context, sel ast.SelectionSet, v []language.Script) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx context.Context, v interface{}) (*language.Script, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(language.Script)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLanguageScript2githubcomecshrevedndgenentlanguageScript(ctx context.Context, sel ast.SelectionSet, v *language.Script) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLanguageWhereInput2githubcomecshrevedndgenentLanguageWhereInput(ctx context.Context, v interface{}) ([]*ent.LanguageWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.LanguageWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLanguageWhereInput2githubcomecshrevedndgenentLanguageWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLanguageWhereInput2githubcomecshrevedndgenentLanguageWhereInput(ctx context.Context, v interface{}) (*ent.LanguageWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLanguageWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMagicSchoolWhereInput2githubcomecshrevedndgenentMagicSchoolWhereInput(ctx context.Context, v interface{}) ([]*ent.MagicSchoolWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.MagicSchoolWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMagicSchoolWhereInput2githubcomecshrevedndgenentMagicSchoolWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOMagicSchoolWhereInput2githubcomecshrevedndgenentMagicSchoolWhereInput(ctx context.Context, v interface{}) (*ent.MagicSchoolWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMagicSchoolWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONode2githubcomecshrevedndgenentNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOPrerequisite2githubcomecshrevedndgenentPrerequisite(ctx context.Context, sel ast.SelectionSet, v []*ent.Prerequisite) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPrerequisite2githubcomecshrevedndgenentPrerequisite(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx context.Context, v interface{}) ([]prerequisite.PrerequisiteType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]prerequisite.PrerequisiteType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx context.Context, sel ast.SelectionSet, v []prerequisite.PrerequisiteType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx context.Context, v interface{}) (*prerequisite.PrerequisiteType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(prerequisite.PrerequisiteType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPrerequisitePrerequisiteType2githubcomecshrevedndgenentprerequisitePrerequisiteType(ctx context.Context, sel ast.SelectionSet, v *prerequisite.PrerequisiteType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPrerequisiteWhereInput2githubcomecshrevedndgenentPrerequisiteWhereInput(ctx context.Context, v interface{}) ([]*ent.PrerequisiteWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.PrerequisiteWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPrerequisiteWhereInput2githubcomecshrevedndgenentPrerequisiteWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPrerequisiteWhereInput2githubcomecshrevedndgenentPrerequisiteWhereInput(ctx context.Context, v interface{}) (*ent.PrerequisiteWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPrerequisiteWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProficiency2githubcomecshrevedndgenentProficiency(ctx context.Context, sel ast.SelectionSet, v []*ent.Proficiency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProficiency2githubcomecshrevedndgenentProficiency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOProficiencyChoice2githubcomecshrevedndgenentProficiencyChoice(ctx context.Context, sel ast.SelectionSet, v []*ent.ProficiencyChoice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProficiencyChoice2githubcomecshrevedndgenentProficiencyChoice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOProficiencyChoiceWhereInput2githubcomecshrevedndgenentProficiencyChoiceWhereInput(ctx context.Context, v interface{}) ([]*ent.ProficiencyChoiceWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ProficiencyChoiceWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProficiencyChoiceWhereInput2githubcomecshrevedndgenentProficiencyChoiceWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProficiencyChoiceWhereInput2githubcomecshrevedndgenentProficiencyChoiceWhereInput(ctx context.Context, v interface{}) (*ent.ProficiencyChoiceWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProficiencyChoiceWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProficiencyWhereInput2githubcomecshrevedndgenentProficiencyWhereInput(ctx context.Context, v interface{}) ([]*ent.ProficiencyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ProficiencyWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProficiencyWhereInput2githubcomecshrevedndgenentProficiencyWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProficiencyWhereInput2githubcomecshrevedndgenentProficiencyWhereInput(ctx context.Context, v interface{}) (*ent.ProficiencyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProficiencyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProperty2githubcomecshrevedndgenentProperty(ctx context.Context, sel ast.SelectionSet, v []*ent.Property) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProperty2githubcomecshrevedndgenentProperty(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPropertyWhereInput2githubcomecshrevedndgenentPropertyWhereInput(ctx context.Context, v interface{}) ([]*ent.PropertyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.PropertyWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPropertyWhereInput2githubcomecshrevedndgenentPropertyWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPropertyWhereInput2githubcomecshrevedndgenentPropertyWhereInput(ctx context.Context, v interface{}) (*ent.PropertyWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPropertyWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORace2githubcomecshrevedndgenentRace(ctx context.Context, sel ast.SelectionSet, v []*ent.Race) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRace2githubcomecshrevedndgenentRace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalORace2githubcomecshrevedndgenentRace(ctx context.Context, sel ast.SelectionSet, v *ent.Race) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Race(ctx, sel, v)
}

func (ec *executionContext) unmarshalORaceSize2githubcomecshrevedndgenentraceSize(ctx context.Context, v interface{}) ([]race.Size, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]race.Size, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRaceSize2githubcomecshrevedndgenentraceSize(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalORaceSize2githubcomecshrevedndgenentraceSize(ctx context.Context, sel ast.SelectionSet, v []race.Size) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRaceSize2githubcomecshrevedndgenentraceSize(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalORaceSize2githubcomecshrevedndgenentraceSize(ctx context.Context, v interface{}) (*race.Size, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(race.Size)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORaceSize2githubcomecshrevedndgenentraceSize(ctx context.Context, sel ast.SelectionSet, v *race.Size) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalORaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx context.Context, v interface{}) ([]*ent.RaceWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.RaceWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalORaceWhereInput2githubcomecshrevedndgenentRaceWhereInput(ctx context.Context, v interface{}) (*ent.RaceWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRaceWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORule2githubcomecshrevedndgenentRule(ctx context.Context, sel ast.SelectionSet, v *ent.Rule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Rule(ctx, sel, v)
}

func (ec *executionContext) marshalORuleSection2githubcomecshrevedndgenentRuleSection(ctx context.Context, sel ast.SelectionSet, v []*ent.RuleSection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRuleSection2githubcomecshrevedndgenentRuleSection(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalORuleSectionWhereInput2githubcomecshrevedndgenentRuleSectionWhereInput(ctx context.Context, v interface{}) ([]*ent.RuleSectionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.RuleSectionWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRuleSectionWhereInput2githubcomecshrevedndgenentRuleSectionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalORuleSectionWhereInput2githubcomecshrevedndgenentRuleSectionWhereInput(ctx context.Context, v interface{}) (*ent.RuleSectionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRuleSectionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORuleWhereInput2githubcomecshrevedndgenentRuleWhereInput(ctx context.Context, v interface{}) ([]*ent.RuleWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.RuleWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRuleWhereInput2githubcomecshrevedndgenentRuleWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalORuleWhereInput2githubcomecshrevedndgenentRuleWhereInput(ctx context.Context, v interface{}) (*ent.RuleWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRuleWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSkill2githubcomecshrevedndgenentSkill(ctx context.Context, sel ast.SelectionSet, v []*ent.Skill) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSkill2githubcomecshrevedndgenentSkill(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSkillWhereInput2githubcomecshrevedndgenentSkillWhereInput(ctx context.Context, v interface{}) ([]*ent.SkillWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.SkillWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSkillWhereInput2githubcomecshrevedndgenentSkillWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSkillWhereInput2githubcomecshrevedndgenentSkillWhereInput(ctx context.Context, v interface{}) (*ent.SkillWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSkillWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTool2githubcomecshrevedndgenentTool(ctx context.Context, sel ast.SelectionSet, v *ent.Tool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tool(ctx, sel, v)
}

func (ec *executionContext) unmarshalOToolWhereInput2githubcomecshrevedndgenentToolWhereInput(ctx context.Context, v interface{}) ([]*ent.ToolWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ToolWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNToolWhereInput2githubcomecshrevedndgenentToolWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOToolWhereInput2githubcomecshrevedndgenentToolWhereInput(ctx context.Context, v interface{}) (*ent.ToolWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputToolWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTrait2githubcomecshrevedndgenentTrait(ctx context.Context, sel ast.SelectionSet, v []*ent.Trait) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTrait2githubcomecshrevedndgenentTrait(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTraitWhereInput2githubcomecshrevedndgenentTraitWhereInput(ctx context.Context, v interface{}) ([]*ent.TraitWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.TraitWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTraitWhereInput2githubcomecshrevedndgenentTraitWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTraitWhereInput2githubcomecshrevedndgenentTraitWhereInput(ctx context.Context, v interface{}) (*ent.TraitWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTraitWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVehicle2githubcomecshrevedndgenentVehicle(ctx context.Context, sel ast.SelectionSet, v *ent.Vehicle) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Vehicle(ctx, sel, v)
}

func (ec *executionContext) unmarshalOVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx context.Context, v interface{}) (vehicle.SpeedUnits, error) {
	var res vehicle.SpeedUnits
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx context.Context, sel ast.SelectionSet, v vehicle.SpeedUnits) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx context.Context, v interface{}) ([]vehicle.SpeedUnits, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]vehicle.SpeedUnits, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx context.Context, sel ast.SelectionSet, v []vehicle.SpeedUnits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx context.Context, v interface{}) (*vehicle.SpeedUnits, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(vehicle.SpeedUnits)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVehicleSpeedUnits2githubcomecshrevedndgenentvehicleSpeedUnits(ctx context.Context, sel ast.SelectionSet, v *vehicle.SpeedUnits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx context.Context, v interface{}) ([]vehicle.VehicleCategory, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]vehicle.VehicleCategory, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx context.Context, sel ast.SelectionSet, v []vehicle.VehicleCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx context.Context, v interface{}) (*vehicle.VehicleCategory, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(vehicle.VehicleCategory)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVehicleVehicleCategory2githubcomecshrevedndgenentvehicleVehicleCategory(ctx context.Context, sel ast.SelectionSet, v *vehicle.VehicleCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOVehicleWhereInput2githubcomecshrevedndgenentVehicleWhereInput(ctx context.Context, v interface{}) ([]*ent.VehicleWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.VehicleWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVehicleWhereInput2githubcomecshrevedndgenentVehicleWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOVehicleWhereInput2githubcomecshrevedndgenentVehicleWhereInput(ctx context.Context, v interface{}) (*ent.VehicleWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputVehicleWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWeapon2githubcomecshrevedndgenentWeapon(ctx context.Context, sel ast.SelectionSet, v []*ent.Weapon) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWeapon2githubcomecshrevedndgenentWeapon(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOWeapon2githubcomecshrevedndgenentWeapon(ctx context.Context, sel ast.SelectionSet, v *ent.Weapon) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Weapon(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx context.Context, v interface{}) ([]weapon.WeaponCategory, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]weapon.WeaponCategory, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx context.Context, sel ast.SelectionSet, v []weapon.WeaponCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx context.Context, v interface{}) (*weapon.WeaponCategory, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(weapon.WeaponCategory)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWeaponWeaponCategory2githubcomecshrevedndgenentweaponWeaponCategory(ctx context.Context, sel ast.SelectionSet, v *weapon.WeaponCategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx context.Context, v interface{}) ([]weapon.WeaponSubcategory, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]weapon.WeaponSubcategory, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx context.Context, sel ast.SelectionSet, v []weapon.WeaponSubcategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx context.Context, v interface{}) (*weapon.WeaponSubcategory, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(weapon.WeaponSubcategory)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWeaponWeaponSubcategory2githubcomecshrevedndgenentweaponWeaponSubcategory(ctx context.Context, sel ast.SelectionSet, v *weapon.WeaponSubcategory) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOWeaponWhereInput2githubcomecshrevedndgenentWeaponWhereInput(ctx context.Context, v interface{}) ([]*ent.WeaponWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.WeaponWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWeaponWhereInput2githubcomecshrevedndgenentWeaponWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWeaponWhereInput2githubcomecshrevedndgenentWeaponWhereInput(ctx context.Context, v interface{}) (*ent.WeaponWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWeaponWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
